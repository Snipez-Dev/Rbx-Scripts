-- VanUI (robuste Version) - Dropdown & Colorpicker Verbesserungen
-- Änderungen:
-- 1) Dropdown: Tags / ausgewählte Items korrekt positioniert; ausgewählte Option im Dropdown heller hervorgehoben.
-- 2) MultiDropdown: Tags als Pills angezeigt (horizontal, sauber positioniert).
-- 3) Colorpicker: Interaktive HSV-Box + Hue-Slider + Hex-Eingabe + Farbvorschau (Google-ähnlich Verhalten).
-- 4) Alle vorherigen Robustheitsfixes (toNumberOrDefault, safe clamps, Dropdown default as string/index etc.) bleiben erhalten.
--
-- Vollständige Library (ersetze deine alte Library-Datei damit)

local Library = {}
Library.Windows = {}
Library.MainWindow = nil

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local TextService = game:GetService("TextService")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")

local function New(ClassName, Properties)
	local Object = Instance.new(ClassName)
	if Properties then
		for Property, Value in next, Properties do
			pcall(function() Object[Property] = Value end)
		end
	end
	return Object
end

local DEFAULT_THEME = {
	Background = Color3.fromRGB(7,7,7),
	Panel = Color3.fromRGB(20,20,20),
	PanelStroke = Color3.fromRGB(25,25,25),
	Tab = Color3.fromRGB(15,15,15),
	TabStroke = Color3.fromRGB(116,116,116),
	ToggleBg = Color3.fromRGB(38,38,38),
	ToggleOn = Color3.fromRGB(230,230,230),
	ToggleOff = Color3.fromRGB(30,30,30),
	Fill = Color3.fromRGB(200,200,200),
	ControlBtnText = Color3.fromRGB(150,150,150)
}

local function themeGet(theme, key)
	if theme and type(theme) == "table" and theme[key] ~= nil then return theme[key] end
	return DEFAULT_THEME[key]
end

local function getViewport()
	if workspace and workspace.CurrentCamera then
		return workspace.CurrentCamera.ViewportSize
	end
	return Vector2.new(1920,1080)
end

-- Utility: sichere Konvertierung / Clamp
local function toNumberOrDefault(v, default)
	if type(v) == "number" then return v end
	if type(v) == "string" then
		local n = tonumber(v)
		if type(n) == "number" then return n end
	end
	return default
end

local function toIndexFromValue(val, options, defaultIndex)
	if not options or #options == 0 then return 1 end
	if type(val) == "number" then
		return math.clamp(math.floor(val), 1, #options)
	end
	if type(val) == "string" then
		for i, v in ipairs(options) do
			if tostring(v) == val then
				return i
			end
		end
		local n = tonumber(val)
		if type(n) == "number" then
			return math.clamp(math.floor(n), 1, #options)
		end
	end
	if type(defaultIndex) == "number" then
		return math.clamp(math.floor(defaultIndex), 1, #options)
	end
	return 1
end

-- Color helpers (RGB <-> HSV)
local function RGBToHSV(c)
	-- c: Color3
	local r, g, b = c.r, c.g, c.b
	local maxv = math.max(r,g,b)
	local minv = math.min(r,g,b)
	local delta = maxv - minv
	local h = 0
	if delta == 0 then
		h = 0
	else
		if maxv == r then
			h = (g - b) / delta
			h = h % 6
		elseif maxv == g then
			h = (b - r) / delta + 2
		else
			h = (r - g) / delta + 4
		end
		h = h * 60
		if h < 0 then h = h + 360 end
	end
	local s = 0
	if maxv ~= 0 then s = delta / maxv end
	local v = maxv
	return h, s, v
end

local function HSVToRGB(h, s, v)
	h = h % 360
	local c = v * s
	local x = c * (1 - math.abs(((h / 60) % 2) - 1))
	local m = v - c
	local r1, g1, b1 = 0,0,0
	if h < 60 then r1, g1, b1 = c, x, 0
	elseif h < 120 then r1, g1, b1 = x, c, 0
	elseif h < 180 then r1, g1, b1 = 0, c, x
	elseif h < 240 then r1, g1, b1 = 0, x, c
	elseif h < 300 then r1, g1, b1 = x, 0, c
	else r1, g1, b1 = c, 0, x end
	return Color3.new(r1 + m, g1 + m, b1 + m)
end

local function lightenColor(c, amount)
	-- amount 0..1 -> returns brighter color by interpolation towards white
	amount = math.clamp(toNumberOrDefault(amount, 0.15), 0, 1)
	return Color3.new(
		math.clamp(c.r + (1 - c.r) * amount, 0, 1),
		math.clamp(c.g + (1 - c.g) * amount, 0, 1),
		math.clamp(c.b + (1 - c.b) * amount, 0, 1)
	)
end

-- Mobile detection
local function detectMobile()
	local isTouchEnabled = UserInputService.TouchEnabled
	local hasKeyboard = UserInputService.KeyboardEnabled
	local vp = getViewport()
	return isTouchEnabled and (not hasKeyboard or vp.X < 800 or vp.Y < 600)
end

function Library:CreateWindow(title, subtitle, opts)
	opts = opts or {}
	local theme = opts.theme or nil

	if Library.MainWindow and not opts.force then
		return Library.MainWindow
	end

	if opts.force and Library.MainWindow then
		pcall(function() Library.MainWindow:Destroy() end)
	end

	local isMobile = detectMobile()
	local vp = getViewport()

	local scaleFactor = 1
	local defaultW, defaultH = 760, 420

	if isMobile then
		scaleFactor = 0.65
		if vp.X < 500 then scaleFactor = 0.55 end
		defaultW = math.floor(vp.X * 0.82)
		defaultH = math.floor(vp.Y * 0.62)
	end

	local sizeUDim
	if opts.size and typeof(opts.size) == "UDim2" then
		sizeUDim = opts.size
	elseif opts.width and opts.height then
		local w = toNumberOrDefault(opts.width, defaultW)
		local h = toNumberOrDefault(opts.height, defaultH)
		sizeUDim = UDim2.new(0, w, 0, h)
	else
		sizeUDim = UDim2.new(0, defaultW, 0, defaultH)
	end
	local absW = sizeUDim.X.Offset
	local absH = sizeUDim.Y.Offset

	if isMobile then
		absW = math.clamp(absW, 280, math.floor(vp.X * 0.98))
		absH = math.clamp(absH, 320, math.floor(vp.Y * 0.95))
	end

	local ScreenGui = New("ScreenGui", {
		Name = "VanUI",
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
		ResetOnSpawn = false
	})
	ScreenGui.Parent = CoreGui

	if isMobile then
		ScreenGui.IgnoreGuiInset = true
	end

	local Background = New("Frame", {
		Name = "Background",
		Parent = ScreenGui,
		AnchorPoint = Vector2.new(0.5,0.5),
		BackgroundColor3 = themeGet(theme, "Background"),
		BorderSizePixel = 0,
		ClipsDescendants = true,
		Position = UDim2.new(0.5, 0, 0.5, 0),
		Size = UDim2.new(0, 0, 0, 0),
		BackgroundTransparency = 1
	})
	New("UICorner", {CornerRadius = UDim.new(0.02,0), Parent = Background})
	local BackgroundStroke = New("UIStroke", {Color = themeGet(theme, "PanelStroke"), Thickness = 1, Transparency = 1, Parent = Background})

	TweenService:Create(Background, TweenInfo.new(0.45, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, absW, 0, absH),
		BackgroundTransparency = 0
	}):Play()
	task.wait(0.22)
	TweenService:Create(BackgroundStroke, TweenInfo.new(0.22), { Transparency = 0 }):Play()

	local HeaderHeight = isMobile and 48 or 60
	local TitleFontSize = isMobile and 13 or 16
	local SubtitleFontSize = isMobile and 10 or 12
	local TabButtonFontSize = isMobile and 11 or 14
	local ElementFontSize = isMobile and 12 or 14
	local SmallFontSize = isMobile and 10 or 13

	local TopBar = New("Frame", {
		Name = "TopBar",
		Parent = Background,
		BackgroundTransparency = 1,
		Position = UDim2.new(0,0,0,0),
		Size = UDim2.new(1,0,0,HeaderHeight)
	})

	local titleYPos = isMobile and 0.15 or 0.18
	local subtitleYPos = isMobile and 0.58 or 0.55

	local TitleLabel = New("TextLabel", {
		Name = "title",
		Parent = TopBar,
		BackgroundTransparency = 1,
		Position = UDim2.new(0.03,0,titleYPos,0),
		Size = UDim2.new(0.5,0,0,TitleFontSize + 8),
		Font = Enum.Font.GothamMedium,
		Text = title or "VanUI",
		TextColor3 = Color3.fromRGB(255,255,255),
		TextSize = TitleFontSize,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextYAlignment = Enum.TextYAlignment.Center
	})

	New("TextLabel", {
		Name = "subtitle",
		Parent = TopBar,
		BackgroundTransparency = 1,
		Position = UDim2.new(0.03,0,subtitleYPos,0),
		Size = UDim2.new(0.5,0,0,SubtitleFontSize + 2),
		Font = Enum.Font.Gotham,
		Text = subtitle or "",
		TextColor3 = Color3.fromRGB(150,150,150),
		TextSize = SubtitleFontSize,
		TextXAlignment = Enum.TextXAlignment.Left
	})

	local btnSizeW = isMobile and 32 or 28
	local btnSizeH = isMobile and 24 or 20
	local btnFontSize = isMobile and 16 or 18
	local controlsWidth = (btnSizeW * 2) + 8

	local ControlsFrame = New("Frame", {
		Name = "WindowControls",
		Parent = TopBar,
		BackgroundTransparency = 1,
		Size = UDim2.new(0, controlsWidth, 0, btnSizeH),
		Position = UDim2.new(1,-10,0, isMobile and 6 or 8),
		AnchorPoint = Vector2.new(1,0)
	})
	New("UIListLayout", {
		Parent = ControlsFrame,
		FillDirection = Enum.FillDirection.Horizontal,
		HorizontalAlignment = Enum.HorizontalAlignment.Right,
		VerticalAlignment = Enum.VerticalAlignment.Center,
		SortOrder = Enum.SortOrder.LayoutOrder,
		Padding = UDim.new(0, isMobile and 4 or 6)
	})

	local function makeControl(symbol)
		local btn = New("TextButton", {
			Parent = ControlsFrame,
			BackgroundColor3 = Background.BackgroundColor3,
			BorderSizePixel = 0,
			Size = UDim2.new(0, btnSizeW, 0, btnSizeH),
			AutoButtonColor = false,
			Font = Enum.Font.SourceSansBold,
			Text = symbol,
			TextColor3 = themeGet(theme, "ControlBtnText"),
			TextSize = btnFontSize,
			TextScaled = true
		})
		New("UICorner", {Parent = btn, CornerRadius = UDim.new(0.08,0)})
		New("UIStroke", {Parent = btn, Color = themeGet(theme, "PanelStroke"), Thickness = 1})
		return btn
	end
	local MinBtn = makeControl("➖")
	local CloseBtn = makeControl("❌")

	local TabWidth = isMobile and (absW < 400 and 90 or 110) or 170
	local TabLeftPadding = isMobile and 6 or 12
	local ContentLeftPadding = isMobile and 6 or 12
	local ContentLeft = TabLeftPadding + TabWidth + ContentLeftPadding
	local ContentWidth = math.max(120, absW - ContentLeft - (isMobile and 6 or 12))
	local ContentHeight = math.max(80, absH - HeaderHeight - (isMobile and 10 or 20))

	local TabContainer = New("Frame", {
		Name = "TabContainer",
		Parent = Background,
		BackgroundTransparency = 1,
		Position = UDim2.new(0, TabLeftPadding, 0, HeaderHeight),
		Size = UDim2.new(0, TabWidth, 0, ContentHeight)
	})
	New("UIListLayout", {
		Parent = TabContainer,
		SortOrder = Enum.SortOrder.LayoutOrder,
		Padding = UDim.new(0, isMobile and 5 or 8)
	})

	local ContentContainer = New("ScrollingFrame", {
		Name = "ContentContainer",
		Parent = Background,
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Position = UDim2.new(0, ContentLeft, 0, HeaderHeight - 2),
		Size = UDim2.new(0, ContentWidth, 0, ContentHeight + 2),
		CanvasSize = UDim2.new(0,0,0,0),
		ScrollBarThickness = isMobile and 4 or 6
	})

	local contentPadding = isMobile and 6 or 10
	New("UIPadding", {
		Parent = ContentContainer,
		PaddingLeft = UDim.new(0,contentPadding),
		PaddingRight = UDim.new(0,contentPadding),
		PaddingTop = UDim.new(0,contentPadding)
	})

	local contentLayout = New("UIListLayout", {
		Parent = ContentContainer,
		SortOrder = Enum.SortOrder.LayoutOrder,
		Padding = UDim.new(0, isMobile and 5 or 8)
	})
	contentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		ContentContainer.CanvasSize = UDim2.new(0,0,0, contentLayout.AbsoluteContentSize.Y + contentPadding * 2)
	end)

	local ContentBackground = New("Frame", {
		Parent = Background,
		BackgroundColor3 = themeGet(theme, "Panel"),
		BackgroundTransparency = 0.3,
		BorderSizePixel = 0,
		Position = UDim2.new(0, ContentLeft, 0, HeaderHeight),
		Size = UDim2.new(0, ContentWidth, 0, ContentHeight)
	})
	New("UICorner", {Parent = ContentBackground, CornerRadius = UDim.new(0.01,0)})
	New("UIStroke", {Parent = ContentBackground, Color = themeGet(theme, "PanelStroke"), Thickness = 1})

	local Window = {}
	Window.Tabs = {}
	Window.CurrentTab = nil
	Window._isMinimized = false
	Window._ScreenGui = ScreenGui
	Window._restoreGui = nil
	Window._isMobile = isMobile
	Window._restorePosition = Window._restorePosition or nil
	Window._Keybinds = Window._Keybinds or {}

	local dragging, dragInput, dragStart, startPos, dragTween
	TopBar.InputBegan:Connect(function(input)
		local inputType = input.UserInputType
		if inputType == Enum.UserInputType.MouseButton1 or inputType == Enum.UserInputType.Touch then
			local bgPos = Background.AbsolutePosition
			local bgSize = Background.AbsoluteSize
			local clickX = input.Position.X
			if clickX <= bgPos.X + (bgSize.X * 0.5) then
				dragging = true
				dragStart = input.Position
				startPos = Background.Position
				if dragTween then dragTween:Cancel() end
				input.Changed:Connect(function()
					if input.UserInputState == Enum.UserInputState.End then dragging = false end
				end)
			end
		end
	end)

	TopBar.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		local inputType = input.UserInputType
		if input == dragInput and dragging and (inputType == Enum.UserInputType.MouseMovement or inputType == Enum.UserInputType.Touch) then
			local delta = input.Position - dragStart
			local newPosition = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
			if dragTween then dragTween:Cancel() end
			dragTween = TweenService:Create(Background, TweenInfo.new(0.09, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Position = newPosition })
			dragTween:Play()
		end
	end)

	CloseBtn.MouseButton1Click:Connect(function()
		if Window._ScreenGui then pcall(function() Window._ScreenGui:Destroy() end) end
		if Window._restoreGui then pcall(function() Window._restoreGui:Destroy() end) end
		for i, w in pairs(Library.Windows) do if w == Window then table.remove(Library.Windows, i); break end end
		if Library.MainWindow == Window then Library.MainWindow = nil end
	end)

	MinBtn.MouseButton1Click:Connect(function()
		if Window._isMinimized then
			if Window._restoreGui then pcall(function() Window._restoreGui:Destroy() end) end
			Window._restoreGui = nil
			Background.Visible = true
			Window._isMinimized = false
		else
			Background.Visible = false
			Window._isMinimized = true

			if Window._restoreGui then
				pcall(function() Window._restoreGui:Destroy() end)
				Window._restoreGui = nil
			end

			local RestoreGui = New("ScreenGui", {
				Name = "VanUI_Restore",
				ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
				ResetOnSpawn = false
			})
			RestoreGui.Parent = CoreGui

			local vp2 = getViewport()
			local boxW = isMobile and 140 or 180
			local boxH = isMobile and 32 or 40
			local margin = isMobile and 8 or 18
			local minX = 8
			local maxX = math.max(8, vp2.X - boxW - 8)
			local centeredX = (vp2.X - boxW) / 2
			local initialX, initialY

			if Window._restorePosition and Window._restorePosition.X and Window._restorePosition.Y then
				local savedX = toNumberOrDefault(Window._restorePosition.X, centeredX)
				local savedY = toNumberOrDefault(Window._restorePosition.Y, margin)
				initialX = math.clamp(savedX, minX, maxX)
				initialY = math.clamp(savedY, margin, vp2.Y - boxH - margin)
			else
				initialX = math.clamp(centeredX, minX, maxX)
				initialY = margin
			end

			local Box = New("Frame", {
				Name = "RestoreBox",
				Parent = RestoreGui,
				AnchorPoint = Vector2.new(0,0),
				Size = UDim2.new(0, boxW, 0, boxH),
				Position = UDim2.new(0, initialX, 0, initialY),
				BackgroundColor3 = themeGet(theme, "Panel"),
				BorderSizePixel = 0
			})
			New("UICorner", { Parent = Box, CornerRadius = UDim.new(0.08,0) })
			New("UIStroke", { Parent = Box, Color = themeGet(theme, "PanelStroke"), Thickness = 1 })

			local labelSize = isMobile and 10 or 14
			local Label = New("TextLabel", {
				Parent = Box,
				BackgroundTransparency = 1,
				Size = UDim2.new(1, -(boxH + 4), 1, 0),
				Position = UDim2.new(0, 8, 0, 0),
				Font = Enum.Font.Gotham,
				Text = title or "VanUI",
				TextColor3 = Color3.fromRGB(255,255,255),
				TextSize = labelSize,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Center
			})

			local btnSize = isMobile and 26 or 34
			local RestoreBtn = New("TextButton", {
				Parent = Box,
				Size = UDim2.new(0, btnSize, 0, btnSize),
				Position = UDim2.new(1, -(btnSize + 3), 0.5, -(btnSize/2)),
				BackgroundColor3 = Background.BackgroundColor3,
				BorderSizePixel = 0,
				Text = "▣",
				Font = Enum.Font.SourceSansBold,
				TextColor3 = themeGet(theme, "ControlBtnText"),
				TextSize = isMobile and 14 or 18,
				TextScaled = true,
				AutoButtonColor = false
			})
			New("UICorner", { Parent = RestoreBtn, CornerRadius = UDim.new(0.08,0) })
			New("UIStroke", { Parent = RestoreBtn, Color = themeGet(theme, "PanelStroke"), Thickness = 1 })

			local function restoreWindow()
				if Window._restoreGui then pcall(function() Window._restoreGui:Destroy() end) end
				Window._restoreGui = nil
				Background.Visible = true
				Window._isMinimized = false
			end

			RestoreBtn.MouseButton1Click:Connect(restoreWindow)

			local draggingBox = false
			local dragStartPos = nil
			local boxStartPos = nil
			local hasMoved = false

			Box.InputBegan:Connect(function(inp)
				local inputType = inp.UserInputType
				if inputType == Enum.UserInputType.MouseButton1 or inputType == Enum.UserInputType.Touch then
					local mousePos = inp.Position
					local btnPos = RestoreBtn.AbsolutePosition
					local btnSizeVec = RestoreBtn.AbsoluteSize
					local isOnButton = mousePos.X >= btnPos.X and mousePos.X <= btnPos.X + btnSizeVec.X and
								mousePos.Y >= btnPos.Y and mousePos.Y <= btnPos.Y + btnSizeVec.Y

					if not isOnButton then
						draggingBox = true
						hasMoved = false
						dragStartPos = inp.Position
						boxStartPos = Vector2.new(Box.Position.X.Offset, Box.Position.Y.Offset)

						inp.Changed:Connect(function()
							if inp.UserInputState == Enum.UserInputState.End then
								draggingBox = false
								if not hasMoved then
									restoreWindow()
								else
									pcall(function()
										Window._restorePosition = { X = Box.Position.X.Offset, Y = Box.Position.Y.Offset }
									end)
								end
							end
						end)
					end
				end
			end)

			UserInputService.InputChanged:Connect(function(inp)
				local inputType = inp.UserInputType
				if draggingBox and (inputType == Enum.UserInputType.MouseMovement or inputType == Enum.UserInputType.Touch) and dragStartPos and boxStartPos then
					local delta = inp.Position - dragStartPos
					if math.abs(delta.X) > 5 or math.abs(delta.Y) > 5 then
						hasMoved = true
					end

					local newX = boxStartPos.X + delta.X
					local newY = boxStartPos.Y + delta.Y
					local vp3 = getViewport()
					newX = math.clamp(newX, 0, vp3.X - Box.AbsoluteSize.X)
					newY = math.clamp(newY, 0, vp3.Y - Box.AbsoluteSize.Y)
					Box.Position = UDim2.new(0, newX, 0, newY)
				end
			end)

			Window._restoreGui = RestoreGui
		end
	end)

	function Window:CreateTab(name)
		local Tab = {}
		local isFirst = #Window.Tabs == 0

		local tabHeight = isMobile and 28 or 35
		local TabButton = New("TextButton", {
			Name = "Tab_" .. name,
			Parent = TabContainer,
			BackgroundColor3 = themeGet(theme, "Tab"),
			BackgroundTransparency = isFirst and 0 or 1,
			BorderSizePixel = 0,
			Size = UDim2.new(1,0,0,tabHeight),
			Font = Enum.Font.Gotham,
			Text = name,
			TextColor3 = isFirst and Color3.fromRGB(255,255,255) or Color3.fromRGB(150,150,150),
			TextSize = TabButtonFontSize,
			TextXAlignment = Enum.TextXAlignment.Left,
			AutoButtonColor = false
		})
		New("UIPadding", {Parent = TabButton, PaddingLeft = UDim.new(0, isMobile and 4 or 5)})
		New("UICorner", {Parent = TabButton, CornerRadius = UDim.new(0.1,0)})
		New("UIStroke", {Parent = TabButton, Color = themeGet(theme, "TabStroke"), Thickness = 1, Transparency = isFirst and 0.8 or 1, ApplyStrokeMode = Enum.ApplyStrokeMode.Border})

		TabButton.MouseButton1Click:Connect(function()
			if Window.CurrentTab == Tab then return end
			for _, t in pairs(Window.Tabs) do
				TweenService:Create(t.Button, TweenInfo.new(0.18), { BackgroundTransparency = 1, TextColor3 = Color3.fromRGB(150,150,150) }):Play()
				local stroke = t.Button:FindFirstChildOfClass("UIStroke")
				if stroke then TweenService:Create(stroke, TweenInfo.new(0.18), {Transparency = 1}):Play() end
			end
			TweenService:Create(TabButton, TweenInfo.new(0.18), { BackgroundTransparency = 0, TextColor3 = Color3.fromRGB(255,255,255) }):Play()
			local stroke = TabButton:FindFirstChildOfClass("UIStroke")
			if stroke then TweenService:Create(stroke, TweenInfo.new(0.18), {Transparency = 0.8}):Play() end
			Window.CurrentTab = Tab
			Window:RefreshContent()
		end)

		Tab.Button = TabButton
		Tab.Elements = {}
		table.insert(Window.Tabs, Tab)
		if isFirst then Window.CurrentTab = Tab end

		function Tab:AddParagraph(titleText, contentText)
			local Paragraph = { Type = "Paragraph", Title = titleText, Content = contentText, Visible = true }
			table.insert(Tab.Elements, Paragraph)
			Window:RefreshContent()
			return {
				Hide = function() Paragraph.Visible = false; Window:RefreshContent() end,
				Show = function() Paragraph.Visible = true; Window:RefreshContent() end
			}
		end

		function Tab:AddButton(text, callback)
			local Button = { Type = "Button", Text = text, Callback = callback, Visible = true }
			table.insert(Tab.Elements, Button)
			Window:RefreshContent()
			return {
				Hide = function() Button.Visible = false; Window:RefreshContent() end,
				Show = function() Button.Visible = true; Window:RefreshContent() end
			}
		end

		function Tab:AddToggle(text, default, callback)
			local Toggle = { Type = "Toggle", Text = text, Value = default or false, Callback = callback, Visible = true }
			table.insert(Tab.Elements, Toggle)
			Window:RefreshContent()
			return {
				Set = function(self, value) Toggle.Value = value; Window:RefreshContent() end,
				Hide = function() Toggle.Visible = false; Window:RefreshContent() end,
				Show = function() Toggle.Visible = true; Window:RefreshContent() end
			}
		end

		function Tab:AddSlider(text, min, max, default, callback)
			min = toNumberOrDefault(min, 0)
			max = toNumberOrDefault(max, 100)
			if max < min then max = min end
			local defaultNum = toNumberOrDefault(default, min)
			local Slider = { Type = "Slider", Text = text, Min = min, Max = max, Value = math.clamp(defaultNum, min, max), Callback = callback, Visible = true }
			table.insert(Tab.Elements, Slider)
			Window:RefreshContent()
			return {
				Set = function(self, value)
					local num = toNumberOrDefault(value, Slider.Min)
					Slider.Value = math.clamp(num, Slider.Min, Slider.Max)
					Window:RefreshContent()
					if Slider.Callback then pcall(Slider.Callback, Slider.Value) end
				end,
				Hide = function() Slider.Visible = false; Window:RefreshContent() end,
				Show = function() Slider.Visible = true; Window:RefreshContent() end
			}
		end

		-- Dropdown: defaultIndex can be index or option string
		function Tab:AddDropdown(text, options, defaultIndex, callback)
			if type(options) ~= "table" then options = {} end
			local default = toIndexFromValue(defaultIndex, options, 1)
			local Dropdown = {
				Type = "Dropdown",
				Text = text,
				Options = options or {},
				Selected = default,
				Callback = callback,
				Visible = true,
				_Expanded = false
			}
			table.insert(Tab.Elements, Dropdown)
			Window:RefreshContent()
			return {
				Set = function(self, index)
					local idx = toIndexFromValue(index, Dropdown.Options, Dropdown.Selected)
					Dropdown.Selected = idx
					Window:RefreshContent()
					if Dropdown.Callback then pcall(Dropdown.Callback, Dropdown.Selected, Dropdown.Options[Dropdown.Selected]) end
				end,
				Get = function() return Dropdown.Selected, Dropdown.Options[Dropdown.Selected] end,
				Hide = function() Dropdown.Visible = false; Window:RefreshContent() end,
				Show = function() Dropdown.Visible = true; Window:RefreshContent() end
			}
		end

		function Tab:AddMultiDropdown(text, options, defaultValues, callback)
			if type(options) ~= "table" then options = {} end
			local set = {}
			if type(defaultValues) == "table" then
				for _, v in ipairs(defaultValues) do
					local idx = toIndexFromValue(v, options, nil)
					if idx and not set[idx] then set[idx] = true end
				end
			end
			local Multi = {
				Type = "MultiDropdown",
				Text = text,
				Options = options,
				Selected = set,
				Callback = callback,
				Visible = true,
				_Expanded = false
			}
			table.insert(Tab.Elements, Multi)
			Window:RefreshContent()
			return {
				GetValues = function()
					local res = {}
					for idx,_ in pairs(Multi.Selected) do
						table.insert(res, Multi.Options[idx])
					end
					return res
				end,
				SetValuesByIndices = function(self, indices)
					local newSet = {}
					for _, i in ipairs(indices or {}) do
						local num = toNumberOrDefault(i, nil)
						if num then newSet[math.clamp(math.floor(num),1,#options)] = true end
					end
					Multi.Selected = newSet
					Window:RefreshContent()
					if Multi.Callback then pcall(Multi.Callback, Multi:GetValues()) end
				end,
				Hide = function() Multi.Visible = false; Window:RefreshContent() end,
				Show = function() Multi.Visible = true; Window:RefreshContent() end
			}
		end

		function Tab:AddKeybind(text, defaultKey, mode, callback)
			if type(mode) == "function" and callback == nil then
				callback = mode
				mode = nil
			end
			local parsedKey = nil
			if typeof(defaultKey) == "EnumItem" then
				parsedKey = defaultKey
			elseif type(defaultKey) == "string" then
				local k = Enum.KeyCode[defaultKey]
				if k then parsedKey = k
				else
					local upper = tostring(defaultKey):upper()
					local k2 = Enum.KeyCode[upper]
					if k2 then parsedKey = k2 end
				end
			elseif type(defaultKey) == "number" then
				-- no reliable numeric mapping; fallback below
			end
			if not parsedKey then parsedKey = Enum.KeyCode.F end

			mode = (mode == "Hold" and "Hold") or "Toggle"

			local Keybind = {
				Type = "Keybind",
				Text = text,
				BindKey = parsedKey,
				Mode = mode,
				Value = false,
				Callback = callback,
				Visible = true,
				_Listening = false
			}
			table.insert(Tab.Elements, Keybind)
			table.insert(Window._Keybinds, { element = Keybind, tab = Tab })

			Window:RefreshContent()
			return {
				Set = function(self, keyEnum)
					if typeof(keyEnum) == "EnumItem" then Keybind.BindKey = keyEnum; Window:RefreshContent() end
				end,
				SetMode = function(self, m) Keybind.Mode = (m == "Hold" and "Hold") or "Toggle"; Window:RefreshContent() end,
				Get = function() return Keybind.BindKey, Keybind.Mode, Keybind.Value end,
				Hide = function() Keybind.Visible = false; Window:RefreshContent() end,
				Show = function() Keybind.Visible = true; Window:RefreshContent() end
			}
		end

		-- Colorpicker: defaultColor Color3, callback(Color3)
		function Tab:AddColorpicker(text, defaultColor, callback)
			local col = defaultColor
			if type(col) ~= "userdata" then col = Color3.fromRGB(255,255,255) end
			local h,s,v = RGBToHSV(col)
			local Picker = {
				Type = "Colorpicker",
				Text = text,
				Color = col,
				HSV = {h=h, s=s, v=v},
				Callback = callback,
				Visible = true,
				_UI = {}
			}
			table.insert(Tab.Elements, Picker)
			Window:RefreshContent()
			return {
				Set = function(self, c)
					if type(c) == "userdata" then
						Picker.Color = c
						local hh,ss,vv = RGBToHSV(c)
						Picker.HSV.h = hh; Picker.HSV.s = ss; Picker.HSV.v = vv
						Window:RefreshContent()
						if Picker.Callback then pcall(Picker.Callback, c) end
					end
				end,
				Get = function() return Picker.Color end,
				Hide = function() Picker.Visible = false; Window:RefreshContent() end,
				Show = function() Picker.Visible = true; Window:RefreshContent() end
			}
		end

		return Tab
	end

	function Window:RefreshContent()
		for _, child in pairs(ContentContainer:GetChildren()) do
			if child:IsA("Frame") then child:Destroy() end
		end
		if not Window.CurrentTab then return end

		for _, element in pairs(Window.CurrentTab.Elements) do
			if not element.Visible then continue end

			if element.Type == "Paragraph" then
				local minHeight = isMobile and 70 or 100
				local P = New("Frame", {
					Parent = ContentContainer,
					BackgroundColor3 = themeGet(theme, "Panel"),
					BorderSizePixel = 0,
					Size = UDim2.new(1,0,0,minHeight)
				})
				New("UICorner", {Parent = P, CornerRadius = UDim.new(0.05,0)})
				New("UIStroke", {Parent = P, Color = themeGet(theme, "PanelStroke"), Thickness = 1})

				local padding = isMobile and 8 or 12
				New("UIPadding", {Parent = P, PaddingLeft = UDim.new(0,padding), PaddingRight = UDim.new(0,padding), PaddingTop = UDim.new(0,padding), PaddingBottom = UDim.new(0,padding)})

				New("TextLabel", {
					Parent = P,
					BackgroundTransparency = 1,
					Size = UDim2.new(1,0,0,ElementFontSize + 4),
					Font = Enum.Font.GothamMedium,
					Text = element.Title or "",
					TextColor3 = Color3.fromRGB(255,255,255),
					TextSize = ElementFontSize,
					TextXAlignment = Enum.TextXAlignment.Left
				})

				New("TextLabel", {
					Parent = P,
					BackgroundTransparency = 1,
					Position = UDim2.new(0,0,0,ElementFontSize + 6),
					Size = UDim2.new(1,0,1,-(ElementFontSize + 6)),
					Font = Enum.Font.Gotham,
					Text = element.Content or "",
					TextColor3 = Color3.fromRGB(150,150,150),
					TextSize = SmallFontSize,
					TextWrapped = true,
					TextYAlignment = Enum.TextYAlignment.Top
				})

				task.spawn(function()
					task.wait()
					local titleSize = TextService:GetTextSize(element.Title or "", ElementFontSize, Enum.Font.GothamMedium, Vector2.new(P.AbsoluteSize.X - padding*2, math.huge))
					local contentSize = TextService:GetTextSize(element.Content or "", SmallFontSize, Enum.Font.Gotham, Vector2.new(P.AbsoluteSize.X - padding*2, math.huge))
					P.Size = UDim2.new(1,0,0, titleSize.Y + contentSize.Y + padding*2 + 6)
				end)

			elseif element.Type == "Button" then
				local btnHeight = isMobile and 36 or 42
				local F = New("Frame", {Parent = ContentContainer, BackgroundColor3 = themeGet(theme, "Panel"), BorderSizePixel = 0, Size = UDim2.new(1,0,0,btnHeight)})
				New("UICorner", {Parent = F, CornerRadius = UDim.new(0.1,0)})
				New("UIStroke", {Parent = F, Color = themeGet(theme, "PanelStroke"), Thickness = 1})
				New("TextLabel", {Parent = F, BackgroundTransparency = 1, Position = UDim2.new(0.03,0,0,0), Size = UDim2.new(0.94,0,1,0), Font = Enum.Font.GothamMedium, Text = element.Text or "", TextColor3 = Color3.fromRGB(255,255,255), TextSize = ElementFontSize, TextXAlignment = Enum.TextXAlignment.Left})
				local Click = New("TextButton", {Parent = F, BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Text = "", AutoButtonColor = false})
				Click.MouseButton1Click:Connect(function()
					TweenService:Create(F, TweenInfo.new(0.09), {BackgroundColor3 = Color3.fromRGB(30,30,30)}):Play()
					task.wait(0.09)
					TweenService:Create(F, TweenInfo.new(0.09), {BackgroundColor3 = themeGet(theme, "Panel")}):Play()
					if element.Callback then pcall(element.Callback) end
				end)

			elseif element.Type == "Toggle" then
				local toggleHeight = isMobile and 36 or 42
				local toggleSize = isMobile and 20 or 24
				local indicatorSize = isMobile and 14 or 16

				local F = New("Frame", {Parent = ContentContainer, BackgroundColor3 = themeGet(theme, "Panel"), BorderSizePixel = 0, Size = UDim2.new(1,0,0,toggleHeight)})
				New("UICorner", {Parent = F, CornerRadius = UDim.new(0.1,0)})
				New("UIStroke", {Parent = F, Color = themeGet(theme, "PanelStroke"), Thickness = 1})
				New("TextLabel", {Parent = F, BackgroundTransparency = 1, Position = UDim2.new(0.03,0,0,0), Size = UDim2.new(0.75,0,1,0), Font = Enum.Font.GothamMedium, Text = element.Text or "", TextColor3 = Color3.fromRGB(255,255,255), TextSize = ElementFontSize, TextXAlignment = Enum.TextXAlignment.Left})

				local IndicatorBg = New("Frame", { Parent = F, AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(0.975,0,0.5,0), Size = UDim2.new(0,toggleSize,0,toggleSize), BackgroundColor3 = themeGet(theme, "ToggleBg"), BorderSizePixel = 0 })
				New("UICorner", {Parent = IndicatorBg, CornerRadius = UDim.new(0.5,0)})
				New("UIStroke", {Parent = IndicatorBg, Color = themeGet(theme, "PanelStroke"), Thickness = 1})

				local Indicator = New("Frame", { Parent = IndicatorBg, AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.new(0.5,0,0.5,0), Size = UDim2.new(0,indicatorSize,0,indicatorSize), BackgroundColor3 = element.Value and themeGet(theme, "ToggleOn") or themeGet(theme, "ToggleOff"), BorderSizePixel = 0 })
				New("UICorner", {Parent = Indicator, CornerRadius = UDim.new(0.5,0)})
				New("UIStroke", {Parent = Indicator, Color = themeGet(theme, "PanelStroke"), Thickness = 1})

				local Click = New("TextButton", {Parent = F, BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Text = "", AutoButtonColor = false})
				Click.MouseButton1Click:Connect(function()
					element.Value = not element.Value
					TweenService:Create(Indicator, TweenInfo.new(0.18), { BackgroundColor3 = element.Value and themeGet(theme, "ToggleOn") or themeGet(theme, "ToggleOff") }):Play()
					if element.Callback then pcall(element.Callback, element.Value) end
				end)

			elseif element.Type == "Slider" then
				local sliderHeight = isMobile and 48 or 56
				local F = New("Frame", {Parent = ContentContainer, BackgroundColor3 = themeGet(theme, "Panel"), BorderSizePixel = 0, Size = UDim2.new(1,0,0,sliderHeight)})
				New("UICorner", {Parent = F, CornerRadius = UDim.new(0.06,0)})
				New("UIStroke", {Parent = F, Color = themeGet(theme, "PanelStroke"), Thickness = 1})

				local padding = isMobile and 8 or 12
				New("UIPadding", {Parent = F, PaddingLeft = UDim.new(0,padding), PaddingRight = UDim.new(0,padding), PaddingTop = UDim.new(0,padding-2), PaddingBottom = UDim.new(0,padding-2)})

				local Label = New("TextLabel", {Parent = F, BackgroundTransparency = 1, Position = UDim2.new(0,0,0,0), Size = UDim2.new(0.55,0,0.45,0), Font = Enum.Font.GothamMedium, Text = element.Text or "Slider", TextColor3 = Color3.fromRGB(255,255,255), TextSize = ElementFontSize, TextXAlignment = Enum.TextXAlignment.Left})
				local ValueLabel = New("TextLabel", {Parent = F, BackgroundTransparency = 1, Position = UDim2.new(0.55,0,0,0), Size = UDim2.new(0.45,0,0.45,0), Font = Enum.Font.Gotham, Text = tostring(math.floor(element.Value*100)/100), TextColor3 = Color3.fromRGB(150,150,150), TextSize = SmallFontSize, TextXAlignment = Enum.TextXAlignment.Right})

				local trackHeight = isMobile and 14 or 18
				local TrackContainer = New("Frame", {Parent = F, BackgroundTransparency = 1, Size = UDim2.new(1,0,0,trackHeight), Position = UDim2.new(0,0,1,-trackHeight)})
				local Track = New("Frame", {Parent = TrackContainer, BackgroundColor3 = Color3.fromRGB(35,35,35), Size = UDim2.new(1,0,1,0), BorderSizePixel = 0})
				New("UICorner", {Parent = Track, CornerRadius = UDim.new(0.5,0)})
				New("UIStroke", {Parent = Track, Color = themeGet(theme, "PanelStroke"), Thickness = 1})

				local Fill = New("Frame", {Parent = Track, BackgroundColor3 = themeGet(theme, "Fill"), Size = UDim2.new(0,0,1,0), BorderSizePixel = 0})
				New("UICorner", {Parent = Fill, CornerRadius = UDim.new(0.5,0)})

				local knobSize = isMobile and 14 or 18
				local Knob = New("Frame", {Parent = Track, BackgroundColor3 = themeGet(theme, "ToggleOn"), Size = UDim2.new(0,knobSize,0,knobSize), AnchorPoint = Vector2.new(0,0.5), Position = UDim2.new(0,0,0.5,0), BorderSizePixel = 0})
				New("UICorner", {Parent = Knob, CornerRadius = UDim.new(0.5,0)})
				New("UIStroke", {Parent = Knob, Color = themeGet(theme, "PanelStroke"), Thickness = 1})

				local function updateVisuals(val)
					local pct = 0
					if element.Max ~= element.Min then pct = (val - element.Min) / (element.Max - element.Min) end
					pct = math.clamp(pct, 0, 1)
					Fill.Size = UDim2.new(pct,0,1,0)
					Knob.Position = UDim2.new(math.clamp(pct,0,1), -knobSize/2, 0.5, 0)
					ValueLabel.Text = tostring(math.floor(val * 100) / 100)
				end
				updateVisuals(element.Value)

				local function getNumericX(pos)
					if not pos then return nil end
					local ok, t = pcall(function() return typeof(pos) end)
					if ok and t then
						if t == "Vector2" or t == "Vector3" then return pos.X end
						if t == "UDim2" then
							if pos.X and pos.X.Offset then return pos.X.Offset end
							return pos.X and pos.X.Scale or nil
						end
					end
					if type(pos) == "table" and pos.X then return pos.X end
					if type(pos) == "number" then return pos end
					local ok2, ppos = pcall(function() return pos.Position end)
					if ok2 and ppos then
						local ok3, t2 = pcall(function() return typeof(ppos) end)
						if ok3 and (t2 == "Vector2" or t2 == "Vector3") then return ppos.X end
						if type(ppos) == "table" and ppos.X then return ppos.X end
					end
					return nil
				end

				local function setValueFromPos(pos)
					local x = getNumericX(pos)
					if not x then return end
					local absX = x - Track.AbsolutePosition.X
					local width = Track.AbsoluteSize.X
					local pct = math.clamp(absX / math.max(width,1), 0, 1)
					local newVal = element.Min + (element.Max - element.Min) * pct
					element.Value = newVal
					updateVisuals(element.Value)
					if element.Callback then pcall(element.Callback, element.Value) end
				end

				do
					local draggingSlider = false
					local function beginDragFromInput(inp)
						draggingSlider = true
						local pos = nil
						local ok, p = pcall(function() return inp.Position end)
						if ok and p then pos = p else pos = inp end
						setValueFromPos(pos)
					end

					Track.InputBegan:Connect(function(inp)
						local t = inp.UserInputType
						if t == Enum.UserInputType.MouseButton1 or t == Enum.UserInputType.Touch then
							beginDragFromInput(inp)
						end
					end)

					Track.InputEnded:Connect(function(inp)
						local t = inp.UserInputType
						if t == Enum.UserInputType.MouseButton1 or t == Enum.UserInputType.Touch then
							draggingSlider = false
						end
					end)

					Knob.InputBegan:Connect(function(inp)
						local t = inp.UserInputType
						if t == Enum.UserInputType.MouseButton1 or t == Enum.UserInputType.Touch then
							beginDragFromInput(inp)
						end
					end)

					Knob.InputEnded:Connect(function(inp)
						local t = inp.UserInputType
						if t == Enum.UserInputType.MouseButton1 or t == Enum.UserInputType.Touch then
							draggingSlider = false
						end
					end)

					UserInputService.InputChanged:Connect(function(input)
						if not draggingSlider then return end
						local t = input.UserInputType
						if (t == Enum.UserInputType.MouseMovement or t == Enum.UserInputType.Touch) and input.Position then
							setValueFromPos(input.Position)
						end
					end)
				end

			elseif element.Type == "Dropdown" then
				-- Single dropdown with pill-style selected display and highlighted selected option when expanded
				local baseHeight = isMobile and 44 or 48
				local optionHeight = isMobile and 30 or 34
				local visibleOptions = math.clamp(#element.Options, 0, 8)
				local collapsedHeight = baseHeight
				local expandedHeight = baseHeight + (visibleOptions * optionHeight)

				local F = New("Frame", {Parent = ContentContainer, BackgroundColor3 = themeGet(theme, "Panel"), BorderSizePixel = 0, Size = UDim2.new(1,0,0, element._Expanded and expandedHeight or collapsedHeight)})
				New("UICorner", {Parent = F, CornerRadius = UDim.new(0.06,0)})
				New("UIStroke", {Parent = F, Color = themeGet(theme, "PanelStroke"), Thickness = 1})

				-- Top: label + selected pill container
				local Label = New("TextLabel", {Parent = F, BackgroundTransparency = 1, Position = UDim2.new(0.03,0,0,6), Size = UDim2.new(0.4,0,0,ElementFontSize + 6), Font = Enum.Font.GothamMedium, Text = element.Text or "Dropdown", TextColor3 = Color3.fromRGB(255,255,255), TextSize = ElementFontSize, TextXAlignment = Enum.TextXAlignment.Left})
				local PillContainer = New("Frame", { Parent = F, BackgroundTransparency = 1, Position = UDim2.new(0.03,0,0,ElementFontSize + 12), Size = UDim2.new(0.94,0,0, baseHeight - (ElementFontSize + 18))})
				-- inside PillContainer we place a UIListLayout horizontal and display the selected option as a pill
				local pillLayout = New("UIListLayout", { Parent = PillContainer, FillDirection = Enum.FillDirection.Horizontal, HorizontalAlignment = Enum.HorizontalAlignment.Left, SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0,6) })
				pillLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function() end)

				local function renderSelectedPill()
					-- clear old
					for _,c in pairs(PillContainer:GetChildren()) do
						if c:IsA("Frame") and c.Name == "SelectedPill" then c:Destroy() end
					end
					local selText = tostring(element.Options[element.Selected] or "")
					local pill = New("Frame", { Parent = PillContainer, Name = "SelectedPill", BackgroundColor3 = lightenColor(themeGet(theme,"Tab"), 0.08), Size = UDim2.new(0, math.clamp(TextService:GetTextSize(selText, SmallFontSize, Enum.Font.Gotham, Vector2.new(800, math.huge)).X + 18, 60, PillContainer.AbsoluteSize.X), 0, PillContainer.AbsoluteSize.Y), BorderSizePixel = 0 })
					New("UICorner", { Parent = pill, CornerRadius = UDim.new(0.5, 0) })
					New("UIStroke", { Parent = pill, Color = themeGet(theme, "PanelStroke"), Thickness = 1 })
					New("TextLabel", { Parent = pill, BackgroundTransparency = 1, Size = UDim2.new(1, -8, 1, 0), Position = UDim2.new(0,8,0,0), Font = Enum.Font.Gotham, Text = selText, TextXAlignment = Enum.TextXAlignment.Left, TextSize = SmallFontSize, TextColor3 = Color3.fromRGB(230,230,230) })
				end
				-- render initial
				renderSelectedPill()

				local Arrow = New("TextButton", { Parent = F, BackgroundTransparency = 1, Size = UDim2.new(0,28,0,28), Position = UDim2.new(1,-34,0,6), Text = element._Expanded and "▴" or "▾", Font = Enum.Font.SourceSansBold, TextColor3 = themeGet(theme, "ControlBtnText"), TextSize = isMobile and 14 or 16, AutoButtonColor = false })

				local OptionsFrame = nil

				local function collapse()
					element._Expanded = false
					Arrow.Text = "▾"
					F.Size = UDim2.new(1,0,0,collapsedHeight)
					if OptionsFrame then OptionsFrame:Destroy(); OptionsFrame = nil end
				end

				local function expand()
					element._Expanded = true
					Arrow.Text = "▴"
					OptionsFrame = New("Frame", { Parent = F, BackgroundTransparency = 1, Position = UDim2.new(0,0,0, baseHeight), Size = UDim2.new(1,0,0, visibleOptions * optionHeight) })
					local optsLayout = New("UIListLayout", { Parent = OptionsFrame, SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0,2) })
					for i, opt in ipairs(element.Options) do
						local isSelected = (i == element.Selected)
						local bgColor = isSelected and lightenColor(themeGet(theme,"Tab"), 0.18) or themeGet(theme,"Tab")
						local textColor = isSelected and Color3.fromRGB(20,20,20) or Color3.fromRGB(200,200,200)
						local btn = New("TextButton", { Parent = OptionsFrame, BackgroundColor3 = bgColor, Size = UDim2.new(1,0,0,optionHeight), Text = "", AutoButtonColor = false })
						New("UICorner", { Parent = btn, CornerRadius = UDim.new(0.06,0) })
						New("UIStroke", { Parent = btn, Color = themeGet(theme, "PanelStroke"), Thickness = 1 })
						local lbl = New("TextLabel", { Parent = btn, BackgroundTransparency = 1, Size = UDim2.new(1,-14,1,0), Position = UDim2.new(0,8,0,0), Font = Enum.Font.Gotham, Text = opt, TextSize = SmallFontSize, TextColor3 = textColor, TextXAlignment = Enum.TextXAlignment.Left })
						if isSelected then
							-- add small check or highlight marker
							local check = New("TextLabel", { Parent = btn, BackgroundTransparency = 1, Size = UDim2.new(0,24,0,optionHeight), Position = UDim2.new(1,-28,0,0), Font = Enum.Font.SourceSansBold, Text = "✓", TextSize = SmallFontSize + 4, TextColor3 = Color3.fromRGB(20,20,20) })
						end
						btn.MouseButton1Click:Connect(function()
							element.Selected = i
							if element.Callback then pcall(element.Callback, element.Selected, element.Options[element.Selected]) end
							renderSelectedPill()
							collapse()
						end)
					end
					F.Size = UDim2.new(1,0,0, expandedHeight)
				end

				Arrow.MouseButton1Click:Connect(function()
					if element._Expanded then collapse() else expand() end
				end)

				-- when PillContainer absolute size changes (resize), re-render pill to fit width
				PillContainer:GetPropertyChangedSignal("AbsoluteSize"):Connect(function() renderSelectedPill() end)

			elseif element.Type == "MultiDropdown" then
				-- MultiDropdown with horizontal pill area; expanded options highlight selected ones
				local baseHeight = isMobile and 44 or 48
				local optionHeight = isMobile and 30 or 34
				local visibleOptions = math.clamp(#element.Options, 0, 8)
				local collapsedHeight = baseHeight
				local expandedHeight = baseHeight + (visibleOptions * optionHeight)

				local F = New("Frame", {Parent = ContentContainer, BackgroundColor3 = themeGet(theme, "Panel"), BorderSizePixel = 0, Size = UDim2.new(1,0,0, element._Expanded and expandedHeight or collapsedHeight)})
				New("UICorner", {Parent = F, CornerRadius = UDim.new(0.06,0)})
				New("UIStroke", {Parent = F, Color = themeGet(theme, "PanelStroke"), Thickness = 1})

				local Label = New("TextLabel", {Parent = F, BackgroundTransparency = 1, Position = UDim2.new(0.03,0,0,6), Size = UDim2.new(0.35,0,0,ElementFontSize + 6), Font = Enum.Font.GothamMedium, Text = element.Text or "MultiDropdown", TextColor3 = Color3.fromRGB(255,255,255), TextSize = ElementFontSize, TextXAlignment = Enum.TextXAlignment.Left})
				local PillContainer = New("Frame", { Parent = F, BackgroundTransparency = 1, Position = UDim2.new(0.03,0,0,ElementFontSize + 12), Size = UDim2.new(0.94,0,0, baseHeight - (ElementFontSize + 18))})
				local pillLayout = New("UIListLayout", { Parent = PillContainer, FillDirection = Enum.FillDirection.Horizontal, HorizontalAlignment = Enum.HorizontalAlignment.Left, SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0,6) })

				local function renderMultiPills()
					for _,c in pairs(PillContainer:GetChildren()) do
						if c:IsA("Frame") and c.Name == "MultiPill" then c:Destroy() end
					end
					for idx,_ in pairs(element.Selected) do
						local text = tostring(element.Options[idx] or "")
						local pill = New("Frame", { Parent = PillContainer, Name = "MultiPill", BackgroundColor3 = lightenColor(themeGet(theme,"Tab"), 0.08), Size = UDim2.new(0, math.clamp(TextService:GetTextSize(text, SmallFontSize, Enum.Font.Gotham, Vector2.new(800, math.huge)).X + 22, 60, PillContainer.AbsoluteSize.X), 0, PillContainer.AbsoluteSize.Y), BorderSizePixel = 0 })
						New("UICorner", { Parent = pill, CornerRadius = UDim.new(0.5, 0) })
						New("UIStroke", { Parent = pill, Color = themeGet(theme, "PanelStroke"), Thickness = 1 })
						local lbl = New("TextLabel", { Parent = pill, BackgroundTransparency = 1, Size = UDim2.new(1, -8, 1, 0), Position = UDim2.new(0,8,0,0), Font = Enum.Font.Gotham, Text = text, TextXAlignment = Enum.TextXAlignment.Left, TextSize = SmallFontSize, TextColor3 = Color3.fromRGB(230,230,230) })
					end
				end
				renderMultiPills()

				local Arrow = New("TextButton", { Parent = F, BackgroundTransparency = 1, Size = UDim2.new(0,28,0,28), Position = UDim2.new(1,-34,0,6), Text = element._Expanded and "▴" or "▾", Font = Enum.Font.SourceSansBold, TextColor3 = themeGet(theme, "ControlBtnText"), TextSize = isMobile and 14 or 16, AutoButtonColor = false })

				local OptionsFrame = nil

				local function collapse()
					element._Expanded = false
					Arrow.Text = "▾"
					F.Size = UDim2.new(1,0,0,collapsedHeight)
					if OptionsFrame then OptionsFrame:Destroy(); OptionsFrame = nil end
				end

				local function expand()
					element._Expanded = true
					Arrow.Text = "▴"
					OptionsFrame = New("Frame", { Parent = F, BackgroundTransparency = 1, Position = UDim2.new(0,0,0, baseHeight), Size = UDim2.new(1,0,0, visibleOptions * optionHeight) })
					local optsLayout = New("UIListLayout", { Parent = OptionsFrame, SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0,2) })
					for i, opt in ipairs(element.Options) do
						local isSelected = element.Selected[i]
						local bgColor = isSelected and lightenColor(themeGet(theme,"Tab"), 0.18) or themeGet(theme,"Tab")
						local textColor = isSelected and Color3.fromRGB(20,20,20) or Color3.fromRGB(200,200,200)
						local btn = New("TextButton", { Parent = OptionsFrame, BackgroundColor3 = bgColor, Size = UDim2.new(1,0,0,optionHeight), Text = "", AutoButtonColor = false })
						New("UICorner", { Parent = btn, CornerRadius = UDim.new(0.06,0) })
						New("UIStroke", { Parent = btn, Color = themeGet(theme, "PanelStroke"), Thickness = 1 })
						local lbl = New("TextLabel", { Parent = btn, BackgroundTransparency = 1, Size = UDim2.new(1,-14,1,0), Position = UDim2.new(0,8,0,0), Font = Enum.Font.Gotham, Text = opt, TextSize = SmallFontSize, TextColor3 = textColor, TextXAlignment = Enum.TextXAlignment.Left })
						local mark = New("TextLabel", { Parent = btn, BackgroundTransparency = 1, Size = UDim2.new(0,24,0,optionHeight), Position = UDim2.new(1,-28,0,0), Font = Enum.Font.SourceSansBold, Text = isSelected and "✓" or "", TextSize = SmallFontSize + 4, TextColor3 = Color3.fromRGB(20,20,20) })
						btn.MouseButton1Click:Connect(function()
							if element.Selected[i] then
								element.Selected[i] = nil
							else
								element.Selected[i] = true
							end
							renderMultiPills()
							if element.Callback then
								local vals = {}
								for idx,_ in pairs(element.Selected) do table.insert(vals, element.Options[idx]) end
								pcall(element.Callback, vals)
							end
						end)
					end
					F.Size = UDim2.new(1,0,0, expandedHeight)
				end

				Arrow.MouseButton1Click:Connect(function()
					if element._Expanded then collapse() else expand() end
				end)

				PillContainer:GetPropertyChangedSignal("AbsoluteSize"):Connect(function() renderMultiPills() end)

			elseif element.Type == "Keybind" then
				local bindHeight = isMobile and 40 or 46
				local F = New("Frame", {Parent = ContentContainer, BackgroundColor3 = themeGet(theme, "Panel"), BorderSizePixel = 0, Size = UDim2.new(1,0,0,bindHeight)})
				New("UICorner", {Parent = F, CornerRadius = UDim.new(0.08,0)})
				New("UIStroke", {Parent = F, Color = themeGet(theme, "PanelStroke"), Thickness = 1})

				local Label = New("TextLabel", {Parent = F, BackgroundTransparency = 1, Position = UDim2.new(0.03,0,0,0), Size = UDim2.new(0.55,0,0,ElementFontSize + 6), Font = Enum.Font.GothamMedium, Text = element.Text or "Keybind", TextColor3 = Color3.fromRGB(255,255,255), TextSize = ElementFontSize, TextXAlignment = Enum.TextXAlignment.Left})
				local ModeLabel = New("TextLabel", {Parent = F, BackgroundTransparency = 1, Position = UDim2.new(0.03,0,0,ElementFontSize + 8), Size = UDim2.new(0.55,0,0,SmallFontSize + 4), Font = Enum.Font.Gotham, Text = "("..element.Mode..")", TextColor3 = Color3.fromRGB(150,150,150), TextSize = SmallFontSize, TextXAlignment = Enum.TextXAlignment.Left})
				local BindBtn = New("TextButton", {
					Parent = F,
					Size = UDim2.new(0, 120, 0, bindHeight - 6),
					Position = UDim2.new(1, -126, 0, 3),
					BackgroundColor3 = Background.BackgroundColor3,
					AutoButtonColor = false,
					Font = Enum.Font.Gotham,
					Text = tostring(element.BindKey.Name or tostring(element.BindKey)),
					TextSize = isMobile and 12 or 14,
					TextColor3 = themeGet(theme, "ControlBtnText")
				})
				New("UICorner", {Parent = BindBtn, CornerRadius = UDim.new(0.06,0)})
				New("UIStroke", {Parent = BindBtn, Color = themeGet(theme, "PanelStroke"), Thickness = 1})

				local ListenIndicator = New("TextLabel", { Parent = BindBtn, BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Position = UDim2.new(0,0,0,0), Text = "", Font = Enum.Font.Gotham, TextSize = isMobile and 12 or 14, TextColor3 = Color3.fromRGB(200,200,200) })

				local listeningConn = nil
				local function startListening()
					element._Listening = true
					BindBtn.Text = "Press Key..."
					ListenIndicator.Text = ""
					listeningConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
						if gameProcessed then return end
						if input.UserInputType == Enum.UserInputType.Keyboard then
							element.BindKey = input.KeyCode
							element._Listening = false
							if listeningConn then listeningConn:Disconnect(); listeningConn = nil end
							BindBtn.Text = tostring(element.BindKey.Name or tostring(element.BindKey))
							Window:RefreshContent()
						end
					end)
				end

				local function stopListening()
					element._Listening = false
					if listeningConn then listeningConn:Disconnect(); listeningConn = nil end
					BindBtn.Text = tostring(element.BindKey.Name or tostring(element.BindKey))
				end

				BindBtn.MouseButton1Click:Connect(function()
					if element._Listening then
						stopListening()
					else
						startListening()
					end
				end)

			elseif element.Type == "Colorpicker" then
				-- full small Google-like color picker: SV box + hue slider + hex input + preview
				local h = isMobile and 140 or 160
				local F = New("Frame", {Parent = ContentContainer, BackgroundColor3 = themeGet(theme, "Panel"), BorderSizePixel = 0, Size = UDim2.new(1,0,0,h + 12)})
				New("UICorner", {Parent = F, CornerRadius = UDim.new(0.06,0)})
				New("UIStroke", {Parent = F, Color = themeGet(theme, "PanelStroke"), Thickness = 1})

				local padding = 8
				New("UIPadding", {Parent = F, PaddingLeft = UDim.new(0,padding), PaddingTop = UDim.new(0,padding)})

				-- title
				New("TextLabel", {Parent = F, BackgroundTransparency = 1, Position = UDim2.new(0,0,0,0), Size = UDim2.new(1, - (h + 20), 0, ElementFontSize + 6), Font = Enum.Font.GothamMedium, Text = element.Text or "Color", TextColor3 = Color3.fromRGB(255,255,255), TextSize = ElementFontSize, TextXAlignment = Enum.TextXAlignment.Left})

				-- SV box (square)
				local svSize = h
				local SV = New("Frame", { Parent = F, BackgroundColor3 = Color3.new(1,1,1), Size = UDim2.new(0, svSize, 0, svSize), Position = UDim2.new(0,0,0, ElementFontSize + 8) })
				New("UICorner", { Parent = SV, CornerRadius = UDim.new(0.02, 0) })
				-- overlays for hue and saturation/value
				local SVColor = New("Frame", { Parent = SV, BackgroundColor3 = HSVToRGB(element.HSV.h, 1, 1), Size = UDim2.new(1,1,1,1), BorderSizePixel = 0 })
				New("UICorner", { Parent = SVColor, CornerRadius = UDim.new(0.02, 0) })
				local SVOverlay = New("ImageLabel", { Parent = SV, BackgroundTransparency = 1, Image = "rbxassetid://4155801250", ImageColor3 = Color3.new(1,1,1), Size = UDim2.new(1,1,1,1), ScaleType = Enum.ScaleType.Stretch })
				-- SVOverlay uses a white->transparent gradient image; using built-in image id common trick (if unavailable, it's harmless)
				-- Crosshair indicator
				local Cross = New("Frame", { Parent = SV, Size = UDim2.new(0, 12, 0, 12), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundColor3 = Color3.new(0,0,0) })
				New("UICorner", { Parent = Cross, CornerRadius = UDim.new(1, 0) })
				local CrossInner = New("Frame", { Parent = Cross, Size = UDim2.new(1,1,1,1), BackgroundColor3 = Color3.new(1,1,1) })
				New("UICorner", { Parent = CrossInner, CornerRadius = UDim.new(1, 0) })

				-- Hue slider
				local hueW = 28
				local Hue = New("Frame", { Parent = F, Size = UDim2.new(0, hueW, 0, svSize), Position = UDim2.new(0, svSize + 12, 0, ElementFontSize + 8), BackgroundColor3 = Color3.new(1,0,0) })
				New("UICorner", { Parent = Hue, CornerRadius = UDim.new(0.02, 0) })
				-- gradient stripe: we'll approximate by cycling background using Image (if available)
				local hueImg = New("ImageLabel", { Parent = Hue, BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Image = "rbxassetid://4318288741", ImageColor3 = Color3.new(1,1,1), ScaleType = Enum.ScaleType.Stretch })

				-- Hue indicator
				local HueIndicator = New("Frame", { Parent = Hue, Size = UDim2.new(1,0,0,6), AnchorPoint = Vector2.new(0,0.5), Position = UDim2.new(0,0, element.HSV.h / 360, 0), BackgroundColor3 = Color3.new(1,1,1) })
				New("UICorner", { Parent = HueIndicator, CornerRadius = UDim.new(0.02, 0) })

				-- Right side: preview + hex input
				local rightX = svSize + 12 + hueW + 12
				local Preview = New("Frame", { Parent = F, Size = UDim2.new(0, 60, 0, 60), Position = UDim2.new(0, rightX, 0, ElementFontSize + 8), BackgroundColor3 = element.Color })
				New("UICorner", { Parent = Preview, CornerRadius = UDim.new(0.04, 0) })
				New("UIStroke", { Parent = Preview, Color = themeGet(theme, "PanelStroke"), Thickness = 1 })

				local HexBox = New("TextBox", { Parent = F, Size = UDim2.new(0, 120, 0, 28), Position = UDim2.new(0, rightX, 0, ElementFontSize + 8 + 68), BackgroundColor3 = themeGet(theme, "Tab"), Text = string.format("#%02X%02X%02X", math.floor(element.Color.r*255), math.floor(element.Color.g*255), math.floor(element.Color.b*255)), ClearTextOnFocus = false, TextColor3 = Color3.fromRGB(240,240,240), Font = Enum.Font.Gotham, TextSize = SmallFontSize, PlaceholderText = "#RRGGBB" })
				New("UICorner", { Parent = HexBox, CornerRadius = UDim.new(0.04, 0) })
				New("UIStroke", { Parent = HexBox, Color = themeGet(theme, "PanelStroke"), Thickness = 1 })

				-- helper: set HSV & update UI elements
				local function updatePickerFromHSV()
					local newC = HSVToRGB(element.HSV.h, element.HSV.s, element.HSV.v)
					element.Color = newC
					SVColor.BackgroundColor3 = HSVToRGB(element.HSV.h, 1, 1)
					Preview.BackgroundColor3 = newC
					HexBox.Text = string.format("#%02X%02X%02X", math.floor(newC.r*255), math.floor(newC.g*255), math.floor(newC.b*255))
					-- position crosshair
					local svPosX = element.HSV.s * SV.AbsoluteSize.X
					local svPosY = (1 - element.HSV.v) * SV.AbsoluteSize.Y
					Cross.Position = UDim2.new(0, svPosX, 0, svPosY)
					-- hue indicator
					local hueY = (element.HSV.h / 360) * Hue.AbsoluteSize.Y
					HueIndicator.Position = UDim2.new(0, 0, 0, math.clamp(hueY, 0, Hue.AbsoluteSize.Y))
					if element.Callback then pcall(element.Callback, element.Color) end
				end

				-- interaction: SV box (saturation/value)
				do
					local draggingSV = false
					local function setSVFromPos(pos)
						local x = pos.X - SV.AbsolutePosition.X
						local y = pos.Y - SV.AbsolutePosition.Y
						local s = math.clamp(x / math.max(1, SV.AbsoluteSize.X), 0, 1)
						local v = math.clamp(1 - (y / math.max(1, SV.AbsoluteSize.Y)), 0, 1)
						element.HSV.s = s
						element.HSV.v = v
						updatePickerFromHSV()
					end
					SV.InputBegan:Connect(function(inp)
						if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
							draggingSV = true
							local ok, p = pcall(function() return inp.Position end)
							if ok and p then setSVFromPos(p) end
						end
					end)
					SV.InputEnded:Connect(function(inp)
						if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
							draggingSV = false
						end
					end)
					UserInputService.InputChanged:Connect(function(inp)
						if not draggingSV then return end
						if (inp.UserInputType == Enum.UserInputType.MouseMovement or inp.UserInputType == Enum.UserInputType.Touch) and inp.Position then
							setSVFromPos(inp.Position)
						end
					end)
				end

				-- hue slider interaction
				do
					local draggingHue = false
					local function setHueFromPos(pos)
						local y = pos.Y - Hue.AbsolutePosition.Y
						local h = math.clamp((y / math.max(1, Hue.AbsoluteSize.Y)) * 360, 0, 360)
						element.HSV.h = h
						updatePickerFromHSV()
					end
					Hue.InputBegan:Connect(function(inp)
						if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
							draggingHue = true
							local ok, p = pcall(function() return inp.Position end)
							if ok and p then setHueFromPos(p) end
						end
					end)
					Hue.InputEnded:Connect(function(inp)
						if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
							draggingHue = false
						end
					end)
					UserInputService.InputChanged:Connect(function(inp)
						if not draggingHue then return end
						if (inp.UserInputType == Enum.UserInputType.MouseMovement or inp.UserInputType == Enum.UserInputType.Touch) and inp.Position then
							setHueFromPos(inp.Position)
						end
					end)
				end

				-- hex input handling
				HexBox.FocusLost:Connect(function(enter)
					local txt = tostring(HexBox.Text or "")
					-- accept #RRGGBB or RRGGBB
					txt = txt:gsub("#","")
					if #txt == 6 then
						local r = tonumber("0x"..txt:sub(1,2))
						local g = tonumber("0x"..txt:sub(3,4))
						local b = tonumber("0x"..txt:sub(5,6))
						if r and g and b then
							local c = Color3.fromRGB(r,g,b)
							element.Color = c
							local hh,ss,vv = RGBToHSV(c)
							element.HSV.h = hh; element.HSV.s = ss; element.HSV.v = vv
							updatePickerFromHSV()
						end
					else
						-- restore current hex
						HexBox.Text = string.format("#%02X%02X%02X", math.floor(element.Color.r*255), math.floor(element.Color.g*255), math.floor(element.Color.b*255))
					end
				end)

				-- initialize visuals
				task.spawn(function() task.wait(0.03); updatePickerFromHSV() end)

				-- on resize, reposition cross/hue
				SV:GetPropertyChangedSignal("AbsoluteSize"):Connect(updatePickerFromHSV)
				Hue:GetPropertyChangedSignal("AbsoluteSize"):Connect(updatePickerFromHSV)
			end
		end
	end

	-- Global Keybind Handling (robust)
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		if input.UserInputType == Enum.UserInputType.Keyboard then
			for _, kb in pairs(Window._Keybinds) do
				local el = kb.element
				if el and el.BindKey and input.KeyCode == el.BindKey then
					if el.Mode == "Toggle" then
						el.Value = not el.Value
						if el.Callback then pcall(el.Callback, el.Value) end
						Window:RefreshContent()
					elseif el.Mode == "Hold" then
						el.Value = true
						if el.Callback then pcall(el.Callback, true) end
						Window:RefreshContent()
					end
				end
			end
		end
	end)

	UserInputService.InputEnded:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		if input.UserInputType == Enum.UserInputType.Keyboard then
			for _, kb in pairs(Window._Keybinds) do
				local el = kb.element
				if el and el.BindKey and input.KeyCode == el.BindKey then
					if el.Mode == "Hold" then
						el.Value = false
						if el.Callback then pcall(el.Callback, false) end
						Window:RefreshContent()
					end
				end
			end
		end
	end)

	function Window:Destroy()
		if Window._ScreenGui then pcall(function() Window._ScreenGui:Destroy() end) end
		if Window._restoreGui then pcall(function() Window._restoreGui:Destroy() end) end
		for i, w in pairs(Library.Windows) do
			if w == Window then table.remove(Library.Windows, i); break end
		end
		if Library.MainWindow == Window then Library.MainWindow = nil end
	end

	table.insert(Library.Windows, Window)
	Library.MainWindow = Window
	return Window
end

return Library
