if getgenv().ForgeScriptLoaded then
        task.spawn(function()
        local Players = game:GetService("Players")
        local PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
        
                local alertGui = Instance.new("ScreenGui")
        alertGui.Name = "ForgeAlreadyRunningAlert"
        alertGui.ResetOnSpawn = false
        alertGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        alertGui.Parent = PlayerGui
        
        local alertFrame = Instance.new("Frame")
        alertFrame.Size = UDim2.new(0, 300, 0, 60)
        alertFrame.Position = UDim2.new(0.5, -150, 0, 20)
        alertFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        alertFrame.BorderSizePixel = 0
        alertFrame.Parent = alertGui
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = alertFrame
        
        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(255, 100, 100)
        stroke.Thickness = 2
        stroke.Parent = alertFrame
        
        local alertText = Instance.new("TextLabel")
        alertText.Size = UDim2.new(1, -20, 1, 0)
        alertText.Position = UDim2.new(0, 10, 0, 0)
        alertText.BackgroundTransparency = 1
        alertText.Text = "⚠️ Script already running!\nCannot execute more than once."
        alertText.TextColor3 = Color3.fromRGB(255, 255, 255)
        alertText.Font = Enum.Font.GothamBold
        alertText.TextSize = 14
        alertText.TextWrapped = true
        alertText.Parent = alertFrame
        
                task.wait(5)
        local TweenService = game:GetService("TweenService")
        local fadeTween = TweenService:Create(alertFrame, TweenInfo.new(0.5), {BackgroundTransparency = 1})
        local textFade = TweenService:Create(alertText, TweenInfo.new(0.5), {TextTransparency = 1})
        local strokeFade = TweenService:Create(stroke, TweenInfo.new(0.5), {Transparency = 1})
        fadeTween:Play()
        textFade:Play()
        strokeFade:Play()
        task.wait(0.5)
        alertGui:Destroy()
    end)
    return end
getgenv().ForgeScriptLoaded = true

-- delete part start

local Debris = workspace:FindFirstChild("Debris")
if Debris then
    local waterDamage = Debris:FindFirstChild("WaterDamage")
    if waterDamage then
        for _, obj in ipairs(waterDamage:GetDescendants()) do
            if obj:IsA("BasePart") then
                pcall(function()
                    obj.CanCollide = false
                    obj.Transparency = 1
                end)
            end
        end
    end
end

-- delete part end

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

task.spawn(function()
    task.wait(1)
    local success, err = pcall(function()
        loadstring(game:HttpGet("https://pastefy.app/SSWN17Dg/raw"))()
    end)
    if not success then
        warn("Failed to load changelog: " .. tostring(err))
    end
end)

getgenv().AutoMelt = false
getgenv().AutoPour = false
getgenv().AutoHammer = false
getgenv().SkipToHammer = false

getgenv().AutoMob = false
getgenv().SelectedMobs = {}
getgenv().AttackDistance = 2
getgenv().FlySpeed = 50
getgenv().MobDepthOffset = 0
getgenv().MobPriority = "Nearest"
getgenv().FilterMobByArea = false
getgenv().SelectedMobAreas = {}

getgenv().NoClipEnabled = false

getgenv().AutoMine = false
getgenv().SelectedRocks = {}
getgenv().MineDistance = 2
getgenv().MineFlySpeed = 50
getgenv().MineDepthOffset = 0
getgenv().MinePriority = "Nearest"
getgenv().MineMode = "Rocks"
getgenv().SelectedOres = {}
getgenv().OreSkipperEnabled = false
getgenv().NoRocksFallback = "Wait (No Potions)"
getgenv().NoDesiredRocksAvailable = false
getgenv().AvoidPlayersWhileMining = false
getgenv().PlayerAvoidDistance = 10
getgenv().DefendWhileMining = false
getgenv().DefendRange = 20
getgenv().FilterMineByArea = false
getgenv().SelectedMineAreas = {}

getgenv().AntiGoblinVillage = false
getgenv().AntiGoblinHeight = 50

getgenv().SpecificPriority = false
getgenv().PriorityOrder = {}

getgenv().AutoDrinkPotions = false
getgenv().SelectedDrinkPotions = {}
getgenv().AutoBuyWhenEmpty = false

getgenv().AutoHealthPotion = false
getgenv().HealthPotionThreshold = 50
getgenv().SelectedHealthPotions = {}
getgenv().AutoBuyHealthPotion = false

getgenv().AutoBoss = false
getgenv().BossAttackDistance = 2
getgenv().BossFlySpeed = 50
getgenv().BossDepthOffset = 0
getgenv().SelectedBosses = {}
getgenv().BossAvoidAttacks = false
getgenv().BossAvoidDistance = 50
getgenv().InstantKillBoss = false

getgenv().AutoQuest = false
getgenv().SelectedQuestIds = {}
getgenv().QuestKillFallback = "Wait"
getgenv().QuestMineFallback = "Wait"
getgenv().QuestEnableMining = false
getgenv().QuestEnableKilling = false

getgenv().AvoidLockedAreas = false

getgenv().MAP_PLACE_IDS = {76558904092080, 129009554587176, 131884594917121}

local function GetCurrentMapNumber()
    local placeId = game.PlaceId
    for i, mapId in ipairs(getgenv().MAP_PLACE_IDS) do
        if placeId == mapId then return i end
    end
    return 0
end

local PotionData = {
    Health = {"HealthPotion2", "HealthPotion1", "HealthPotion12"},
    Buff = {"AttackDamagePotion1", "LuckPotion1", "MinerPotion1", "MovementSpeedPotion1", "PotionLVL2"},
    All = {"AttackDamagePotion1", "HealthPotion1", "HealthPotion2", "HealthPotion12", "LuckPotion1", "MinerPotion1", "MovementSpeedPotion1", "PotionLVL2"},
}

local Threads = {
    autoQuest = nil,
    autoHealth = nil,
    autoDrink = nil,
    autoReroll = nil,
    antiAfkConnection = nil,
}

local GameData = {
    Enemies = nil, OreList = nil, Rock = nil, Rarities = nil,
}

local Helpers = {}

Helpers.SafeRequire = function(path)
    local success, result = pcall(function() return require(path) end)
    return success and result or nil
end


local CustomLockedAreas = {
    {Position = Vector3.new(457.08, 48.32, 113.04), Size = Vector3.new(220.90, 60.40, 121.77)},
    {Position = Vector3.new(583.37, 49.54, -57.36), Size = Vector3.new(342.45, 60.61, 210.89)},
    {Position = Vector3.new(449.91, 9.12, 57.78), Size = Vector3.new(205.74, 29.99, 227.59)},
}

local function IsPointInsideLockedBox(point, box)
    local halfSize = box.Size / 2
    local pos = box.Position
    
    return math.abs(point.X - pos.X) <= halfSize.X and
           math.abs(point.Y - pos.Y) <= halfSize.Y and
           math.abs(point.Z - pos.Z) <= halfSize.Z
end

local function IsPositionInsideLockedRegion(position)
    for _, box in pairs(CustomLockedAreas) do
        if IsPointInsideLockedBox(position, box) then
            return true, box
        end
    end
    return false
end

local function DoesLineIntersectBox(p1, p2, box)
    local halfSize = box.Size / 2
    local pos = box.Position
    
        local localP1 = p1 - pos
    local localP2 = p2 - pos
    
    local dir = localP2 - localP1
    local tMin = 0
    local tMax = 1
    
        for _, axis in pairs({"X", "Y", "Z"}) do
        local p1Axis = localP1[axis]
        local dirAxis = dir[axis]
        local minBound = -halfSize[axis]
        local maxBound = halfSize[axis]
        
        if math.abs(dirAxis) < 0.0001 then
                        if p1Axis < minBound or p1Axis > maxBound then
                return false             end
        else
            local t1 = (minBound - p1Axis) / dirAxis
            local t2 = (maxBound - p1Axis) / dirAxis
            
            if t1 > t2 then
                t1, t2 = t2, t1
            end
            
            tMin = math.max(tMin, t1)
            tMax = math.min(tMax, t2)
            
            if tMin > tMax then
                return false
            end
        end
    end
    
    return true
end

local function DoesPathIntersectLockedRegion(p1, p2)
    for _, box in pairs(CustomLockedAreas) do
        if DoesLineIntersectBox(p1, p2, box) then
            return true, box
        end
    end
    return false, nil
end

local function GetLockedRegionsMaxHeight()
    local maxY = 0
    for _, box in pairs(CustomLockedAreas) do
        local topY = box.Position.Y + (box.Size.Y / 2)
        if topY > maxY then
            maxY = topY
        end
    end
    return maxY
end

local AvoidFlightState = {
    phase = "direct",     safeHeight = 0,
    lastTargetPos = nil,
}

Helpers.GetSafeFlyVelocity = function(currentPos, targetPos, flySpeed)
    if not getgenv().AvoidLockedAreas then
        local direction = (targetPos - currentPos).Unit
        return direction * flySpeed
    end
    
        local insideLocked, lockedBox = IsPositionInsideLockedRegion(currentPos)
    if insideLocked then
                print("[AvoidLockedAreas] INSIDE locked region! Flying up to escape...")
        return Vector3.new(0, flySpeed, 0)
    end
    
        if not AvoidFlightState.lastTargetPos or (AvoidFlightState.lastTargetPos - targetPos).Magnitude > 10 then
        AvoidFlightState.phase = "direct"
        AvoidFlightState.lastTargetPos = targetPos
    end
    
        local wouldHit, hitBox = DoesPathIntersectLockedRegion(currentPos, targetPos)
    
    if wouldHit then
                        local maxHeight = GetLockedRegionsMaxHeight()
        local safeHeight = maxHeight + 50         AvoidFlightState.safeHeight = safeHeight
        
        if AvoidFlightState.phase == "direct" then
            AvoidFlightState.phase = "ascending"
        end
        
        if AvoidFlightState.phase == "ascending" then
                        if currentPos.Y < safeHeight then
                return Vector3.new(0, flySpeed, 0)
            else
                AvoidFlightState.phase = "horizontal"
            end
        end
        
        if AvoidFlightState.phase == "horizontal" then
                        local horizontalTarget = Vector3.new(targetPos.X, currentPos.Y, targetPos.Z)
            local horizontalDir = horizontalTarget - currentPos
            local horizontalDist = horizontalDir.Magnitude
            
                        local hHit = DoesPathIntersectLockedRegion(currentPos, horizontalTarget)
            if hHit then
                                AvoidFlightState.safeHeight = AvoidFlightState.safeHeight + 30
                AvoidFlightState.phase = "ascending"
                return Vector3.new(0, flySpeed, 0)
            end
            
            if horizontalDist > 8 then
                return horizontalDir.Unit * flySpeed
            else
                                AvoidFlightState.phase = "descending"
            end
        end
        
        if AvoidFlightState.phase == "descending" then
                        local dHit = DoesPathIntersectLockedRegion(currentPos, targetPos)
            if dHit then
                                AvoidFlightState.phase = "horizontal"
                local horizontalTarget = Vector3.new(targetPos.X, currentPos.Y, targetPos.Z)
                local horizontalDir = horizontalTarget - currentPos
                if horizontalDir.Magnitude > 1 then
                    return horizontalDir.Unit * flySpeed
                else
                                        AvoidFlightState.safeHeight = AvoidFlightState.safeHeight + 30
                    AvoidFlightState.phase = "ascending"
                    return Vector3.new(0, flySpeed, 0)
                end
            end
            
                        local descendDir = targetPos - currentPos
            if descendDir.Magnitude > 1 then
                return descendDir.Unit * flySpeed
            else
                                AvoidFlightState.phase = "direct"
                return Vector3.new(0, 0, 0)
            end
        end
    else
                AvoidFlightState.phase = "direct"
        local direction = targetPos - currentPos
        if direction.Magnitude > 1 then
            return direction.Unit * flySpeed
        else
            return Vector3.new(0, 0, 0)
        end
    end
    
        local direction = (targetPos - currentPos)
    if direction.Magnitude > 1 then
        return direction.Unit * flySpeed
    end
    return Vector3.new(0, 0, 0)
end

Helpers.RefreshLockedRegions = function()
    LockedRegionParts = {}
    LockedRegionsCollected = false
    CollectLockedRegions()
    return #LockedRegionParts
end

pcall(function()
    local SharedData = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Data")
    GameData.Enemies = Helpers.SafeRequire(SharedData:WaitForChild("Enemies"))
    GameData.OreList = Helpers.SafeRequire(SharedData:WaitForChild("Ore"))
    GameData.Rock = Helpers.SafeRequire(SharedData:WaitForChild("Rock"))
    GameData.Rarities = Helpers.SafeRequire(SharedData:WaitForChild("Rarities"))
end)

local MobList = {
    "Yeti","Prismarine Spider","Mini Demonic Spider","Elite Orc","Diamond Spider",
    "Demonic Spider","Demonic Queen Spider","Crystal Spider","Crystal Golem","Common Orc",
    "Axe Skeleton","Blazing Slime","Blight Pyromancer","Bomber","Brute Zombie",
    "Deathaxe Skeleton","Delver Zombie","Elite Deathaxe Skeleton","Elite Rogue Skeleton",
    "Elite Zombie","Reaper","Skeleton Rogue","Slime","Zombie","Chuthlu","Skeleton Pirate",
}

local MobIcons = {}
local MobIslands = {}

-- Populate icons and islands if GameData.Enemies exists
if GameData.Enemies then
    for mobId, mobData in pairs(GameData.Enemies) do
        local mobName = mobData.Name or mobId

        -- Only assign icons if the mob exists in fallback list
        if table.find(MobList, mobName) then
            if mobData.Slot and mobData.Slot.Icon then
                MobIcons[mobName] = mobData.Slot.Icon
            end
            if mobData.Island then
                MobIslands[mobName] = mobData.Island
            end
        end
    end
end

-- Sort fallback list for convenience
table.sort(MobList)


local MobListWithIcons = {}
for _, mobName in ipairs(MobList) do
    table.insert(MobListWithIcons, {
        Title = mobName,
        Icon = MobIcons[mobName] or "skull",
    })
end

local MiningOreList = {}
local OreRarityMap = {} local OreDataMap = {}   
if GameData.OreList then
            for _, oreData in ipairs(GameData.OreList) do
        if type(oreData) == "table" and oreData.Name then
            table.insert(MiningOreList, oreData.Name)
                        if oreData.Rarity then
                OreRarityMap[oreData.Name] = oreData.Rarity
            end
                        OreDataMap[oreData.Name] = oreData
        end
    end
        table.sort(MiningOreList)
    print("[Dynamic Load] Loaded", #MiningOreList, "ores from game data")
else
        warn("[Dynamic Load] Using fallback ore list")
    MiningOreList = {
        "Aether Lotus", "Aetherit", "Aite", "Amethyst", "Aqujade", "Arcane Crystal",
        "Bananite", "Blue Crystal", "Boneite", "Cardboardite", "Ceyite", "Cobalt",
        "Coinite", "Copper", "Crimson Crystal", "Crimsonite", "Cryptex", "Cuprite",
        "Dark Boneite", "Darkryte", "Demonite", "Diamond", "Duranite", "Emerald", "Etherealite",
        "Evil Eye", "Eye Ore", "Fichillium", "Fichilliumorite", "Fireite", "Frogite", "Frost Fossil", "Galestor",
        "Galaxite", "Gargantuan", "Golem Heart", "Gold", "Graphite", "Grass", "Green Crystal", "Gulabite",
        "Heart Of The Island", "Heavenite", "Iceite", "Iron", "Lapis Lazuli", "Larimar", "Lgarite", "Lightite",
        "Magenta Crystal", "Magmaite", "Malachite", "Marblite", "Mistvein", "Moltenfrost", "Moon Stone",
        "Mosasaursit", "Mushroomite", "Mythril", "Neurotite", "Obsidian", "Orange Crystal",
        "Platinum", "Poopite", "Prismatic Heart", "Pumice", "Quartz", "Rainbow Crystal", "Rivalite", "Ruby",
        "Sand Stone", "Sanctis", "Sapphire", "Scheelite", "Silver", "Slimite", "Snowite", "Stolen Heart",
        "Stone", "Sulfur", "Suryafal", "Tide Carve", "Tin", "Titanium", "Topaz", "Tungsten",
        "Uranium", "Vanegos", "Velchire", "Volcanic Rock", "Voidfractal", "Voidstar",
        "Vooite", "Yeti Heart", "Zephyte",
    }
end

local RockList = {}
local RockOreData = {} 
if GameData.Rock then
        for rockName, rockData in pairs(GameData.Rock) do
        table.insert(RockList, rockName)
                if rockData.Ores then
            RockOreData[rockName] = rockData.Ores
        end
    end
        table.sort(RockList)
    print("[Dynamic Load] Loaded", #RockList, "rocks from game data")
else
        warn("[Dynamic Load] Using fallback rock list")
    RockList = {
        "Basalt Core", "Basalt Rock", "Basalt Vein", "Boulder", "Crimson Crystal",
        "Cyan Crystal", "Earth Crystal", "Floating Crystal", "Heart Of The Island", "Iceberg", "Icy Boulder",
        "Icy Pebble", "Icy Rock", "Large Ice Crystal", "Large Red Crystal", "Light Crystal", "Lucky Block",
        "Medium Ice Crystal", "Medium Red Crystal", "Pebble", "Rock", "Small Ice Crystal", "Small Red Crystal", "Violet Crystal",
        "Volcanic Rock",
    }
        RockOreData = {
        ["Pebble"] = {"Stone", "Sand Stone", "Copper", "Iron", "Poopite"},
        ["Rock"] = {"Sand Stone", "Copper", "Iron", "Tin", "Silver", "Poopite", "Bananite", "Cardboardite", "Mushroomite"},
        ["Boulder"] = {"Copper", "Iron", "Tin", "Silver", "Gold", "Platinum", "Poopite", "Bananite", "Cardboardite", "Mushroomite", "Aite"},
        ["Lucky Block"] = {"Fichillium", "Fichilliugeromoriteite"},
        ["Basalt Rock"] = {"Silver", "Gold", "Platinum", "Cobalt", "Titanium", "Lapis Lazuli", "Eye Ore"},
        ["Basalt Core"] = {"Cobalt", "Titanium", "Lapis Lazuli", "Quartz", "Amethyst", "Topaz", "Diamond", "Sapphire", "Cuprite", "Emerald", "Eye Ore"},
        ["Basalt Vein"] = {"Quartz", "Amethyst", "Topaz", "Diamond", "Sapphire", "Cuprite", "Emerald", "Ruby", "Rivalite", "Uranium", "Mythril", "Eye Ore", "Lightite"},
        ["Volcanic Rock"] = {"Volcanic Rock", "Topaz", "Cuprite", "Rivalite", "Obsidian", "Eye Ore", "Fireite", "Magmaite", "Demonite", "Fireite", "Darkryte"},
        ["Earth Crystal"] = {"Blue Crystal", "Crimson Crystal", "Green Crystal", "Magenta Crystal", "Orange Crystal", "Rainbow Crystal", "Arcane Crystal"},
        ["Cyan Crystal"] = {"Blue Crystal", "Crimson Crystal", "Green Crystal", "Magenta Crystal", "Orange Crystal", "Rainbow Crystal", "Arcane Crystal"},
        ["Crimson Crystal"] = {"Blue Crystal", "Crimson Crystal", "Green Crystal", "Magenta Crystal", "Orange Crystal", "Rainbow Crystal", "Arcane Crystal"},
        ["Violet Crystal"] = {"Blue Crystal", "Crimson Crystal", "Green Crystal", "Magenta Crystal", "Orange Crystal", "Rainbow Crystal", "Arcane Crystal"},
        ["Light Crystal"] = {"Blue Crystal", "Crimson Crystal", "Green Crystal", "Magenta Crystal", "Orange Crystal", "Rainbow Crystal", "Arcane Crystal"},
        ["Icy Pebble"] = {"Emerald", "Ruby", "Rivalite", "Uranium", "Mythril", "Lightite", "Tungsten", "Sulfur", "Pumice", "Graphite", "Aetherit", "Snowite"},
        ["Icy Rock"] = {"Uranium", "Mythril", "Lightite", "Tungsten", "Sulfur", "Pumice", "Graphite", "Aetherit", "Scheelite", "Larimar", "Neurotite", "Iceite", "Snowite"},
        ["Icy Boulder"] = {"Tungsten", "Sulfur", "Pumice", "Graphite", "Aetherit", "Scheelite", "Larimar", "Neurotite", "Frost Fossil", "Tide Carve", "Velchire", "Sanctis", "Iceite", "Snowite"},
        ["Small Ice Crystal"] = {"Aetherit", "Scheelite", "Larimar", "Neurotite", "Frost Fossil", "Tide Carve", "Velchire", "Sanctis", "Iceite", "Snowite", "Mistvein", "Lgarite", "Voidfractal", "Moltenfrost", "Crimsonite", "Suryafal"},
        ["Medium Ice Crystal"] = {"Frost Fossil", "Tide Carve", "Velchire", "Sanctis", "Iceite", "Snowite", "Mistvein", "Lgarite", "Voidfractal", "Moltenfrost", "Crimsonite", "Malachite", "Aqujade", "Cryptex", "Galestor", "Voidstar", "Suryafal"},
        ["Large Ice Crystal"] = {"Velchire", "Sanctis", "Iceite", "Snowite", "Mistvein", "Lgarite", "Voidfractal", "Moltenfrost", "Crimsonite", "Malachite", "Aqujade", "Cryptex", "Galestor", "Voidstar", "Etherealite", "Suryafal", "Gargantuan"},
        ["Floating Crystal"] = {"Velchire", "Sanctis", "Iceite", "Snowite", "Mistvein", "Lgarite", "Voidfractal", "Moltenfrost", "Crimsonite", "Malachite", "Aqujade", "Cryptex", "Galestor", "Voidstar", "Etherealite", "Suryafal", "Heavenite"},
        ["Iceberg"] = {"Mosasaursit"},
        ["Heart Of The Island"] = {"Frost Fossil", "Tide Carve", "Velchire", "Mistvein", "Lgarite", "Voidfractal", "Moltenfrost", "Crimsonite", "Malachite", "Cryptex", "Galestor", "Voidstar", "Etherealite", "Suryafal", "Gargantuan", "Frogite", "Moon Stone", "Gulabite", "Coinite", "Duranite", "Evil Eye", "Stolen Heart", "Heart Of The Island"},
        ["Large Red Crystal"] = {"Frost Fossil", "Tide Carve", "Velchire", "Iceite", "Snowite", "Mistvein", "Lgarite", "Voidfractal", "Moltenfrost", "Crimsonite", "Malachite", "Cryptex", "Galestor", "Voidstar", "Etherealite", "Suryafal", "Gargantuan", "Frogite", "Moon Stone", "Gulabite", "Coinite", "Duranite", "Evil Eye"},
        ["Medium Red Crystal"] = {"Frost Fossil", "Tide Carve", "Velchire", "Mistvein", "Lgarite", "Voidfractal", "Moltenfrost", "Crimsonite", "Malachite", "Aqujade", "Cryptex", "Galestor", "Voidstar", "Etherealite", "Suryafal", "Gargantuan", "Frogite", "Moon Stone", "Gulabite", "Coinite"},
        ["Small Red Crystal"] = {"Frost Fossil", "Tide Carve", "Velchire", "Mistvein", "Lgarite", "Voidfractal", "Moltenfrost", "Crimsonite", "Malachite", "Aqujade", "Cryptex", "Galestor", "Voidstar", "Etherealite", "Suryafal", "Gargantuan", "Frogite", "Moon Stone"},
    }
end

local RarityList = {}

if GameData.Rarities then
    for rarityName, _ in pairs(GameData.Rarities) do
        table.insert(RarityList, rarityName)
    end
    table.sort(RarityList)
else
        RarityList = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythic", "Divine", "Exotic", "Relic", "Unobtainable"}
end

Helpers.GetOreRarity = function(oreName) return OreRarityMap[oreName] or "Common" end
Helpers.GetOreData = function(oreName) return OreDataMap[oreName] end
Helpers.GetOresForRock = function(rockName) return RockOreData[rockName] or {} end

Helpers.GetPlayerFavorites = function()
    local favorites = nil
    pcall(function()
        local KnitService = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"))
        local PC = KnitService.GetController("PlayerController")
        if PC and PC.Replica and PC.Replica.Data then
            favorites = PC.Replica.Data.Favorites
        end
    end)
    return favorites or {}
end

Helpers.IsItemFavorited = function(itemKey, favoritesCache)
    local favorites = favoritesCache or Helpers.GetPlayerFavorites()
    if favorites and favorites[itemKey] == true then
        return true
    end
    return false
end

Helpers.GetRocksForOre = function(oreName)
    local rocks = {}
    for rockName, ores in pairs(RockOreData) do
        for _, ore in ipairs(ores) do
            if ore == oreName then table.insert(rocks, rockName) break end
        end
    end
    return rocks
end

Helpers.RockDropsSelectedOre = function(rockName)
    if not getgenv().SelectedOres or #getgenv().SelectedOres == 0 then return false end
    local ores = RockOreData[rockName]
    if not ores then return false end
    for _, ore in ipairs(ores) do
        for _, selectedOre in pairs(getgenv().SelectedOres) do
            if ore == selectedOre then return true end
        end
    end
    return false
end

Helpers.IsSelected = function(item, selectionList)
    if not selectionList then return false end
    for _, selected in pairs(selectionList) do
        if item == selected then return true end
    end
    return false
end

local Window = WindUI:CreateWindow({
    Title = "ToastyHub(For Sell): The Forge",
    Icon = "hammer",
    Author = "ToastyHub(For Sell)",
    Folder = "ForgeAutomation",
    Size = UDim2.fromOffset(500, 400),
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 180,
})

Window:Tag({
    Title = "Always Free",
    Icon = "badge-check",
    Color = Color3.fromHex("#30ff6a"),
    Radius = 10, })
Window:Tag({
    Title = "V13",
    Icon = "git-compare",
    Color = Color3.fromHex("#be29ec"),
    Radius = 10, })

Window:SetToggleKey(Enum.KeyCode.RightControl)

Window:EditOpenButton({
    Title = "The Forge",
    Icon = "hammer",
    CornerRadius = UDim.new(0, 12),
    StrokeThickness = 2,
    Color = ColorSequence.new(
        Color3.fromRGB(255, 180, 60),
        Color3.fromRGB(255, 100, 50)
    ),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

local ForgeTab = Window:Tab({
    Title = "Forge",
    Icon = "flame",
})

ForgeTab:Section({
    Title = "Status",
    Icon = "info",
})

ForgeTab:Button({
    Title = "Open Forge",
    Desc = "Opens the forge UI from anywhere",
    Callback = function()
        pcall(function()
            local forgeStation = workspace:FindFirstChild("Proximity")
            if forgeStation then
                forgeStation = forgeStation:FindFirstChild("Forge")
            end
            
            if not forgeStation then
                WindUI:Notify({
                    Title = "Error",
                    Content = "Forge station not found!",
                    Duration = 3,
                    Icon = "alert-circle",
                })
                return
            end
            
            local proximityPrompt = forgeStation:FindFirstChildOfClass("ProximityPrompt", true)
            
            if proximityPrompt then
                fireproximityprompt(proximityPrompt)
                WindUI:Notify({
                    Title = "Success",
                    Content = "Forge opened!",
                    Duration = 2,
                    Icon = "check-circle",
                })
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "Proximity prompt not found!",
                    Duration = 3,
                    Icon = "alert-circle",
                })
            end
        end)
    end
})

ForgeTab:Divider()

ForgeTab:Section({
    Title = "Automation",
    Icon = "zap",
})

ForgeTab:Toggle({
    Title = "Auto Melt",
    Desc = "Automatically completes the melt minigame",
    Value = true,
    Flag = "AutoMelt",
    Callback = function(state)
        getgenv().AutoMelt = state
    end
})

ForgeTab:Toggle({
    Title = "Auto Pour",
    Desc = "Automatically completes the pour minigame",
    Value = true,
    Flag = "AutoPour",
    Callback = function(state)
        getgenv().AutoPour = state
    end
})

ForgeTab:Toggle({
    Title = "Auto Hammer",
    Desc = "Automatically completes the hammer minigame with perfect timing",
    Value = true,
    Flag = "AutoHammer",
    Callback = function(state)
        getgenv().AutoHammer = state
    end
})

ForgeTab:Toggle({
    Title = "Skip To Hammer",
    Desc = "Skips Melt & Pour phases, goes directly to Hammer (FastForge)",
    Value = true,
    Flag = "SkipToHammer",
    Callback = function(state)
        getgenv().SkipToHammer = state
    end
})

local MiscTab = Window:Tab({
    Title = "Misc",
    Icon = "settings-2",
})

getgenv().MiscState = getgenv().MiscState or {
    noclip = false,
    fly = false,
    infJump = false,
    flySpeed = 70,
    transparent = false,
    transparentRadius = 75,
    transparentValue = 0.7,
    conns = {},
    trackedParts = {},
    originalTransparency = {},
    isChanged = {},
    keys = { noclip = "N", fly = "F", infJump = "J" }
}

local function setMiscNoclip(enabled)
    getgenv().MiscState.noclip = enabled
    if getgenv().MiscState.conns.noclip then getgenv().MiscState.conns.noclip:Disconnect() end
    if enabled then
        getgenv().MiscState.conns.noclip = RunService.Stepped:Connect(function()
            local char = LocalPlayer.Character
            if char then for _, d in ipairs(char:GetDescendants()) do if d:IsA("BasePart") then d.CanCollide = false end end end
        end)
    else
        local char = LocalPlayer.Character
        if char then for _, d in ipairs(char:GetDescendants()) do if d:IsA("BasePart") then d.CanCollide = true end end end
    end
end

local function setMiscFly(enabled)
    getgenv().MiscState.fly = enabled
    if getgenv().MiscState.conns.fly then getgenv().MiscState.conns.fly:Disconnect() end
    if enabled then
        setMiscNoclip(true)
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then hum.PlatformStand = true end
        getgenv().MiscState.conns.fly = RunService.RenderStepped:Connect(function()
            local c = LocalPlayer.Character
            if not c then return end
            local h = c:FindFirstChild("HumanoidRootPart")
            if not h then return end
            local cam, dir = workspace.CurrentCamera, Vector3.new()
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then dir = dir + cam.CFrame.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then dir = dir - cam.CFrame.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then dir = dir - cam.CFrame.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then dir = dir + cam.CFrame.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then dir = dir + Vector3.new(0, 1, 0) end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then dir = dir - Vector3.new(0, 1, 0) end
            if dir.Magnitude > 0 then dir = dir.Unit * getgenv().MiscState.flySpeed end
            h.AssemblyLinearVelocity = dir
        end)
    else
        local char = LocalPlayer.Character
        if char then
            local hum, hrp = char:FindFirstChildOfClass("Humanoid"), char:FindFirstChild("HumanoidRootPart")
            if hum then hum.PlatformStand = false end
            if hrp then hrp.AssemblyLinearVelocity = Vector3.new() end
        end
        setMiscNoclip(false)
    end
end

local function setMiscInfJump(enabled)
    getgenv().MiscState.infJump = enabled
    if getgenv().MiscState.conns.infJump then getgenv().MiscState.conns.infJump:Disconnect() end
    if enabled then
        getgenv().MiscState.conns.infJump = UserInputService.JumpRequest:Connect(function()
            local char = LocalPlayer.Character
            if char then local hum = char:FindFirstChildOfClass("Humanoid") if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end end
        end)
    end
end

local function setMiscSpeedBoost(value)
    local living = workspace:FindFirstChild("Living")
    local playerFolder = living and living:FindFirstChild(LocalPlayer.Name)
    if not playerFolder then return end
    local status = playerFolder:FindFirstChild("Status") or Instance.new("Folder", playerFolder)
    status.Name = "Status"
    local boost = status:FindFirstChild("PercentageSpeedBoost")
    if boost and boost:IsA("NumberValue") then boost.Value = value
    else local num = Instance.new("NumberValue") num.Name = "PercentageSpeedBoost" num.Value = value num.Parent = status end
end

local function setMiscTransparent(enabled)
    local state = getgenv().MiscState
    state.transparent = enabled
    if state.conns.transparent then state.conns.transparent:Disconnect() end
    
    if not enabled then
                for part in pairs(state.isChanged) do
            if part and part.Parent and state.originalTransparency[part] then
                pcall(function() part.Transparency = state.originalTransparency[part] end)
            end
        end
        state.originalTransparency, state.isChanged = {}, {}
        return
    end
    
    local Assets = workspace:FindFirstChild("Assets")
    local Rocks = workspace:FindFirstChild("Rocks")
    if not Assets and not Rocks then 
        WindUI:Notify({Title = "Error", Content = "Assets/Rocks folders not found", Duration = 3, Icon = "alert-circle"}) 
        return 
    end
    
    local Camera = workspace.CurrentCamera
    local previousBlockers = {}     
    state.conns.transparent = RunService.RenderStepped:Connect(function()
        local char = LocalPlayer.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        local tval = state.transparentValue
        local origTrans = state.originalTransparency
        local isChanged = state.isChanged
        
        local camPos = Camera.CFrame.Position
        local camCF = Camera.CFrame
        local targetPos = hrp.Position
        local distance = (targetPos - camPos).Magnitude
        
        if distance < 1 then return end
        
        local currentBlockers = {}
        
                        local rayTargets = {}
        
                table.insert(rayTargets, targetPos)
        table.insert(rayTargets, targetPos + Vector3.new(0, 2, 0))         table.insert(rayTargets, targetPos + Vector3.new(0, -2, 0))         
                local spread = math.min(distance * 0.6, 25)         
                for x = -1.5, 1.5, 1 do
            for y = -1.5, 1.5, 1 do
                local offset = camCF.RightVector * (x * spread) + camCF.UpVector * (y * spread)
                table.insert(rayTargets, targetPos + offset)
            end
        end
        
                local midPoint = camPos:Lerp(targetPos, 0.5)
        for x = -1.5, 1.5, 1 do
            for y = -1.5, 1.5, 1 do
                local offset = camCF.RightVector * (x * spread * 0.7) + camCF.UpVector * (y * spread * 0.7)
                table.insert(rayTargets, midPoint + offset)
            end
        end
        
                local quarterPoint = camPos:Lerp(targetPos, 0.25)
        for x = -1.5, 1.5, 1 do
            for y = -1.5, 1.5, 1 do
                local offset = camCF.RightVector * (x * spread * 0.4) + camCF.UpVector * (y * spread * 0.4)
                table.insert(rayTargets, quarterPoint + offset)
            end
        end
        
        for _, target in ipairs(rayTargets) do
            local rayDir = target - camPos
            local rayExclude = {char}
            
            for _ = 1, 10 do
                local rayParams = RaycastParams.new()
                rayParams.FilterType = Enum.RaycastFilterType.Exclude
                rayParams.FilterDescendantsInstances = rayExclude
                rayParams.IgnoreWater = true
                
                local result = workspace:Raycast(camPos, rayDir, rayParams)
                
                if not result then break end
                
                local part = result.Instance
                if not part then break end
                
                                if not part:IsA("BasePart") then
                    table.insert(rayExclude, part)
                    continue
                end
                
                                table.insert(rayExclude, part)
                
                                local inAssets = Assets and part:IsDescendantOf(Assets)
                local inRocks = Rocks and part:IsDescendantOf(Rocks)
                
                                if inRocks then
                    local partName = part.Name:lower()
                    if partName == "hitbox" or partName == "ore" then
                        continue
                    end
                end
                
                if inAssets or inRocks then
                    currentBlockers[part] = true
                    if not isChanged[part] then
                        origTrans[part] = part.Transparency
                        part.Transparency = tval
                        isChanged[part] = true
                    end
                end
            end
        end
        
                for part in pairs(previousBlockers) do
            if not currentBlockers[part] and isChanged[part] then
                if part and part.Parent then
                    part.Transparency = origTrans[part] or 0
                    isChanged[part] = nil
                end
            end
        end
        
        previousBlockers = currentBlockers
    end)
end

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    if getgenv().MiscState.noclip then setMiscNoclip(true) end
    if getgenv().MiscState.fly then setMiscFly(true) end
    if getgenv().MiscState.infJump then setMiscInfJump(true) end
end)

MiscTab:Section({ Title = "Movement", Icon = "move" })

local NoclipToggle = MiscTab:Toggle({
    Title = "Noclip",
    Desc = "Walk through walls",
    Value = false,
    Callback = function(state)
        if getgenv().MiscState.fly and not state then WindUI:Notify({Title = "Noclip", Content = "Cannot disable while Fly is enabled", Duration = 2, Icon = "alert-circle"}) return end
        setMiscNoclip(state)
        WindUI:Notify({Title = "Noclip", Content = state and "Enabled" or "Disabled", Duration = 2, Icon = state and "check-circle" or "x-circle"})
    end
})

MiscTab:Keybind({
    Title = "Noclip Key",
    Desc = "Keybind to toggle noclip",
    Value = "N",
    Callback = function()
        if getgenv().MiscState.fly then 
            setMiscFly(false) 
            FlyToggle:Set(false)
            WindUI:Notify({Title = "Fly", Content = "Disabled", Duration = 2, Icon = "x-circle"}) 
        end
        setMiscNoclip(not getgenv().MiscState.noclip)
        NoclipToggle:Set(getgenv().MiscState.noclip)
        WindUI:Notify({Title = "Noclip", Content = getgenv().MiscState.noclip and "Enabled" or "Disabled", Duration = 2, Icon = getgenv().MiscState.noclip and "check-circle" or "x-circle"})
    end
})

local FlyToggle = MiscTab:Toggle({
    Title = "Fly",
    Desc = "Fly around - WASD + Space/Shift",
    Value = false,
    Callback = function(state)
        setMiscFly(state)
        if state then NoclipToggle:Set(true) end
        if not state then NoclipToggle:Set(false) end
        WindUI:Notify({Title = "Fly", Content = state and "Enabled" or "Disabled", Duration = 2, Icon = state and "check-circle" or "x-circle"})
    end
})

MiscTab:Keybind({
    Title = "Fly Key",
    Desc = "Keybind to toggle fly",
    Value = "G",
    Callback = function()
        setMiscFly(not getgenv().MiscState.fly)
        FlyToggle:Set(getgenv().MiscState.fly)
        NoclipToggle:Set(getgenv().MiscState.noclip)
        WindUI:Notify({Title = "Fly", Content = getgenv().MiscState.fly and "Enabled" or "Disabled", Duration = 2, Icon = getgenv().MiscState.fly and "check-circle" or "x-circle"})
    end
})

MiscTab:Slider({
    Title = "Fly Speed",
    Desc = "Adjust flying speed",
    Step = 1,
    Value = {
        Min = 10,
        Max = 200,
        Default = 70,
    },
    Callback = function(value) getgenv().MiscState.flySpeed = value end
})

local InfJumpToggle = MiscTab:Toggle({
    Title = "Infinite Jump",
    Desc = "Jump in mid-air",
    Value = false,
    Callback = function(state)
        setMiscInfJump(state)
        WindUI:Notify({Title = "Infinite Jump", Content = state and "Enabled" or "Disabled", Duration = 2, Icon = state and "check-circle" or "x-circle"})
    end
})

MiscTab:Keybind({
    Title = "Infinite Jump Key",
    Desc = "Keybind to toggle infinite jump",
    Value = "J",
    Callback = function()
        setMiscInfJump(not getgenv().MiscState.infJump)
        InfJumpToggle:Set(getgenv().MiscState.infJump)
        WindUI:Notify({Title = "Infinite Jump", Content = getgenv().MiscState.infJump and "Enabled" or "Disabled", Duration = 2, Icon = getgenv().MiscState.infJump and "check-circle" or "x-circle"})
    end
})

MiscTab:Divider()

MiscTab:Section({ Title = "Speed Boost", Icon = "zap" })

MiscTab:Slider({
    Title = "Speed Boost %",
    Desc = "Adjust movement speed boost",
    Step = 1,
    Value = {
        Min = 0,
        Max = 10,
        Default = 0,
    },
    Callback = function(value) setMiscSpeedBoost(value) end
})

MiscTab:Button({
    Title = "Reset Speed",
    Desc = "Reset speed boost to 0",
    Callback = function()
        setMiscSpeedBoost(0)
        WindUI:Notify({Title = "Speed Reset", Content = "Reset to 0", Duration = 2, Icon = "check-circle"})
    end
})

MiscTab:Divider()

MiscTab:Section({ Title = "Transparency", Icon = "eye" })

MiscTab:Toggle({
    Title = "Transparent Assets",
    Desc = "Auto-hide assets blocking camera view",
    Value = false,
    Callback = function(state)
        setMiscTransparent(state)
        WindUI:Notify({Title = "Transparency", Content = state and "Enabled" or "Disabled", Duration = 2, Icon = state and "check-circle" or "x-circle"})
    end
})

MiscTab:Slider({
    Title = "Transparency Level",
    Desc = "0 = invisible, 1 = solid",
    Step = 0.1,
    Value = {
        Min = 0,
        Max = 1,
        Default = 0.7,
    },
    Callback = function(value) getgenv().MiscState.transparentValue = value end
})

local ShopManagerTab = Window:Tab({
    Title = "Shop Manager",
    Icon = "shopping-bag",
})

ShopManagerTab:Section({
    Title = "Auto Sell Manager",
    Icon = "dollar-sign",
})

getgenv().ShopManagerGUILoaded = false

local ShopManagerButton = ShopManagerTab:Button({
    Title = "Load Shop Manager",
    Desc = "Opens the Auto Sell GUI for managing ores, runes & essences",
    Callback = function()
                if getgenv().AutoSellGUI then
                        if getgenv().AutoSellGUI.Visible then
                getgenv().AutoSellGUI:Hide()
                ShopManagerButton:SetTitle("Open GUI")
                ShopManagerButton:SetDesc("Click to open the Shop Manager (or press F6)")
            else
                getgenv().AutoSellGUI:Show()
                ShopManagerButton:SetTitle("Close GUI")
                ShopManagerButton:SetDesc("Click to close the Shop Manager (or press F6)")
            end
        else
                        WindUI:Notify({
                Title = "Shop Manager",
                Content = "Loading Auto Sell GUI...",
                Duration = 2,
                Icon = "loader",
            })
            
            local success, err = pcall(function()
                loadstring(game:HttpGet("https://raw.githubusercontent.com/nouralddin-abdullah/99-night/refs/heads/main/shop-manager-gui.luau"))()
            end)
            
            if success then
                                task.wait(0.1)
                
                                if getgenv().AutoSellGUI then
                                        getgenv().AutoSellGUI:Show()
                    ShopManagerButton:SetTitle("Close GUI")
                    ShopManagerButton:SetDesc("Click to close the Shop Manager (or press F6)")
                    WindUI:Notify({
                        Title = "Shop Manager",
                        Content = "Loaded! Press F6 to open/close.",
                        Duration = 3,
                        Icon = "check-circle",
                    })
                else
                    WindUI:Notify({
                        Title = "Shop Manager",
                        Content = "GUI loaded but not accessible. Try again.",
                        Duration = 3,
                        Icon = "alert-triangle",
                    })
                end
            else
                WindUI:Notify({
                    Title = "Shop Manager",
                    Content = "Failed to load: " .. tostring(err),
                    Duration = 5,
                    Icon = "alert-circle",
                })
            end
        end
    end
})

ShopManagerTab:Paragraph({
    Title = "How to Use",
    Desc = "• Click button above to load the Shop Manager GUI\n• Once loaded, press F6 to open/close\n• Select items by tab (Ores, Runes, Essences)\n• Use rarity filters to quickly select items\n• Configure auto-sell intervals in Settings tab\n\n⚠️ Note: Xeno executor users - multi-trait and high-roll rune protection is not available due to require() limitations. Starred/favorited protection works via GUI detection.",
})

local MobsTab = Window:Tab({
    Title = "Mobs",
    Icon = "skull",
})

MobsTab:Section({
    Title = "Mob Selection",
    Icon = "target",
})

MobsTab:Dropdown({
    Title = "Select Mobs",
    Desc = "Choose which mobs to target (multi-select)",
    Multi = true,
    Flag = "SelectedMobs",
    Values = MobListWithIcons,
    Callback = function(options)
        getgenv().SelectedMobs = options
    end
})

MobsTab:Dropdown({
    Title = "Target Priority",
    Desc = "How to choose which mob to attack first",
    Multi = false,
    Flag = "MobPriority",
    Value = "Nearest",
    Values = {"Nearest", "Weakest", "Strongest"},
    Callback = function(value)
        getgenv().MobPriority = value
    end
})

MobsTab:Divider()

MobsTab:Section({
    Title = "Auto Attack",
    Icon = "sword",
})

MobsTab:Slider({
    Title = "Attack Distance",
    Desc = "Distance to stay from mob",
    Step = 1,
    Flag = "AttackDistance",
    Value = {
        Min = 2,
        Max = 15,
        Default = 2,
    },
    Callback = function(value)
        getgenv().AttackDistance = value
    end
})

MobsTab:Slider({
    Title = "Fly Speed",
    Desc = "Speed to fly towards mobs",
    Step = 1,
    Flag = "MobFlySpeed",
    Value = {
        Min = 15,
        Max = 60,
        Default = 50,
    },
    Callback = function(value)
        getgenv().FlySpeed = value
    end
})

MobsTab:Slider({
    Title = "Attack Depth",
    Desc = "Vertical offset (-10 = up, 0 = surface, 10 = down)",
    Step = 1,
    Flag = "MobDepthOffset",
    Value = {
        Min = -10,
        Max = 10,
        Default = 0,
    },
    Callback = function(value)
        getgenv().MobDepthOffset = value
    end
})

MobsTab:Toggle({
    Title = "Auto Attack Mobs",
    Desc = "Teleport to selected mobs and attack them",
    Value = false,
    Callback = function(state)
        getgenv().AutoMob = state
        getgenv().NoClipEnabled = state         if state then
            WindUI:Notify({
                Title = "Mob Attack Enabled",
                Content = "Targeting selected mobs... (No-clip ON)",
                Duration = 2,
                Icon = "sword",
            })
        else
            WindUI:Notify({
                Title = "Mob Attack Disabled",
                Content = "No-clip OFF",
                Duration = 2,
                Icon = "square",
            })
        end
    end
})

local AntiGoblinMobsToggle = MobsTab:Toggle({
    Title = "Anti-Goblin Village",
    Desc = "Fly up first to avoid Goblin Village teleport zone (Map 2 only)",
    Icon = "shield",
    Value = false,
    Flag = "AntiGoblinVillageMobs",
    Callback = function(state)
        getgenv().AntiGoblinVillage = state
        if state then
            WindUI:Notify({
                Title = "Anti-Goblin Village ON",
                Content = "Will fly up " .. getgenv().AntiGoblinHeight .. " studs before moving to targets",
                Duration = 3,
                Icon = "shield",
            })
        end
    end
})

if GetCurrentMapNumber() ~= 2 then
    AntiGoblinMobsToggle:Lock()
end

local AvoidLockedAreasMobsToggle = MobsTab:Toggle({
    Title = "Avoid Locked Areas",
    Desc = "Fly over/around locked cave regions (Map 3 only)",
    Icon = "mountain",
    Value = false,
    Flag = "AvoidLockedAreasMobs",
    Callback = function(state)
        getgenv().AvoidLockedAreas = state
        if state then
            WindUI:Notify({
                Title = "Avoid Locked Areas ON",
                Content = "Will fly around locked cave zones",
                Duration = 3,
                Icon = "mountain",
            })
        end
    end
})

if GetCurrentMapNumber() ~= 3 then
    AvoidLockedAreasMobsToggle:Lock()
end

MobsTab:Divider()

MobsTab:Section({
    Title = "Area Filter",
    Icon = "map-pin",
})

local function GetMobSpawnAreas()
    local areas = {}
    local MobSpawns = workspace:FindFirstChild("Debris") and workspace.Debris:FindFirstChild("MobSpawns")
    if MobSpawns then
        for _, areaFolder in pairs(MobSpawns:GetChildren()) do
            if areaFolder:IsA("Folder") then
                table.insert(areas, areaFolder.Name)
            end
        end
    end
    table.sort(areas)
    return areas
end

local MobUI = {}

MobsTab:Toggle({
    Title = "Filter by Area",
    Desc = "Only attack mobs in selected spawn areas",
    Value = false,
    Flag = "FilterMobByArea",
    Callback = function(state)
        getgenv().FilterMobByArea = state
        if MobUI.MobAreaDropdown then
            if state then
                MobUI.MobAreaDropdown:Unlock()
            else
                MobUI.MobAreaDropdown:Lock()
            end
        end
    end
})

MobUI.MobAreaDropdown = MobsTab:Dropdown({
    Title = "Select Mob Areas",
    Desc = "Choose which spawn areas to target mobs in",
    Multi = true,
    AllowNone = true,
    Flag = "SelectedMobAreas",
    Values = GetMobSpawnAreas(),
    Value = {},
    Callback = function(values)
        getgenv().SelectedMobAreas = values
    end
})
MobUI.MobAreaDropdown:Lock()

MobsTab:Button({
    Title = "Refresh Mob Area List",
    Desc = "Update available mob spawn areas",
    Callback = function()
        local newAreas = GetMobSpawnAreas()
        MobUI.MobAreaDropdown:Refresh(newAreas)
        WindUI:Notify({
            Title = "Mob Areas Refreshed",
            Content = "Found " .. #newAreas .. " mob spawn areas",
            Duration = 2,
            Icon = "refresh-cw",
        })
    end
})

local BossesTab = Window:Tab({
    Title = "Bosses",
    Icon = "crown",
})

local BossData = {
    ["Golem"] = {
        ActiveDuration = 900,            SpawnInterval = 3600,            Arena = "Island3BossArena",
        RegionName = "Island3BossArena",
    },
}

local BossList = {}
for bossName, _ in pairs(BossData) do
    table.insert(BossList, bossName)
end
table.sort(BossList)

local BossState = {
    checkThread = nil,
    isFighting = false,
    lastAttackTime = 0,
    bodyVelocity = nil,
    bodyGyro = nil,
    currentTarget = nil,
    connection = nil,
    sessionAttacked = {},
    lastTimerValue = {},
    isAvoiding = false, }

local function FindBoss(bossName)
            local Living = workspace:FindFirstChild("Living")
    if Living then
        for _, entity in pairs(Living:GetChildren()) do
                        if entity:IsA("Model") and string.sub(entity.Name, 1, #bossName) == bossName then
                local humanoid = entity:FindFirstChildOfClass("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    return entity
                end
            end
        end
    end
    
    return nil
end

local function FindAnySelectedBoss()
    for _, bossName in pairs(getgenv().SelectedBosses) do
        local boss = FindBoss(bossName)
        if boss then
            return boss, bossName
        end
    end
    return nil, nil
end

pcall(function()
    local PartyService = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("PartyService")
    BossState.createPartyRemote = PartyService:WaitForChild("RF"):WaitForChild("CreateParty")
    BossState.activatePartyRemote = PartyService:WaitForChild("RF"):WaitForChild("Activate")
end)

pcall(function()
    BossState.attackRemote = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated")
end)

local function GetBossTimer(bossName)
    local proximity = workspace:FindFirstChild("Proximity")
    if not proximity then return nil end
    local createParty = proximity:FindFirstChild("CreateParty")
    if not createParty then return nil end
    local bossProximity = createParty:FindFirstChild(bossName)
    if not bossProximity then return nil end
    local timer = bossProximity:FindFirstChild("Timer")
    if not timer then return nil end
    local container = timer:FindFirstChild("Container")
    if not container then return nil end
    local label = container:FindFirstChild("Label")
    if not label then return nil end
    
    local timeText = label.ContentText or label.Text or ""
        local minutes, seconds = timeText:match("(%d+):(%d+)")
    if minutes and seconds then
        return tonumber(minutes) * 60 + tonumber(seconds)
    end
    return nil
end

local function CheckBossSessionReset(bossName)
    local currentTimer = GetBossTimer(bossName)
    if not currentTimer then return end
    
    local lastTimer = BossState.lastTimerValue[bossName]
    BossState.lastTimerValue[bossName] = currentTimer
    
        if lastTimer and lastTimer < 60 and currentTimer > 3000 then
        BossState.sessionAttacked[bossName] = false
        WindUI:Notify({
            Title = "New Boss Session!",
            Content = bossName .. " session has reset. Ready to fight!",
            Duration = 5,
            Icon = "refresh-cw",
        })
    end
end

local function FlyToCreatePartyProximity()
    local proximity = workspace:FindFirstChild("Proximity")
    if not proximity then return false end
    local createPartyPart = proximity:FindFirstChild("CreateParty")
    if not createPartyPart then return false end
    
    local character = LocalPlayer.Character
    if not character then return false end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
        local targetPos
    if createPartyPart:IsA("BasePart") then
        targetPos = createPartyPart.Position
    elseif createPartyPart:IsA("Model") then
        targetPos = createPartyPart:GetPivot().Position
    else
        return false
    end
    
        local wasNoClipEnabled = getgenv().NoClipEnabled
    getgenv().NoClipEnabled = true
    
    local flyBV = Instance.new("BodyVelocity")
    flyBV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    flyBV.Velocity = Vector3.new(0, 0, 0)
    flyBV.Parent = hrp
    
    local flyBG = Instance.new("BodyGyro")
    flyBG.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    flyBG.P = 10000
    flyBG.D = 100
    flyBG.Parent = hrp
    
    humanoid.PlatformStand = true
    
        local startTime = tick()
    local maxFlyTime = 120     
    while tick() - startTime < maxFlyTime do
        if not getgenv().AutoBoss then break end
        
        local distance = (hrp.Position - targetPos).Magnitude
        if distance < 10 then
                        break
        end
        
        flyBV.Velocity = Helpers.GetSafeFlyVelocity(hrp.Position, targetPos, getgenv().BossFlySpeed)
        flyBG.CFrame = CFrame.new(hrp.Position, targetPos)
        
        task.wait()
    end
    
        flyBV.Velocity = Vector3.new(0, 0, 0)
    task.wait(1)
    
        pcall(function() flyBV:Destroy() end)
    pcall(function() flyBG:Destroy() end)
    humanoid.PlatformStand = false
    getgenv().NoClipEnabled = wasNoClipEnabled
    
    return true
end

local function SpawnBoss(bossName)
    if not BossState.createPartyRemote or not BossState.activatePartyRemote then
        warn("Party remotes not available")
        return false
    end
    
        WindUI:Notify({
        Title = "Flying to Party Area",
        Content = "Flying to CreateParty location...",
        Duration = 3,
        Icon = "navigation",
    })
    
    local reachedProximity = FlyToCreatePartyProximity()
    if not reachedProximity then
        warn("Could not reach CreateParty part")
        return false
    end
    
    WindUI:Notify({
        Title = "Creating Party",
        Content = "Creating party for " .. bossName .. "...",
        Duration = 2,
        Icon = "users",
    })
    
    task.wait(0.5)
    
        local createSuccess, createResult = pcall(function()
        return BossState.createPartyRemote:InvokeServer(bossName)
    end)
    
    if not createSuccess then
        warn("Failed to create party: " .. tostring(createResult))
        return false
    end
    
    task.wait(0.5)     
        local activateSuccess, activateResult = pcall(function()
        return BossState.activatePartyRemote:InvokeServer()
    end)
    
    if not activateSuccess then
        warn("Failed to activate party: " .. tostring(activateResult))
        return false
    end
    
    return true
end


local function SetupBossFly(hrp)
    if BossState.bodyVelocity then pcall(function() BossState.bodyVelocity:Destroy() end) end
    if BossState.bodyGyro then pcall(function() BossState.bodyGyro:Destroy() end) end
    
    BossState.bodyVelocity = Instance.new("BodyVelocity")
    BossState.bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    BossState.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    BossState.bodyVelocity.Parent = hrp
    
    BossState.bodyGyro = Instance.new("BodyGyro")
    BossState.bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    BossState.bodyGyro.P = 10000
    BossState.bodyGyro.D = 100
    BossState.bodyGyro.Parent = hrp
    
    return BossState.bodyVelocity, BossState.bodyGyro
end

local function CleanupBossFly()
    pcall(function() if BossState.bodyVelocity then BossState.bodyVelocity:Destroy() end end)
    pcall(function() if BossState.bodyGyro then BossState.bodyGyro:Destroy() end end)
    BossState.bodyVelocity = nil
    BossState.bodyGyro = nil
    BossState.currentTarget = nil
    
    pcall(function()
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.PlatformStand = false
            end
        end
    end)
end

local function StartBossAttack(bossModel, bossName)
    if BossState.connection then BossState.connection:Disconnect() end
    
    BossState.currentTarget = bossModel
    local wasNoClipEnabled = getgenv().NoClipEnabled
    getgenv().NoClipEnabled = true
    
    BossState.connection = RunService.Heartbeat:Connect(function()
        if not BossState.isFighting or not BossState.currentTarget then
            CleanupBossFly()
            getgenv().NoClipEnabled = wasNoClipEnabled
            if BossState.connection then BossState.connection:Disconnect() BossState.connection = nil end
            return
        end
        
        local character = LocalPlayer.Character
        if not character then return end
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        
                local bossHumanoid = BossState.currentTarget:FindFirstChildOfClass("Humanoid")
        if not bossHumanoid or bossHumanoid.Health <= 0 then
            BossState.isFighting = false
            CleanupBossFly()
            getgenv().NoClipEnabled = wasNoClipEnabled
            if BossState.connection then BossState.connection:Disconnect() BossState.connection = nil end
            return
        end
        
        local bossHRP = BossState.currentTarget:FindFirstChild("HumanoidRootPart") or BossState.currentTarget.PrimaryPart
        if not bossHRP then
            BossState.isFighting = false
            CleanupBossFly()
            getgenv().NoClipEnabled = wasNoClipEnabled
            if BossState.connection then BossState.connection:Disconnect() BossState.connection = nil end
            return
        end
        
                if not BossState.bodyVelocity or not BossState.bodyVelocity.Parent then
            SetupBossFly(hrp)
            if humanoid then
                humanoid.PlatformStand = true
            end
        end
        
                local bossIsAttacking = false
        if getgenv().BossAvoidAttacks then
            local statusFolder = BossState.currentTarget:FindFirstChild("Status")
            if statusFolder then
                local attackingVal = statusFolder:FindFirstChild("Attacking")
                local usingSkillVal = statusFolder:FindFirstChild("UsingSkill")
                if (attackingVal and attackingVal.Value == true) or (usingSkillVal and usingSkillVal.Value == true) then
                    bossIsAttacking = true
                end
            end
        end
        
        local targetPos = bossHRP.Position + Vector3.new(0, getgenv().BossDepthOffset, 0)
        local distance = (hrp.Position - targetPos).Magnitude
        
                if bossIsAttacking then
            BossState.isAvoiding = true
                        local avoidDirection = getgenv().BossDepthOffset >= 0 and 1 or -1
            local avoidTarget = hrp.Position + Vector3.new(0, avoidDirection * getgenv().BossAvoidDistance, 0)
            BossState.bodyVelocity.Velocity = (avoidTarget - hrp.Position).Unit * getgenv().BossFlySpeed
        else
            BossState.isAvoiding = false
                        if distance > getgenv().BossAttackDistance then
                BossState.bodyVelocity.Velocity = Helpers.GetSafeFlyVelocity(hrp.Position, targetPos, getgenv().BossFlySpeed)
            else
                                BossState.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
        end
        BossState.bodyGyro.CFrame = CFrame.new(hrp.Position, bossHRP.Position)
        
                local now = tick()
        if now - BossState.lastAttackTime >= 0.3 then
            BossState.lastAttackTime = now
            pcall(function()
                if BossState.attackRemote then
                    BossState.attackRemote:InvokeServer("Weapon")
                end
            end)
        end
    end)
    
        while BossState.isFighting and BossState.currentTarget do
        local bossHumanoid = BossState.currentTarget:FindFirstChildOfClass("Humanoid")
        if not bossHumanoid or bossHumanoid.Health <= 0 then
            break
        end
        task.wait(0.1)
    end
    
        if BossState.connection then BossState.connection:Disconnect() BossState.connection = nil end
    CleanupBossFly()
    getgenv().NoClipEnabled = wasNoClipEnabled
    
    local bossHumanoid = bossModel:FindFirstChildOfClass("Humanoid")
    return bossHumanoid and bossHumanoid.Health <= 0
end

local function StartBossCheck()
    if BossState.checkThread then return end
    
    BossState.checkThread = task.spawn(function()
        while getgenv().AutoBoss do
                        for _, bossName in pairs(getgenv().SelectedBosses) do
                CheckBossSessionReset(bossName)
            end
            
                        local boss, bossName = FindAnySelectedBoss()
            
            if boss then
                                local wasMining = getgenv().AutoMine
                local wasMobbing = getgenv().AutoMob
                
                if wasMining then getgenv().AutoMine = false end
                if wasMobbing then getgenv().AutoMob = false end
                
                task.wait(0.3)                 
                WindUI:Notify({
                    Title = "Boss Found!",
                    Content = "Fighting " .. bossName .. "...",
                    Duration = 5,
                    Icon = "crown",
                })
                
                BossState.isFighting = true
                local killed = StartBossAttack(boss, bossName)
                BossState.isFighting = false
                
                                BossState.sessionAttacked[bossName] = true
                
                if killed then
                    WindUI:Notify({
                        Title = "Boss Defeated!",
                        Content = bossName .. " has been slain! Waiting for next session...",
                        Duration = 5,
                        Icon = "trophy",
                    })
                else
                    WindUI:Notify({
                        Title = "Boss Fight Ended",
                        Content = "Fight with " .. bossName .. " ended. Waiting for next session...",
                        Duration = 3,
                        Icon = "info",
                    })
                end
                
                task.wait(1)                 
                                if wasMining then getgenv().AutoMine = true end
                if wasMobbing then getgenv().AutoMob = true end
            else
                                for _, selectedBoss in pairs(getgenv().SelectedBosses) do
                                        if BossState.sessionAttacked[selectedBoss] then
                                                local timerSeconds = GetBossTimer(selectedBoss)
                        if timerSeconds then
                            local mins = math.floor(timerSeconds / 60)
                            local secs = timerSeconds % 60
                                                        if secs == 0 and mins > 0 and mins % 10 == 0 then
                                WindUI:Notify({
                                    Title = "Waiting for Session",
                                    Content = selectedBoss .. " - " .. mins .. " minutes until next session",
                                    Duration = 3,
                                    Icon = "clock",
                                })
                            end
                        end
                    else
                                                WindUI:Notify({
                            Title = "Spawning Boss",
                            Content = "Flying to " .. selectedBoss .. " party creation...",
                            Duration = 3,
                            Icon = "crown",
                        })
                        
                        local spawned = SpawnBoss(selectedBoss)
                        if spawned then
                            WindUI:Notify({
                                Title = "Party Activated",
                                Content = "Watching for " .. selectedBoss .. " to spawn...",
                                Duration = 3,
                                Icon = "clock",
                            })
                                                        local spawnWaitStart = tick()
                            local maxSpawnWait = 10
                            while tick() - spawnWaitStart < maxSpawnWait and getgenv().AutoBoss do
                                local spawnedBoss = FindBoss(selectedBoss)
                                if spawnedBoss then
                                                                        break
                                end
                                task.wait(0.2)
                            end
                        else
                            WindUI:Notify({
                                Title = "Spawn Failed",
                                Content = "Could not create party for " .. selectedBoss,
                                Duration = 3,
                                Icon = "x",
                            })
                                                        BossState.sessionAttacked[selectedBoss] = true
                        end
                        break                     end
                end
            end
            
                        task.wait(1)
        end
    end)
end

local function StopBossCheck()
    BossState.isFighting = false
    if BossState.checkThread then
        task.cancel(BossState.checkThread)
        BossState.checkThread = nil
    end
end

if not getgenv().Controllers then
    getgenv().Controllers = {}
end

local BossController = {
        spamCount = 100,
    anchorTime = 5,
    respawnWaitTime = 5,
    depthOffset = 2,
    attackDistance = 2,
    flySpeed = 50,
    avoidSkills = false,     
        isActive = false,
    isKilling = false,
    currentTarget = nil,
    instantKillMonitorThread = nil,     instantKilledGolems = {},     
        killConnection = nil,
    noClipConnection = nil,
    bodyVelocity = nil,
    bodyGyro = nil,
    
        lastAttackTime = 0,
    attackRemote = nil,
}

pcall(function()
    BossController.attackRemote = ReplicatedStorage:WaitForChild("Shared")
        :WaitForChild("Packages"):WaitForChild("Knit")
        :WaitForChild("Services"):WaitForChild("ToolService")
        :WaitForChild("RF"):WaitForChild("ToolActivated")
end)

local INSTANT_KILL_POSITION = Vector3.new(-1244.7967529296875, -2386.561767578125, 5394.7646484375)

local function TeleportGolemToKillZone(golem)
    if not golem then return false end
    
    local hrp = golem:FindFirstChild("HumanoidRootPart")
    if not hrp then
                hrp = golem:FindFirstChild("Torso") or golem.PrimaryPart
    end
    if not hrp then return false end
    
        pcall(function()
        hrp.CFrame = CFrame.new(INSTANT_KILL_POSITION)
    end)
    
    return true
end

function BossController:StartInstantKillMonitor()
    if self.instantKillMonitorThread then return end
    
    self.instantKillMonitorThread = task.spawn(function()
        while self.isActive and getgenv().InstantKillBoss do
                        if self.currentTarget and self:IsMobAlive(self.currentTarget) then
                local humanoid = self.currentTarget:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local golemId = self.currentTarget:GetFullName()
                    
                                        if humanoid.Health <= 19000 and humanoid.Health > 0 and not self.instantKilledGolems[golemId] then
                                                self.instantKilledGolems[golemId] = true
                        
                                                local success = TeleportGolemToKillZone(self.currentTarget)
                        
                        if success then
                                                        local golemRef = self.currentTarget
                            task.delay(5, function()
                                if golemRef and golemRef.Parent then
                                    local hum = golemRef:FindFirstChildOfClass("Humanoid")
                                    if hum and hum.Health > 0 then
                                                                                TeleportGolemToKillZone(golemRef)
                                    end
                                end
                            end)
                        end
                    end
                end
            end
            task.wait(0.1)         end
        self.instantKillMonitorThread = nil
    end)
end

function BossController:StopInstantKillMonitor()
    if self.instantKillMonitorThread then
        pcall(task.cancel, self.instantKillMonitorThread)
        self.instantKillMonitorThread = nil
    end
    self.instantKilledGolems = {} end

function BossController:SetupFly(hrp)
    self:CleanupFly()
    
    self.bodyVelocity = Instance.new("BodyVelocity")
    self.bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    self.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    self.bodyVelocity.Parent = hrp
    
    self.bodyGyro = Instance.new("BodyGyro")
    self.bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    self.bodyGyro.P = 10000
    self.bodyGyro.D = 100
    self.bodyGyro.Parent = hrp
end

function BossController:CleanupFly()
    pcall(function() if self.bodyVelocity and self.bodyVelocity.Parent then self.bodyVelocity:Destroy() end end)
    pcall(function() if self.bodyGyro and self.bodyGyro.Parent then self.bodyGyro:Destroy() end end)
    self.bodyVelocity = nil
    self.bodyGyro = nil
    
    pcall(function()
        local char = LocalPlayer.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        if humanoid then humanoid.PlatformStand = false end
    end)
end

function BossController:GetClosestGolem()
    local Living = workspace:FindFirstChild("Living")
    if not Living then return nil end
    
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local bestMob, bestDistance = nil, math.huge
    
    for _, mob in pairs(Living:GetChildren()) do
                local baseName = mob.Name:gsub("%d+$", "")         if mob:IsA("Model") and baseName == "Golem" then
            local mobHRP = mob:FindFirstChild("HumanoidRootPart") or mob:FindFirstChild("Torso") or mob.PrimaryPart
            local humanoid = mob:FindFirstChildOfClass("Humanoid")
            
            if mobHRP and humanoid and humanoid.Health > 0 then
                local distance = (hrp.Position - mobHRP.Position).Magnitude
                if distance < bestDistance then
                    bestDistance = distance
                    bestMob = mob
                end
            end
        end
    end
    
    return bestMob
end

function BossController:IsMobAlive(mob)
    if not mob or not mob.Parent then return false end
    local humanoid = mob:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.Health > 0
end

function BossController:IsAnyGolemUsingSkill()
    local Living = workspace:FindFirstChild("Living")
    if not Living then return false end
    
    for _, mob in pairs(Living:GetChildren()) do
        local baseName = mob.Name:gsub("%d+$", "")
        if mob:IsA("Model") and baseName == "Golem" then
            local status = mob:FindFirstChild("Status")
            if status then
                local usingSkill = status:FindFirstChild("UsingSkill")
                if usingSkill and usingSkill:IsA("BoolValue") and usingSkill.Value == true then
                    return true
                end
            end
        end
    end
    return false
end

function BossController:SetNoClip(enabled)
    if self.noClipConnection then
        self.noClipConnection:Disconnect()
        self.noClipConnection = nil
    end
    
    if enabled then
        self.noClipConnection = RunService.Stepped:Connect(function()
            local char = LocalPlayer.Character
            if char then
                for _, part in pairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then part.CanCollide = false end
                end
            end
        end)
    end
end

function BossController:StartKillLoop()
    if self.killConnection then self.killConnection:Disconnect() end
    
    self.isKilling = true
    self.dodgeDirection = 1     self.dodgeDistance = 15
    self.lastDodgeSwitch = 0
    self.dodgeSwitchInterval = 2     
        if getgenv().InstantKillBoss then
        self:StartInstantKillMonitor()
    end
    
    self.killConnection = RunService.Heartbeat:Connect(function()
        if not self.isKilling then
            self.currentTarget = nil
            self:CleanupFly()
            return
        end
        
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        
                if not self:IsMobAlive(self.currentTarget) then
            self.currentTarget = self:GetClosestGolem()
            if not self.currentTarget then
                if self.bodyVelocity then self.bodyVelocity.Velocity = Vector3.new(0, 0, 0) end
                return
            end
        end
        
        local mobHRP = self.currentTarget:FindFirstChild("HumanoidRootPart") 
            or self.currentTarget:FindFirstChild("Torso") 
            or self.currentTarget.PrimaryPart
        if not mobHRP then self.currentTarget = nil return end
        
                if not self.bodyVelocity or not self.bodyVelocity.Parent then
            self:SetupFly(hrp)
            if humanoid then humanoid.PlatformStand = true end
        end
        
                local isSkillActive = self.avoidSkills and self:IsAnyGolemUsingSkill()
        
        if isSkillActive then
                        local now = tick()
            if now - self.lastDodgeSwitch >= self.dodgeSwitchInterval then
                self.dodgeDirection = -self.dodgeDirection                 self.lastDodgeSwitch = now
            end
            
                        local mobCFrame = mobHRP.CFrame
            local dodgeOffset = mobCFrame.RightVector * (self.dodgeDistance * self.dodgeDirection)
            local dodgePosition = hrp.Position + dodgeOffset
            
                        local direction = (dodgePosition - hrp.Position)
            if direction.Magnitude > 1 then
                self.bodyVelocity.Velocity = direction.Unit * self.flySpeed
            else
                                self.dodgeDirection = -self.dodgeDirection
                self.lastDodgeSwitch = tick()
            end
            self.bodyGyro.CFrame = CFrame.new(hrp.Position, mobHRP.Position)
        else
                                    local targetPosition = (mobHRP.CFrame * CFrame.new(0, -self.depthOffset, -self.attackDistance)).Position
            
                        local direction = (targetPosition - hrp.Position)
            if direction.Magnitude > 1 then
                self.bodyVelocity.Velocity = direction.Unit * self.flySpeed
            else
                self.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
            self.bodyGyro.CFrame = CFrame.new(hrp.Position, mobHRP.Position)
        end
        
                local now = tick()
        if now - self.lastAttackTime >= 0.3 then
            self.lastAttackTime = now
            pcall(function()
                if self.attackRemote then self.attackRemote:InvokeServer("Weapon") end
            end)
        end
    end)
end

function BossController:StopKillLoop()
    self.isKilling = false
    if self.killConnection then self.killConnection:Disconnect() self.killConnection = nil end
    self:CleanupFly()
    self.currentTarget = nil
    self:StopInstantKillMonitor()
end

function BossController:AreGolemsAlive()
    local Living = workspace:FindFirstChild("Living")
    if not Living then return false end
    
    for _, mob in pairs(Living:GetChildren()) do
        local baseName = mob.Name:gsub("%d+$", "")
        if mob:IsA("Model") and baseName == "Golem" then
            local humanoid = mob:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                return true
            end
        end
    end
    return false
end

function BossController:FlyTo(targetPos, maxTime)
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
    if not hrp then return false end
    
    self:SetupFly(hrp)
    self:SetNoClip(true)
    if humanoid then humanoid.PlatformStand = true end
    
    local startTime = tick()
    
    while self.isActive and tick() - startTime < maxTime do
        local currentHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not currentHRP then break end
        
        local direction = (targetPos - currentHRP.Position)
        local distance = direction.Magnitude
        
        if distance < 5 then break end
        
        self.bodyVelocity.Velocity = direction.Unit * self.flySpeed
        self.bodyGyro.CFrame = CFrame.new(currentHRP.Position, targetPos)
        task.wait()
    end
    
    if self.bodyVelocity then self.bodyVelocity.Velocity = Vector3.new(0, 0, 0) end
    self:CleanupFly()
    self:SetNoClip(false)
    if humanoid then humanoid.PlatformStand = false end
    
    task.wait(0.5)
    return true
end

function BossController:SpawnGolems()
    if not self.isActive then return end
    
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
        local createPartyPart = workspace:FindFirstChild("Proximity") and workspace.Proximity:FindFirstChild("CreateParty")
    if not createPartyPart then
        WindUI:Notify({Title = "Error", Content = "CreateParty location not found!", Duration = 3, Icon = "x"})
        return
    end
    
    WindUI:Notify({Title = "Flying to Party Creation", Content = "Moving to CreateParty location...", Duration = 3, Icon = "navigation"})
    
        self:FlyTo(createPartyPart.Position, 120)
    
    if not self.isActive then return end
    
        char = LocalPlayer.Character
    hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    WindUI:Notify({Title = "Spamming Parties", Content = "Spamming " .. self.spamCount .. " parties...", Duration = 3, Icon = "zap"})
    
        local originalFpsCap = getfpscap and getfpscap() or 60
    if setfpscap then setfpscap(1) end
    
        pcall(function()
        local PartyService = ReplicatedStorage.Shared.Packages.Knit.Services.PartyService
        local CreateParty = PartyService.RF.CreateParty
        local Activate = PartyService.RF.Activate
        
        for i = 1, self.spamCount do
            coroutine.wrap(function() CreateParty:InvokeServer("Golem") end)()
            coroutine.wrap(function() Activate:InvokeServer() end)()
        end
    end)
    
        task.wait(2)
    
        if setfpscap then setfpscap(originalFpsCap) end
    
        local golemsSpawned = false
    for checkAttempt = 1, 5 do
        task.wait(1)
        if not self.isActive then return end
        
        if self:AreGolemsAlive() then
            golemsSpawned = true
            break
        end
    end
    
        if not golemsSpawned then
                WindUI:Notify({Title = "No Golems Spawned", Content = "Waiting 5 minutes before retrying...", Duration = 5, Icon = "clock"})
        
                local waitStart = tick()
        while self.isActive and tick() - waitStart < 300 do
            task.wait(1)
        end
        
        if not self.isActive then return end
        
        WindUI:Notify({Title = "Retrying", Content = "5 minutes passed, attempting to spawn Golems again...", Duration = 3, Icon = "refresh-cw"})
        return     end
    
        WindUI:Notify({Title = "Golems Spawned!", Content = "Starting to fight...", Duration = 3, Icon = "sword"})
end

function BossController:MainLoop()
    while self.isActive do
                if self:AreGolemsAlive() then
                        WindUI:Notify({Title = "Golems Found!", Content = "Starting to kill...", Duration = 3, Icon = "sword"})
            
            self:SetNoClip(true)
            self:StartKillLoop()
            print("kill loop started we now will wait till all golems is dead and health is 0")
                        while self.isActive and self:AreGolemsAlive() do
                task.wait(0.5)
            end
            
            print("extra wait")

                        task.wait(1)
                        print("after the wait")
                        if self:AreGolemsAlive() then
                continue
            end
                        print("stopping kill loop")
                        self:StopKillLoop()
            self:SetNoClip(false)
            
            if not self.isActive then break end
            
            WindUI:Notify({Title = "All Dead!", Content = "Resetting...", Duration = 3, Icon = "check"})
            
                        local char = LocalPlayer.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.Anchored = true
            end
            
                        pcall(function()
                local resetRemote = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("CharacterService"):WaitForChild("RF"):WaitForChild("Reset")
                resetRemote:InvokeServer()
            end)
            
                        task.wait(5)
            
                        pcall(function()
                local newChar = LocalPlayer.Character
                local newHrp = newChar and newChar:FindFirstChild("HumanoidRootPart")
                if newHrp then
                    newHrp.Anchored = false
                end
            end)
            
                        local createPartyPart = workspace:FindFirstChild("Proximity") and workspace.Proximity:FindFirstChild("CreateParty")
            if createPartyPart then
                self:FlyTo(createPartyPart.Position, 15)
            end
                        print("flying back")
        else
                        self:SpawnGolems()
        end
        
        if not self.isActive then break end
        task.wait(0.5)
    end
end

function BossController:Start()
    if self.isActive then
        return
    end
    
    self.isActive = true
    
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then
        self.isActive = false
        return
    end
    
        local createPartyPart = workspace:FindFirstChild("Proximity") and workspace.Proximity:FindFirstChild("CreateParty")
    if not createPartyPart then
        WindUI:Notify({Title = "Error", Content = "CreateParty location not found!", Duration = 3, Icon = "x"})
        self.isActive = false
        return
    end
    
    WindUI:Notify({Title = "Boss Auto Started", Content = "Starting Golem farming loop...", Duration = 3, Icon = "crown"})
    
        task.spawn(function()
        self:MainLoop()
    end)
end

function BossController:Stop()
    self.isActive = false
    self:StopKillLoop()
    self:SetNoClip(false)
    
    local char = LocalPlayer.Character
    if char then
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then hrp.Anchored = false end
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then humanoid.PlatformStand = false end
    end
    
    WindUI:Notify({Title = "Boss Auto Stopped", Content = "Stopped boss spam/killing", Duration = 2, Icon = "square"})
end

LocalPlayer.CharacterAdded:Connect(function(character)
        local wasKilling = BossController.isKilling
    
    if wasKilling then
                BossController:StopKillLoop()
        BossController:SetNoClip(false)
        
                character:WaitForChild("HumanoidRootPart", 5)
        character:WaitForChild("Humanoid", 5)
        task.wait(1)
        
                if BossController.isActive then
            BossController:SetNoClip(true)
            BossController:StartKillLoop()
        end
    end
end)

getgenv().Controllers.BossController = BossController

BossesTab:Section({
    Title = "Golem Boss Auto (Separate Controller)",
    Icon = "crown",
})

BossesTab:Paragraph({
    Title = "How It Works",
    Desc = "1. Enable the Auto boss down there and that's all.",
})

BossesTab:Slider({
    Title = "Depth Offset",
    Desc = "How deep to fly underground",
    Step = 1,
    Flag = "GolemDepthOffset",
    Value = {
        Min = 2,
        Max = 8,
        Default = 2,
    },
    Callback = function(value)
        BossController.depthOffset = value
    end
})

BossesTab:Toggle({
    Title = "Avoid Skills",
    Desc = "Enable this if u are shit ass noob bitch no armor",
    Value = false,
    Flag = "GolemAvoidSkills",
    Callback = function(state)
        BossController.avoidSkills = state
    end
})


BossesTab:Toggle({
    Title = "Instant Kill Golem",
    Desc = "Waits until 21.5k HP then kills the golem instantly.",
    Value = false,
    Flag = "InstantKillBoss",
    Callback = function(state)
        getgenv().InstantKillBoss = state

        -- prevent multiple watchers
        BossController._instantKillWatcher = BossController._instantKillWatcher or false

        if state then
            if BossController._instantKillWatcher then return end
            BossController._instantKillWatcher = true

            task.spawn(function()
                local Players = game:GetService("Players")
                local Workspace = game:GetService("Workspace")
                local RunService = game:GetService("RunService")

                local Client = Players.LocalPlayer
                local Mobs = Workspace:WaitForChild("Living")

                local cache = {}

                --// Kill logic (unchanged)
                local function TryKill(mob)
                    if not mob then return end
                    local root = mob:FindFirstChild("HumanoidRootPart")
                    local hum = mob:FindFirstChild("Humanoid")
                    if not root or not hum then return end

                    task.spawn(function()
                        local char = Client.Character
                        local hrp = char and char:FindFirstChild("HumanoidRootPart")

                        local attempts = 0
                        while hrp and (hrp.Position - root.Position).Magnitude > 100 and attempts < 50 do
                            task.wait(0.1)
                            attempts += 1
                            hrp = Client.Character and Client.Character:FindFirstChild("HumanoidRootPart")
                        end

                        for i = 1, 15 do
                            if not mob or not mob.Parent or hum.Health <= 0 then break end
                            pcall(root.SetNetworkOwner, root, Client)
                            hum.Health = 0
                            RunService.Heartbeat:Wait()
                        end

                        task.wait(0.2)
                        if mob and mob.Parent and hum.Health > 0 then
                            cache[mob] = nil
                        end
                    end)
                end

                --// WAIT until boss fight actually starts
                while getgenv().InstantKillBoss and not BossController.isKilling do
                    task.wait(0.1)
                end

                --// MAIN LOOP
                while getgenv().InstantKillBoss and BossController.isKilling do
                    for _, v in ipairs(Mobs:GetChildren()) do
                        if v.Name:match("^Golem") and not cache[v] then
                            local hum = v:FindFirstChild("Humanoid")
                            if hum and hum.Health > 0 and hum.Health <= 21500 then
                                cache[v] = true
                                TryKill(v)
                            end
                        end
                    end
                    task.wait(0.1)
                end

                -- cleanup
                BossController._instantKillWatcher = false
                table.clear(cache)
            end)
        else
            -- FULL STOP
            getgenv().InstantKillBoss = false
            BossController._instantKillWatcher = false
        end
    end
})



BossesTab:Divider()

local BossUI = {}

local function CountGolems()
    local count = 0
    local Living = workspace:FindFirstChild("Living")
    if Living then
        for _, mob in pairs(Living:GetChildren()) do
            local baseName = mob.Name:gsub("%d+$", "")
            if mob:IsA("Model") and baseName == "Golem" then
                local humanoid = mob:FindFirstChildOfClass("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    count = count + 1
                end
            end
        end
    end
    return count
end

BossUI.GolemCountParagraph = BossesTab:Paragraph({
    Title = "Golems in World",
    Desc = "Count: 0 (enable Auto Boss to start tracking)",
})

BossesTab:Toggle({
    Title = "Start Boss Killing Auto",
    Desc = "Spam parties → Reset character → Kill all Golems (separate controller)",
    Value = false,
    Flag = "GolemBossAuto",
    Callback = function(state)
        if state then
            BossController:Start()
                        task.spawn(function()
                while BossController.isActive do
                    local count = CountGolems()
                    pcall(function()
                        BossUI.GolemCountParagraph:SetDesc("Count: " .. count .. " Golem(s) alive")
                    end)
                    task.wait(5)
                end
                                pcall(function()
                    BossUI.GolemCountParagraph:SetDesc("Count: 0 (enable Auto Boss to start tracking)")
                end)
            end)
        else
            BossController:Stop()
        end
    end
})

local QuestsTab = Window:Tab({
    Title = "Quests",
    Icon = "scroll-text",
})

local GameQuestData = nil
pcall(function()
    GameQuestData = Helpers.SafeRequire(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Data"):WaitForChild("Quests"))
end)

local QuestPlayerController = nil
local QuestKnit = nil

pcall(function()
    QuestKnit = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"))
    QuestPlayerController = QuestKnit.GetController("PlayerController")
end)

Helpers.GetActiveQuests = function()
    if QuestPlayerController and QuestPlayerController.Replica and QuestPlayerController.Replica.Data then
        return QuestPlayerController.Replica.Data.Quests or {}
    end
    return {}
end

Helpers.GetQuestName = function(questId)
    if GameQuestData and GameQuestData[questId] and GameQuestData[questId].Name then
        return GameQuestData[questId].Name
    end
    return questId end

Helpers.IsQuestComplete = function(questId)
    local activeQuests = Helpers.GetActiveQuests()
    if not activeQuests[questId] then return false end
    
    local progress = activeQuests[questId].Progress
    if not progress then return false end
    
    for _, obj in pairs(progress) do
        local current = obj.currentProgress or 0
        local required = obj.requiredAmount or 1
        if current < required then
            return false
        end
    end
    return true
end

Helpers.GetQuestObjectives = function(questId)
    local activeQuests = Helpers.GetActiveQuests()
    if not activeQuests[questId] then return {} end
    return activeQuests[questId].Progress or {}
end

Helpers.AreAutoObjectivesDone = function(questId)
    local objectives = Helpers.GetQuestObjectives(questId)
    local hasAutoObjective = false
    
    for _, obj in pairs(objectives) do
        local questType = obj.questType
                if questType == "Kill" or questType == "Mine" or questType == "Collect" then
            hasAutoObjective = true
            local current = obj.currentProgress or 0
            local required = obj.requiredAmount or 1
            if current < required then
                return false             end
        end
    end
    
        return true
end

Helpers.ParseQuestTargets = function(questId)
    local objectives = Helpers.GetQuestObjectives(questId)
    local result = {
        killTargets = {},
        mineTargets = {},          collectTargets = {},         hasKill = false,
        hasMine = false,
        hasCollect = false,
    }
    
    for _, obj in pairs(objectives) do
        local current = obj.currentProgress or 0
        local required = obj.requiredAmount or 1
        
                if current < required then
            local questType = obj.questType
            local target = obj.target
            
            if questType == "Kill" then
                result.hasKill = true
                table.insert(result.killTargets, target)
            elseif questType == "Mine" then
                result.hasMine = true
                table.insert(result.mineTargets, target)
            elseif questType == "Collect" then
                result.hasCollect = true
                table.insert(result.collectTargets, target)
            end
        end
    end
    
    return result
end

local function BuildActiveQuestList()
    local questList = {}
    local activeQuests = Helpers.GetActiveQuests()
    
    for questId, questInfo in pairs(activeQuests) do
        local name = Helpers.GetQuestName(questId)
        
                local completed, total = 0, 0
        if questInfo.Progress then
            for _, obj in pairs(questInfo.Progress) do
                total = total + 1
                local current = obj.currentProgress or 0
                local required = obj.requiredAmount or 1
                if current >= required then
                    completed = completed + 1
                end
            end
        end
        
        local displayName = name .. " (" .. completed .. "/" .. total .. ")"
        
        table.insert(questList, {
            Title = displayName,
            Id = questId,
            Name = name,
            Completed = completed,
            Total = total,
        })
    end
    
        table.sort(questList, function(a, b) return a.Name < b.Name end)
    
    return questList
end

local QuestsUI = {}

local function StartAutoQuest(toggleElement)
    if Threads.autoQuest then return end
    
    Threads.autoQuest = task.spawn(function()
        while getgenv().AutoQuest do
            local selectedQuestIds = getgenv().SelectedQuestIds or {}
            
            if #selectedQuestIds == 0 then
                task.wait(2)
                continue
            end
            
                                    local currentQuestId = nil
            for _, questId in ipairs(selectedQuestIds) do
                if not Helpers.AreAutoObjectivesDone(questId) then
                    currentQuestId = questId
                    break
                end
            end
            
            if not currentQuestId then
                                                local hasManualLeft = false
                for _, questId in ipairs(selectedQuestIds) do
                    if not Helpers.IsQuestComplete(questId) then
                        hasManualLeft = true
                        break
                    end
                end
                
                if hasManualLeft then
                    WindUI:Notify({
                        Title = "Auto Objectives Done!",
                        Content = "Manual objectives remain (Forge/Talk/Equip)",
                        Duration = 5,
                        Icon = "info",
                    })
                else
                    WindUI:Notify({
                        Title = "Quests Complete!",
                        Content = "All selected quests have been completed",
                        Duration = 5,
                        Icon = "check-circle",
                    })
                end
                                getgenv().AutoMob = false
                getgenv().AutoMine = false
                getgenv().NoClipEnabled = false
                getgenv().AutoQuest = false
                if toggleElement then toggleElement:Set(false) end
                break
            end
            
                        local targets = Helpers.ParseQuestTargets(currentQuestId)
            local questName = Helpers.GetQuestName(currentQuestId)
            
                        if QuestsUI.progressParagraph then
                local progressText = "Quest: " .. questName .. "\n"
                if targets.hasKill then
                    progressText = progressText .. "Kill: " .. table.concat(targets.killTargets, ", ") .. "\n"
                end
                if targets.hasMine then
                    progressText = progressText .. "Mine: " .. table.concat(targets.mineTargets, ", ") .. "\n"
                end
                if targets.hasCollect then
                    progressText = progressText .. "Collect: " .. table.concat(targets.collectTargets, ", ")
                end
                QuestsUI.progressParagraph:SetDesc(progressText)
            end
            
                        if targets.hasKill and getgenv().QuestEnableKilling then
                local validKillTargets = {}
                
                                                local Living = workspace:FindFirstChild("Living")
                for _, target in ipairs(targets.killTargets) do
                    local mobExists = false
                    if Living then
                        for _, entity in pairs(Living:GetDescendants()) do
                            if entity:IsA("Model") then
                                                                local entityBaseName = entity.Name:gsub("%d+$", "")
                                if entityBaseName == target then
                                    local humanoid = entity:FindFirstChildOfClass("Humanoid")
                                    if humanoid and humanoid.Health > 0 then
                                        mobExists = true
                                        break
                                    end
                                end
                            end
                        end
                    end
                    if mobExists then
                        table.insert(validKillTargets, target)
                    end
                end
                
                if #validKillTargets > 0 then
                                        local needsUpdate = false
                    local currentMobs = getgenv().SelectedMobs or {}
                    
                    if #currentMobs ~= #validKillTargets then
                        needsUpdate = true
                    else
                        for _, target in ipairs(validKillTargets) do
                            if not Helpers.IsSelected(target, currentMobs) then
                                needsUpdate = true
                                break
                            end
                        end
                    end
                    
                    if needsUpdate then
                        getgenv().SelectedMobs = validKillTargets
                        WindUI:Notify({
                            Title = "Quest: Kill",
                            Content = "Hunting: " .. table.concat(validKillTargets, ", "),
                            Duration = 3,
                            Icon = "sword",
                        })
                    end
                    
                    if not getgenv().AutoMob then
                        getgenv().AutoMob = true
                        getgenv().NoClipEnabled = true
                    end
                elseif getgenv().QuestKillFallback == "Kill Anything" then
                                        if not getgenv().AutoMob then
                        getgenv().SelectedMobs = MobList                         getgenv().AutoMob = true
                        getgenv().NoClipEnabled = true
                        WindUI:Notify({
                            Title = "Quest Fallback",
                            Content = "Killing any mob (target not found)",
                            Duration = 3,
                            Icon = "alert-triangle",
                        })
                    end
                end
            elseif not targets.hasKill then
                                if getgenv().AutoMob then
                    getgenv().AutoMob = false
                    WindUI:Notify({
                        Title = "Quest: Kill Done",
                        Content = "Stopping mob hunting",
                        Duration = 2,
                        Icon = "check",
                    })
                end
            end
            
                        if targets.hasMine and getgenv().QuestEnableMining then
                local validMineTargets = {}
                
                                local RocksFolder = workspace:FindFirstChild("Rocks")
                for _, target in ipairs(targets.mineTargets) do
                    local rockExists = false
                    if RocksFolder then
                        for _, areaFolder in pairs(RocksFolder:GetChildren()) do
                            if areaFolder:IsA("Folder") then
                                for _, rock in pairs(areaFolder:GetDescendants()) do
                                    if rock:IsA("Model") and rock.Name == target then
                                        rockExists = true
                                        break
                                    end
                                end
                            end
                            if rockExists then break end
                        end
                    end
                    if rockExists then
                        table.insert(validMineTargets, target)
                    end
                end
                
                if #validMineTargets > 0 then
                    getgenv().MineMode = "Rocks"
                    getgenv().SelectedRocks = validMineTargets
                    
                    if not getgenv().AutoMine then
                        getgenv().AutoMine = true
                        getgenv().NoClipEnabled = true
                        WindUI:Notify({
                            Title = "Quest: Mine",
                            Content = "Mining: " .. table.concat(validMineTargets, ", "),
                            Duration = 3,
                            Icon = "pickaxe",
                        })
                    end
                elseif getgenv().QuestMineFallback == "Mine Anything" then
                                        getgenv().MineMode = "Rocks"
                    getgenv().SelectedRocks = RockList
                    if not getgenv().AutoMine then
                        getgenv().AutoMine = true
                        getgenv().NoClipEnabled = true
                        WindUI:Notify({
                            Title = "Quest Fallback",
                            Content = "Mining any rock (target not found)",
                            Duration = 3,
                            Icon = "alert-triangle",
                        })
                    end
                end
            end
            
                        if targets.hasCollect and getgenv().QuestEnableMining then
                local validCollectTargets = {}
                
                                local RocksFolder = workspace:FindFirstChild("Rocks")
                for _, target in ipairs(targets.collectTargets) do
                    local oreAvailable = false
                                        local rocksForOre = Helpers.GetRocksForOre(target)
                    if #rocksForOre > 0 and RocksFolder then
                        for _, rockName in ipairs(rocksForOre) do
                            for _, areaFolder in pairs(RocksFolder:GetChildren()) do
                                if areaFolder:IsA("Folder") then
                                    for _, rock in pairs(areaFolder:GetDescendants()) do
                                        if rock:IsA("Model") and rock.Name == rockName then
                                            oreAvailable = true
                                            break
                                        end
                                    end
                                end
                                if oreAvailable then break end
                            end
                            if oreAvailable then break end
                        end
                    end
                    if oreAvailable then
                        table.insert(validCollectTargets, target)
                    end
                end
                
                if #validCollectTargets > 0 then
                                        getgenv().MineMode = "Ores"
                    getgenv().SelectedOres = validCollectTargets
                    
                    if not getgenv().AutoMine then
                        getgenv().AutoMine = true
                        getgenv().NoClipEnabled = true
                        WindUI:Notify({
                            Title = "Quest: Collect",
                            Content = "Collecting: " .. table.concat(validCollectTargets, ", "),
                            Duration = 3,
                            Icon = "gem",
                        })
                    end
                elseif getgenv().QuestMineFallback == "Mine Anything" then
                                        getgenv().MineMode = "Rocks"
                    getgenv().SelectedRocks = RockList
                    if not getgenv().AutoMine then
                        getgenv().AutoMine = true
                        getgenv().NoClipEnabled = true
                        WindUI:Notify({
                            Title = "Quest Fallback",
                            Content = "Mining any rock for ores",
                            Duration = 3,
                            Icon = "alert-triangle",
                        })
                    end
                end
            end
            
                        if not targets.hasMine and not targets.hasCollect then
                if getgenv().AutoMine then
                    getgenv().AutoMine = false
                    WindUI:Notify({
                        Title = "Quest: Mine Done",
                        Content = "Stopping mining",
                        Duration = 2,
                        Icon = "check",
                    })
                end
            end
            
                        if not targets.hasKill and not targets.hasMine and not targets.hasCollect then
                if QuestsUI.progressParagraph then
                    QuestsUI.progressParagraph:SetDesc("Quest: " .. questName .. "\nNo auto-completable objectives (Talk/Forge/Equip)")
                end
            end
            
            task.wait(2)         end
        
            end)
end

local function StopAutoQuest()
    if Threads.autoQuest then
        task.cancel(Threads.autoQuest)
        Threads.autoQuest = nil
    end
        getgenv().AutoMob = false
    getgenv().AutoMine = false
    getgenv().NoClipEnabled = false
end

QuestsTab:Section({
    Title = "Active Quests",
    Icon = "list",
})

QuestsUI.questDropdown = QuestsTab:Dropdown({
    Title = "Select Quests",
    Desc = "Choose quests to auto-complete (queue order)",
    Multi = true,
    AllowNone = true,
    Flag = "SelectedQuests",
    Values = BuildActiveQuestList(),
    Callback = function(options)
                local questIds = {}
        for _, option in pairs(options) do
            if type(option) == "table" and option.Id then
                table.insert(questIds, option.Id)
            elseif type(option) == "string" then
                                local activeQuests = Helpers.GetActiveQuests()
                for questId, _ in pairs(activeQuests) do
                    local name = Helpers.GetQuestName(questId)
                    if string.find(option, name) then
                        table.insert(questIds, questId)
                        break
                    end
                end
            end
        end
        getgenv().SelectedQuestIds = questIds
    end
})

QuestsTab:Button({
    Title = "Refresh Quest List",
    Desc = "Update list of active quests",
    Icon = "refresh-cw",
    Callback = function()
        local newList = BuildActiveQuestList()
        QuestsUI.questDropdown:Refresh(newList)
        WindUI:Notify({
            Title = "Quests",
            Content = "Found " .. #newList .. " active quests",
            Duration = 2,
            Icon = "refresh-cw",
        })
    end
})

QuestsUI.progressParagraph = QuestsTab:Paragraph({
    Title = "Current Progress",
    Desc = "Select quests and enable Auto Quest to see progress",
})

QuestsTab:Divider()

QuestsTab:Section({
    Title = "Fallback Options",
    Icon = "settings",
})

QuestsTab:Dropdown({
    Title = "Kill Fallback",
    Desc = "What to do when quest mob not found in game",
    Multi = false,
    Flag = "QuestKillFallback",
    Value = "Wait",
    Values = {"Wait", "Kill Anything"},
    Callback = function(value)
        getgenv().QuestKillFallback = value
    end
})

QuestsTab:Dropdown({
    Title = "Mine/Collect Fallback",
    Desc = "What to do when quest rock/ore not found",
    Multi = false,
    Flag = "QuestMineFallback",
    Value = "Wait",
    Values = {"Wait", "Mine Anything"},
    Callback = function(value)
        getgenv().QuestMineFallback = value
    end
})

QuestsTab:Toggle({
    Title = "Enable Auto Kill",
    Desc = "Automatically kill mobs for Kill objectives",
    Value = true,
    Flag = "QuestEnableKilling",
    Callback = function(state)
        getgenv().QuestEnableKilling = state
    end
})

QuestsTab:Toggle({
    Title = "Enable Auto Mine",
    Desc = "Automatically mine for Mine/Collect objectives",
    Value = true,
    Flag = "QuestEnableMining",
    Callback = function(state)
        getgenv().QuestEnableMining = state
    end
})

QuestsTab:Divider()

QuestsTab:Section({
    Title = "Auto Quest",
    Icon = "zap",
})

QuestsUI.autoQuestToggle = QuestsTab:Toggle({
    Title = "Auto Quest",
    Desc = "Automatically complete selected quests in queue order",
    Value = false,
    Flag = "AutoQuest",
    Callback = function(state)
        getgenv().AutoQuest = state
        if state then
            StartAutoQuest(QuestsUI.autoQuestToggle)
            WindUI:Notify({
                Title = "Auto Quest Enabled",
                Content = "Processing quest queue...",
                Duration = 3,
                Icon = "scroll-text",
            })
        else
            StopAutoQuest()
            if QuestsUI.progressParagraph then
                QuestsUI.progressParagraph:SetDesc("Auto Quest disabled")
            end
            WindUI:Notify({
                Title = "Auto Quest Disabled",
                Content = "Quest automation stopped",
                Duration = 2,
                Icon = "square",
            })
        end
    end
})

QuestsTab:Paragraph({
    Title = "How It Works",
    Desc = "• Select active quests from the dropdown (multi-select)\n• Quests are completed in queue order\n• Kill objectives → enables Auto Mob\n• Mine objectives → enables Auto Mine (Rocks mode)\n• Collect objectives → enables Auto Mine (Ores mode)\n• Talk/Forge/Equip must be done manually\n• Game auto-claims rewards when completed",
})

QuestsTab:Divider()

QuestsTab:Paragraph({
    Title = "⚙️ Quest Settings",
    Desc = "Auto Quest uses settings from Mobs and Mine tabs:\n\n• Attack Distance/Depth → Configure in Mobs tab\n• Mine Distance/Depth → Configure in Mine tab\n• Defend While Mining → Enable in Mine tab to kill mobs during mining objectives",
})

local MineTab = Window:Tab({
    Title = "Mine",
    Icon = "pickaxe",
})

MineTab:Section({
    Title = "Mining Mode",
    Icon = "settings",
})

local MineUI = {}

MineTab:Dropdown({
    Title = "Mining Mode",
    Desc = "Mine by rock type or by desired ore drops",
    Multi = false,
    Flag = "MineMode",
    Value = "Rocks",
    Values = {"Rocks", "Ores"},
    Callback = function(value)
        getgenv().MineMode = value
        if value == "Rocks" then
            WindUI:Notify({
                Title = "Mining Mode: Rocks",
                Content = "Mining specific rock types",
                Duration = 2,
                Icon = "mountain",
            })
                        if MineUI.OreSkipperToggle then
                MineUI.OreSkipperToggle:Lock()
                MineUI.OreSkipperToggle:Set(false)
                getgenv().OreSkipperEnabled = false
            end
            if MineUI.SelectOresDropdown then MineUI.SelectOresDropdown:Lock() end
            if MineUI.SelectRocksDropdown then MineUI.SelectRocksDropdown:Unlock() end
            if MineUI.NoRocksFallbackDropdown then MineUI.NoRocksFallbackDropdown:Lock() end
                        getgenv().NoDesiredRocksAvailable = false
        else
            WindUI:Notify({
                Title = "Mining Mode: Ores",
                Content = "Mining rocks that drop selected ores",
                Duration = 2,
                Icon = "gem",
            })
                        if MineUI.OreSkipperToggle then MineUI.OreSkipperToggle:Unlock() end
            if MineUI.SelectOresDropdown then MineUI.SelectOresDropdown:Unlock() end
            if MineUI.SelectRocksDropdown then MineUI.SelectRocksDropdown:Lock() end
            if MineUI.NoRocksFallbackDropdown then MineUI.NoRocksFallbackDropdown:Unlock() end
        end
    end
})

MineTab:Divider()

MineTab:Section({
    Title = "Rock Selection",
    Icon = "mountain",
})

MineUI.SelectRocksDropdown = MineTab:Dropdown({
    Title = "Select Rocks",
    Desc = "Choose which rocks to mine (used in Rocks mode)",
    Multi = true,
    Flag = "SelectedRocks",
    Values = RockList,
    Callback = function(options)
        getgenv().SelectedRocks = options
                if getgenv().SpecificPriority and getgenv().MineMode == "Rocks" then
            task.spawn(function()
                task.wait(0.1)                 if MineUI.UpdatePriorityInputs then
                    MineUI.UpdatePriorityInputs()
                end
            end)
        end
    end
})

MineTab:Divider()

MineTab:Section({
    Title = "Ore Selection",
    Icon = "gem",
})

MineUI.SelectOresDropdown = MineTab:Dropdown({
    Title = "Select Ores",
    Desc = "Choose desired ores - will mine rocks that drop these (used in Ores mode)",
    Multi = true,
    Flag = "SelectedOres",
    Values = MiningOreList,
    Callback = function(options)
        getgenv().SelectedOres = options
                if getgenv().SpecificPriority and getgenv().MineMode == "Ores" then
            task.spawn(function()
                task.wait(0.1)                 if MineUI.UpdatePriorityInputs then
                    MineUI.UpdatePriorityInputs()
                end
            end)
        end
    end
})
MineUI.SelectOresDropdown:Lock()

MineUI.OreSkipperToggle = MineTab:Toggle({
    Title = "Ore Skipper",
    Desc = "Skip rocks mid-mining if revealed ores don't match your selection",
    Icon = "fast-forward",
    Value = false,
    Flag = "OreSkipperEnabled",
    Callback = function(state)
        getgenv().OreSkipperEnabled = state
        if state then
            WindUI:Notify({
                Title = "Ore Skipper Enabled",
                Content = "Will skip rocks that don't have desired ores",
                Duration = 2,
                Icon = "fast-forward",
            })
        end
    end
})
MineUI.OreSkipperToggle:Lock()

MineUI.NoRocksFallbackDropdown = MineTab:Dropdown({
    Title = "No Rocks Fallback",
    Desc = "What to do when no rocks drop your selected ores",
    Multi = false,
    Flag = "NoRocksFallback",
    Value = "Wait (No Potions)",
    Values = {"Wait (No Potions)", "Mine Any (No Potions)", "Mine Any (With Potions)"},
    Callback = function(value)
        getgenv().NoRocksFallback = value
    end
})
MineUI.NoRocksFallbackDropdown:Lock()

MineTab:Divider()

MineTab:Section({
    Title = "Target Settings",
    Icon = "target",
})

MineTab:Dropdown({
    Title = "Target Priority",
    Desc = "How to choose which rock to mine first",
    Multi = false,
    Flag = "MinePriority",
    Value = "Nearest",
    Values = {"Nearest", "Weakest", "Strongest"},
    Callback = function(value)
        getgenv().MinePriority = value
                if MineUI.SpecificPriorityToggle then
            if value ~= "Nearest" then
                MineUI.SpecificPriorityToggle:Lock()
                MineUI.SpecificPriorityToggle:Set(false)
                getgenv().SpecificPriority = false
            else
                MineUI.SpecificPriorityToggle:Unlock()
            end
        end
    end
})

MineUI.SpecificPriorityToggle = MineTab:Toggle({
    Title = "Specific Priority",
    Desc = "Set custom priority order for each rock/ore (1 = highest)",
    Icon = "list-ordered",
    Value = false,
    Flag = "SpecificPriority",
    Callback = function(state)
        getgenv().SpecificPriority = state
        if MineUI.PrioritySection then
            if state then
                MineUI.PrioritySection:Unlock()
            else
                MineUI.PrioritySection:Lock()
            end
        end
                if state then
            MineUI.UpdatePriorityInputs()
        end
    end
})

MineUI.PriorityInputs = {}

MineUI.UpdatePriorityInputs = function()
        for _, input in pairs(MineUI.PriorityInputs) do
        pcall(function() input:Destroy() end)
    end
    MineUI.PriorityInputs = {}
    
    if not getgenv().SpecificPriority then return end
    
    local mineMode = getgenv().MineMode or "Rocks"
    local items = {}
    
    if mineMode == "Rocks" then
        items = getgenv().SelectedRocks or {}
    else
        items = getgenv().SelectedOres or {}
    end
    
        for i, item in ipairs(items) do
        local itemName = type(item) == "table" and item.Title or item
        local currentPriority = getgenv().PriorityOrder[itemName] or i
        
        local input = MineTab:Input({
            Title = itemName .. " Priority",
            Desc = "Priority order (1 = first, lower = higher priority)",
            Value = tostring(currentPriority),
            Placeholder = "1",
            Callback = function(value)
                local num = tonumber(value)
                if num then
                    getgenv().PriorityOrder[itemName] = num
                end
            end
        })
        
        table.insert(MineUI.PriorityInputs, input)
    end
    
    if #items == 0 then
        WindUI:Notify({
            Title = "No Items Selected",
            Content = "Select rocks or ores first to set priorities",
            Duration = 3,
            Icon = "info",
        })
    end
end

MineTab:Button({
    Title = "Refresh Priority List",
    Desc = "Update priority inputs based on current selection",
    Icon = "refresh-cw",
    Callback = function()
        MineUI.UpdatePriorityInputs()
        WindUI:Notify({
            Title = "Priorities Updated",
            Content = "Priority inputs refreshed",
            Duration = 2,
            Icon = "check",
        })
    end
})

MineTab:Divider()

MineTab:Section({
    Title = "Auto Mine",
    Icon = "hammer",
})

MineTab:Slider({
    Title = "Mine Distance",
    Desc = "Distance to stay from rock",
    Step = 1,
    Flag = "MineDistance",
    Value = {
        Min = 0,
        Max = 5,
        Default = 2,
    },
    Callback = function(value)
        getgenv().MineDistance = value
    end
})

MineTab:Slider({
    Title = "Fly Speed",
    Desc = "Speed to fly towards rocks",
    Step = 1,
    Flag = "MineFlySpeed",
    Value = {
        Min = 15,
        Max = 60,
        Default = 50,
    },
    Callback = function(value)
        getgenv().MineFlySpeed = value
    end
})

MineTab:Slider({
    Title = "Mine Depth",
    Desc = "Vertical offset (-10 = up, 0 = surface, 10 = down)",
    Step = 1,
    Flag = "MineDepthOffset",
    Value = {
        Min = -10,
        Max = 10,
        Default = 0,
    },
    Callback = function(value)
        getgenv().MineDepthOffset = value
    end
})

MineTab:Toggle({
    Title = "Avoid Players",
    Desc = "Skip rocks that have other players nearby",
    Value = false,
    Flag = "AvoidPlayersWhileMining",
    Callback = function(state)
        getgenv().AvoidPlayersWhileMining = state
        if MineUI.PlayerAvoidDistanceSlider then
            if state then
                MineUI.PlayerAvoidDistanceSlider:Unlock()
            else
                MineUI.PlayerAvoidDistanceSlider:Lock()
            end
        end
    end
})

MineUI.PlayerAvoidDistanceSlider = MineTab:Slider({
    Title = "Player Avoid Distance",
    Desc = "How far to check for players around rocks",
    Step = 1,
    Flag = "PlayerAvoidDistance",
    Value = {
        Min = 5,
        Max = 50,
        Default = 10,
    },
    Callback = function(value)
        getgenv().PlayerAvoidDistance = value
    end
})
MineUI.PlayerAvoidDistanceSlider:Lock()

MineTab:Toggle({
    Title = "Defend While Mining",
    Desc = "Kill mobs that attack you while mining",
    Value = false,
    Flag = "DefendWhileMining",
    Callback = function(state)
        getgenv().DefendWhileMining = state
        if MineUI.DefendRangeSlider then
            if state then
                MineUI.DefendRangeSlider:Unlock()
            else
                MineUI.DefendRangeSlider:Lock()
            end
        end
    end
})

MineUI.DefendRangeSlider = MineTab:Slider({
    Title = "Defend Range",
    Desc = "How far to check for attacking mobs",
    Step = 5,
    Flag = "DefendRange",
    Value = {
        Min = 10,
        Max = 50,
        Default = 20,
    },
    Callback = function(value)
        getgenv().DefendRange = value
    end
})
MineUI.DefendRangeSlider:Lock()

MineTab:Divider()

MineTab:Toggle({
    Title = "Filter by Area",
    Desc = "Only mine in selected area folders",
    Value = false,
    Flag = "FilterMineByArea",
    Callback = function(state)
        getgenv().FilterMineByArea = state
        if MineUI.MineAreaDropdown then
            if state then
                MineUI.MineAreaDropdown:Unlock()
            else
                MineUI.MineAreaDropdown:Lock()
            end
        end
    end
})

local function GetMineAreaFolders()
    local areas = {}
    local Rocks = workspace:FindFirstChild("Rocks")
    if Rocks then
        for _, areaFolder in pairs(Rocks:GetChildren()) do
            if areaFolder:IsA("Folder") then
                table.insert(areas, areaFolder.Name)
            end
        end
    end
    table.sort(areas)
    return areas
end

MineUI.MineAreaDropdown = MineTab:Dropdown({
    Title = "Select Mining Areas",
    Desc = "Choose which area folders to mine in",
    Multi = true,
    AllowNone = true,
    Flag = "SelectedMineAreas",
    Values = GetMineAreaFolders(),
    Value = {},
    Callback = function(values)
        getgenv().SelectedMineAreas = values
    end
})
MineUI.MineAreaDropdown:Lock()

MineTab:Button({
    Title = "Refresh Area List",
    Desc = "Update available mining areas",
    Callback = function()
        local newAreas = GetMineAreaFolders()
        MineUI.MineAreaDropdown:Refresh(newAreas)
        WindUI:Notify({
            Title = "Areas Refreshed",
            Content = "Found " .. #newAreas .. " mining areas",
            Duration = 2,
            Icon = "refresh-cw",
        })
    end
})

MineTab:Divider()

MineTab:Toggle({
    Title = "Auto Mine Rocks",
    Desc = "Fly to selected rocks and mine them",
    Value = false,
    Callback = function(state)
        getgenv().AutoMine = state
        getgenv().NoClipEnabled = state         if state then
            WindUI:Notify({
                Title = "Auto Mine Enabled",
                Content = "Mining selected rocks... (No-clip ON)",
                Duration = 2,
                Icon = "pickaxe",
            })
        else
            WindUI:Notify({
                Title = "Auto Mine Disabled",
                Content = "No-clip OFF",
                Duration = 2,
                Icon = "square",
            })
        end
    end
})

local AntiGoblinMineToggle = MineTab:Toggle({
    Title = "Anti-Goblin Village",
    Desc = "Fly up first to avoid Goblin Village teleport zone (Map 2 only)",
    Icon = "shield",
    Value = false,
    Flag = "AntiGoblinVillageMine",
    Callback = function(state)
        getgenv().AntiGoblinVillage = state
        if state then
            WindUI:Notify({
                Title = "Anti-Goblin Village ON",
                Content = "Will fly up " .. getgenv().AntiGoblinHeight .. " studs before moving to targets",
                Duration = 3,
                Icon = "shield",
            })
        end
    end
})

if GetCurrentMapNumber() ~= 2 then
    AntiGoblinMineToggle:Lock()
end

local AvoidLockedAreasMineToggle = MineTab:Toggle({
    Title = "Avoid Locked Areas",
    Desc = "Fly over/around locked cave regions (Map 3 only)",
    Icon = "mountain",
    Value = false,
    Flag = "AvoidLockedAreasMine",
    Callback = function(state)
        getgenv().AvoidLockedAreas = state
        if state then
            WindUI:Notify({
                Title = "Avoid Locked Areas ON",
                Content = "Will fly around locked cave zones",
                Duration = 3,
                Icon = "mountain",
            })
        end
    end
})

if GetCurrentMapNumber() ~= 3 then
    AvoidLockedAreasMineToggle:Lock()
end

local PotionsTab = Window:Tab({
    Title = "Potions",
    Icon = "flask-conical",
})

Helpers.GetProximityService = function()
    local s = ReplicatedStorage:FindFirstChild("Shared")
    return s and s:FindFirstChild("Packages") and s.Packages:FindFirstChild("Knit")
        and s.Packages.Knit:FindFirstChild("Services") and s.Packages.Knit.Services:FindFirstChild("ProximityService")
        and s.Packages.Knit.Services.ProximityService:FindFirstChild("RF")
        and s.Packages.Knit.Services.ProximityService.RF:FindFirstChild("Purchase")
end

Helpers.GetToolService = function()
    local s = ReplicatedStorage:FindFirstChild("Shared")
    return s and s:FindFirstChild("Packages") and s.Packages:FindFirstChild("Knit")
        and s.Packages.Knit:FindFirstChild("Services") and s.Packages.Knit.Services:FindFirstChild("ToolService")
        and s.Packages.Knit.Services.ToolService:FindFirstChild("RF")
        and s.Packages.Knit.Services.ToolService.RF:FindFirstChild("ToolActivated")
end

Helpers.IsPotionEffectActive = function(potionName)
    local hotbar = PlayerGui:FindFirstChild("Hotbar")
    return hotbar and hotbar:FindFirstChild("Perks") and hotbar.Perks:FindFirstChild(potionName) ~= nil
end

Helpers.GetPotionCount = function(potionName)
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        local potion = backpack:FindFirstChild(potionName)
        if potion then return potion:GetAttribute("Count") or 0 end
    end
    return 0
end

Helpers.MAP3_POTION_SHOP_POS = Vector3.new(146.108765, 17.4276791, 48.4276199)

local function FlyToPotionShop()
    local character = LocalPlayer.Character
    if not character then return false end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    local targetPos = nil
    local currentPlaceId = game.PlaceId
    
        if currentPlaceId == getgenv().MAP_PLACE_IDS[3] then
                targetPos = Helpers.MAP3_POTION_SHOP_POS
    else
                local potionShop = workspace:FindFirstChild("Proximity") and workspace.Proximity:FindFirstChild("MinerPotion1")
        if not potionShop then
            warn("[Potions] MinerPotion1 not found in Proximity!")
            return false
        end
        
        local shopHandle = potionShop:FindFirstChild("Handle")
        if not shopHandle then
            warn("[Potions] MinerPotion1.Handle not found!")
            return false
        end
        
        targetPos = shopHandle.Position + Vector3.new(0, 2, 0)
    end
    
        local originalPosition = hrp.Position
    local originalHipHeight = humanoid.HipHeight
    
        local wasNoClipEnabled = getgenv().NoClipEnabled
    getgenv().NoClipEnabled = true
    
        local flyBV = Instance.new("BodyVelocity")
    flyBV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    flyBV.Velocity = Vector3.new(0, 0, 0)
    flyBV.Parent = hrp
    
    local flyBG = Instance.new("BodyGyro")
    flyBG.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    flyBG.P = 10000
    flyBG.D = 100
    flyBG.Parent = hrp
    
    humanoid.PlatformStand = true
    
        local startTime = tick()
    local timeout = 15
    local flySpeed = 70
    
    while (hrp.Position - targetPos).Magnitude > 3 and tick() - startTime < timeout do
                flyBV.Velocity = Helpers.GetSafeFlyVelocity(hrp.Position, targetPos, flySpeed)
        flyBG.CFrame = CFrame.new(hrp.Position, targetPos)
        task.wait()
    end
    
        flyBV.Velocity = Vector3.new(0, 0, 0)
    humanoid.HipHeight = originalHipHeight
    hrp.CFrame = CFrame.new(targetPos)
    
    return {
        success = true,
        originalPosition = originalPosition,
        flyBV = flyBV,
        flyBG = flyBG,
        humanoid = humanoid,
        hrp = hrp,
        wasNoClipEnabled = wasNoClipEnabled
    }
end

local function ReturnFromPotionShop(flyData)
    if not flyData or not flyData.success then return end
    
    local hrp = flyData.hrp
    local humanoid = flyData.humanoid
    local flyBV = flyData.flyBV
    local flyBG = flyData.flyBG
    local originalPosition = flyData.originalPosition
    
    if not hrp or not hrp.Parent then return end
    
    humanoid.PlatformStand = true
    local startTimeBack = tick()
    local timeout = 15
    local flySpeed = 70
    
    while (hrp.Position - originalPosition).Magnitude > 3 and tick() - startTimeBack < timeout do
                flyBV.Velocity = Helpers.GetSafeFlyVelocity(hrp.Position, originalPosition, flySpeed)
        flyBG.CFrame = CFrame.new(hrp.Position, originalPosition)
        task.wait()
    end
    
        flyBV.Velocity = Vector3.new(0, 0, 0)
    hrp.CFrame = CFrame.new(originalPosition)
    
    pcall(function() flyBV:Destroy() end)
    pcall(function() flyBG:Destroy() end)
    humanoid.PlatformStand = false
    
    getgenv().NoClipEnabled = flyData.wasNoClipEnabled
end

local function BuyPotionAtShop(potionName, quantity)
    local purchaseRemote = Helpers.GetProximityService()
    if not purchaseRemote then
        warn("[Potions] Purchase remote not found")
        return false
    end
    
        local currentCount = Helpers.GetPotionCount(potionName)
    local maxBuy = math.min(quantity, 10 - currentCount)
    
    if maxBuy <= 0 then
        return true     end
    
    local success, result = pcall(function()
        return purchaseRemote:InvokeServer(potionName, maxBuy)
    end)
    
    if not success then
        warn("[Potions] Failed to buy " .. potionName .. ": " .. tostring(result))
    end
    
    return success
end

local function BuyMultiplePotionsWithFly(potionsList, quantity)
    if #potionsList == 0 then return 0, 0 end
    
        local wasMining = getgenv().AutoMine
    local wasMobbing = getgenv().AutoMob
    
    if wasMining then getgenv().AutoMine = false end
    if wasMobbing then getgenv().AutoMob = false end
    
    task.wait(0.5)     
        local flyData = FlyToPotionShop()
    
    if not flyData or not flyData.success then
                if wasMining then getgenv().AutoMine = true end
        if wasMobbing then getgenv().AutoMob = true end
        return 0, #potionsList
    end
    
    task.wait(0.3)     
        local bought = 0
    local failed = 0
    
    for _, potionName in pairs(potionsList) do
        if BuyPotionAtShop(potionName, quantity) then
            bought = bought + 1
        else
            failed = failed + 1
        end
        task.wait(0.1)     end
    
    task.wait(0.2)
    
        ReturnFromPotionShop(flyData)
    
        if wasMining then getgenv().AutoMine = true end
    if wasMobbing then getgenv().AutoMob = true end
    
    return bought, failed
end

local function BuyPotionWithFly(potionName, quantity)
    local bought, failed = BuyMultiplePotionsWithFly({potionName}, quantity)
    return bought > 0
end

local function DrinkPotion(potionName)
    local toolRemote = Helpers.GetToolService()
    if not toolRemote then
        warn("[Potions] Tool remote not found")
        return false
    end
    
        local count = Helpers.GetPotionCount(potionName)
    if count <= 0 then
        return false
    end
    
    local success, result = pcall(function()
        return toolRemote:InvokeServer(potionName)
    end)
    
    return success
end

PotionsTab:Section({ Title = "Buy Potions" })

local PotionBuyState = { selected = {}, quantity = 1 }

PotionsTab:Dropdown({
    Title = "Select Potions to Buy",
    Multi = true,
    AllowNone = true,
    Value = {},
    Flag = "PotionsToBuy",
    Values = PotionData.All,
    Callback = function(values)
        PotionBuyState.selected = values
    end
})

PotionsTab:Slider({
    Title = "Quantity (per potion)",
    Step = 1,
    Flag = "PotionBuyQuantity",
    Value = {
        Min = 1,
        Max = 10,
        Default = 1,
    },
    Callback = function(value)
        PotionBuyState.quantity = value
    end
})

PotionsTab:Button({
    Title = "Buy Selected Potions",
    Callback = function()
        if #PotionBuyState.selected == 0 then
            WindUI:Notify({
                Title = "Potions",
                Content = "No potions selected to buy!",
                Duration = 2,
                Icon = "alert-circle",
            })
            return
        end
        
                task.spawn(function()
            WindUI:Notify({
                Title = "Potions",
                Content = "Flying to potion shop...",
                Duration = 2,
                Icon = "flask-conical",
            })
            
                        local bought, failed = BuyMultiplePotionsWithFly(PotionBuyState.selected, PotionBuyState.quantity)
            
            WindUI:Notify({
                Title = "Potions",
                Content = "Bought " .. bought .. " types, " .. failed .. " failed",
                Duration = 3,
                Icon = "flask-conical",
            })
        end)
    end
})

PotionsTab:Section({ Title = "Auto Health Potions" })

Helpers.IsAnyHealthPotionActive = function()
    for _, potionName in ipairs(PotionData.Health) do
        if Helpers.IsPotionEffectActive(potionName) then return true end
    end
    return false
end

Helpers.GetBestHealthPotion = function()
    for _, potionName in ipairs(PotionData.Health) do
        if Helpers.IsSelected(potionName, getgenv().SelectedHealthPotions) and Helpers.GetPotionCount(potionName) > 0 then
            return potionName
        end
    end
    return nil
end

Helpers.AreAllHealthPotionsEmpty = function()
    for _, potionName in pairs(getgenv().SelectedHealthPotions) do
        if Helpers.GetPotionCount(potionName) > 0 then return false end
    end
    return true
end

PotionsTab:Dropdown({
    Title = "Health Potions to Use",
    Desc = "Select health potions (will use best available first)",
    Multi = true,
    AllowNone = true,
    Value = {},
    Flag = "HealthPotionsToUse",
    Values = PotionData.Health,
    Callback = function(values)
        getgenv().SelectedHealthPotions = values
    end
})

PotionsTab:Slider({
    Title = "Health Threshold (%)",
    Desc = "Use health potion when health drops to this %",
    Step = 5,
    Flag = "HealthPotionThreshold",
    Value = {
        Min = 10,
        Max = 90,
        Default = 50,
    },
    Callback = function(value)
        getgenv().HealthPotionThreshold = value
    end
})

PotionsTab:Toggle({
    Title = "Auto Buy When Empty",
    Desc = "Fly to shop when ALL selected potions are empty",
    Value = false,
    Flag = "AutoBuyHealthPotion",
    Callback = function(state)
        getgenv().AutoBuyHealthPotion = state
    end
})

local function StartAutoHealth()
    if Threads.autoHealth then return end
    
    Threads.autoHealth = task.spawn(function()
        while getgenv().AutoHealthPotion do
                                    local character = LocalPlayer.Character
            local humanoid = character and character:FindFirstChildOfClass("Humanoid")
            
            if humanoid and humanoid.Health > 0 and #getgenv().SelectedHealthPotions > 0 then
                local healthPercent = (humanoid.Health / humanoid.MaxHealth) * 100
                
                                if getgenv().NoDesiredRocksAvailable and healthPercent > 25 then
                    task.wait(0.5)
                    continue
                end
                
                                if healthPercent <= getgenv().HealthPotionThreshold then
                                        if not Helpers.IsAnyHealthPotionActive() then
                                                local bestPotion = Helpers.GetBestHealthPotion()
                        
                                                if not bestPotion and getgenv().AutoBuyHealthPotion and Helpers.AreAllHealthPotionsEmpty() then
                                                        local potionsToBuy = {}
                            for _, potionName in pairs(getgenv().SelectedHealthPotions) do
                                table.insert(potionsToBuy, potionName)
                            end
                            if #potionsToBuy > 0 then
                                BuyMultiplePotionsWithFly(potionsToBuy, 10)
                                task.wait(0.5)
                                bestPotion = Helpers.GetBestHealthPotion()
                            end
                        end
                        
                                                if bestPotion then
                            DrinkPotion(bestPotion)
                        end
                    end
                end
            end
            
                        task.wait(0.5)
        end
    end)
end

local function StopAutoHealth()
    if Threads.autoHealth then
        task.cancel(Threads.autoHealth)
        Threads.autoHealth = nil
    end
end

PotionsTab:Toggle({
    Title = "Auto Health Potion",
    Desc = "Use health potion when health drops below threshold",
    Value = false,
    Flag = "AutoHealthPotion",
    Callback = function(state)
        getgenv().AutoHealthPotion = state
        if state then
            StartAutoHealth()
            WindUI:Notify({
                Title = "Potions",
                Content = "Auto health potion enabled (" .. getgenv().HealthPotionThreshold .. "% threshold)",
                Duration = 2,
                Icon = "heart",
            })
        else
            StopAutoHealth()
            WindUI:Notify({
                Title = "Potions",
                Content = "Auto health potion disabled",
                Duration = 2,
                Icon = "heart",
            })
        end
    end
})

PotionsTab:Section({ Title = "Auto Buff Potions" })

PotionsTab:Dropdown({
    Title = "Select Buff Potions to Auto-Drink",
    Desc = "These will be used when effect expires",
    Multi = true,
    AllowNone = true,
    Value = {},
    Flag = "PotionsToAutoDrink",
    Values = PotionData.Buff,
    Callback = function(values)
        getgenv().SelectedDrinkPotions = values
    end
})

PotionsTab:Toggle({
    Title = "Auto Buy When Empty",
    Desc = "Will fly to potion shop to buy",
    Value = false,
    Flag = "AutoBuyWhenEmpty",
    Callback = function(state)
        getgenv().AutoBuyWhenEmpty = state
    end
})

local function StartAutoDrink()
    if Threads.autoDrink then return end
    
    Threads.autoDrink = task.spawn(function()
        while getgenv().AutoDrinkPotions do
                        if getgenv().NoDesiredRocksAvailable then
                task.wait(1)
                continue
            end
            
            if #getgenv().SelectedDrinkPotions > 0 then
                                for _, potionName in ipairs(getgenv().SelectedDrinkPotions) do
                                        if not Helpers.IsPotionEffectActive(potionName) then
                        local count = Helpers.GetPotionCount(potionName)
                        
                                                if count <= 0 and getgenv().AutoBuyWhenEmpty then
                            BuyPotionWithFly(potionName, 10)
                            task.wait(0.5)
                            count = Helpers.GetPotionCount(potionName)
                        end
                        
                                                if count > 0 then
                            DrinkPotion(potionName)
                        end
                    end
                end
            end
            
                        task.wait(10)
        end
    end)
end

local function StopAutoDrink()
    if Threads.autoDrink then
        task.cancel(Threads.autoDrink)
        Threads.autoDrink = nil
    end
end

PotionsTab:Toggle({
    Title = "Auto Drink Buff Potions",
    Desc = "Checks every 10 seconds, drinks when effect ends",
    Value = false,
    Flag = "AutoDrinkBuffPotions",
    Callback = function(state)
        getgenv().AutoDrinkPotions = state
        if state then
            StartAutoDrink()
            WindUI:Notify({
                Title = "Potions",
                Content = "Auto buff potions enabled (checks every 10s)",
                Duration = 2,
                Icon = "flask-conical",
            })
        else
            StopAutoDrink()
            WindUI:Notify({
                Title = "Potions",
                Content = "Auto buff potions disabled",
                Duration = 2,
                Icon = "flask-conical",
            })
        end
    end
})

local NPCsTab = Window:Tab({
    Title = "NPCs / Proximity",
    Icon = "map-pin",
})

local ImportantPlaces = {
    "Enhancer",
    "Runemaker", 
    "Forge",
    "Maria",          "Marbles",        "Greedy Cey","Maze Merchant/Fungi" }

Helpers.IsImportantPlace = function(name)
    for _, place in pairs(ImportantPlaces) do
        if name == place then return true end
    end
    return false
end

Helpers.IsPickaxe = function(name) return string.match(name, "Pickaxe$") ~= nil end

Helpers.GetPickaxeList = function()
    local list, proximity = {}, workspace:FindFirstChild("Proximity")
    if proximity then
        for _, child in pairs(proximity:GetChildren()) do
            if Helpers.IsPickaxe(child.Name) then table.insert(list, child.Name) end
        end
        table.sort(list)
    end
    return list
end

Helpers.GetOtherNPCsList = function()
    local list, proximity = {}, workspace:FindFirstChild("Proximity")
    if proximity then
        for _, child in pairs(proximity:GetChildren()) do
            if not Helpers.IsImportantPlace(child.Name) and not Helpers.IsPickaxe(child.Name) then
                table.insert(list, child.Name)
            end
        end
        table.sort(list)
    end
    return list
end

local function FlyToProximity(targetName)
    task.spawn(function()
        local character = LocalPlayer.Character
        if not character then return end
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        
                local proximity = workspace:FindFirstChild("Proximity")
        if not proximity then
            WindUI:Notify({
                Title = "NPCs",
                Content = "Proximity folder not found!",
                Duration = 2,
                Icon = "alert-circle",
            })
            return
        end
        
        local npc = proximity:FindFirstChild(targetName)
        if not npc then
            WindUI:Notify({
                Title = "NPCs",
                Content = targetName .. " not found!",
                Duration = 2,
                Icon = "alert-circle",
            })
            return
        end
        
                local targetPart = nil
        if npc:IsA("Model") then
            targetPart = npc.PrimaryPart or npc:FindFirstChild("HumanoidRootPart") or npc:FindFirstChildOfClass("BasePart")
        elseif npc:IsA("BasePart") then
            targetPart = npc
        end
        
        if not targetPart then
            WindUI:Notify({
                Title = "NPCs",
                Content = "Could not find position for " .. targetName,
                Duration = 2,
                Icon = "alert-circle",
            })
            return
        end
        
        WindUI:Notify({
            Title = "NPCs",
            Content = "Flying to " .. targetName .. "...",
            Duration = 2,
            Icon = "map-pin",
        })
        
                local wasMining = getgenv().AutoMine
        local wasMobbing = getgenv().AutoMob
        
        if wasMining then getgenv().AutoMine = false end
        if wasMobbing then getgenv().AutoMob = false end
        
        task.wait(0.3)
        
                local originalHipHeight = humanoid.HipHeight
        
                local targetPos = targetPart.Position + Vector3.new(0, 2, 0)
        if npc:FindFirstChild("HumanoidRootPart") then
            local npcHRP = npc.HumanoidRootPart
            local lookVector = npcHRP.CFrame.LookVector
            targetPos = npcHRP.Position + (lookVector * 3)
        end
        
                local wasNoClipEnabled = getgenv().NoClipEnabled
        getgenv().NoClipEnabled = true
        
                local flyBV = Instance.new("BodyVelocity")
        flyBV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        flyBV.Velocity = Vector3.new(0, 0, 0)
        flyBV.Parent = hrp
        
        local flyBG = Instance.new("BodyGyro")
        flyBG.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        flyBG.P = 10000
        flyBG.D = 100
        flyBG.Parent = hrp
        
        humanoid.PlatformStand = true
        
                local startTime = tick()
        local timeout = 150
        
        while (hrp.Position - targetPos).Magnitude > 3 and tick() - startTime < timeout do
            local direction = (targetPos - hrp.Position).Unit
            flyBV.Velocity = direction * 50
            flyBG.CFrame = CFrame.new(hrp.Position, targetPos)
            task.wait()
        end
        
                flyBV.Velocity = Vector3.new(0, 0, 0)
        humanoid.HipHeight = originalHipHeight
        hrp.CFrame = CFrame.new(targetPos)
        
                pcall(function() flyBV:Destroy() end)
        pcall(function() flyBG:Destroy() end)
        humanoid.PlatformStand = false
        
        getgenv().NoClipEnabled = wasNoClipEnabled
        
                if wasMining then getgenv().AutoMine = true end
        if wasMobbing then getgenv().AutoMob = true end
        
        WindUI:Notify({
            Title = "NPCs",
            Content = "Arrived at " .. targetName,
            Duration = 2,
            Icon = "check-circle",
        })
    end)
end

NPCsTab:Section({ Title = "Important Places" })

NPCsTab:Button({
    Title = "Enhancer",
    Callback = function()
        FlyToProximity("Enhancer")
    end
})

NPCsTab:Button({
    Title = "Runemaker",
    Callback = function()
        FlyToProximity("Runemaker")
    end
})

NPCsTab:Button({
    Title = "Forge",
    Callback = function()
        FlyToProximity("Forge")
    end
})

NPCsTab:Button({
    Title = "Potions Shop",
    Desc = "Maria",
    Callback = function()
        FlyToProximity("Maria")
    end
})

NPCsTab:Button({
    Title = "Sell Equipments",
    Desc = "Marbles",
    Callback = function()
        FlyToProximity("Marbles")
    end
})

NPCsTab:Button({
    Title = "Sell Ores, Materials",
    Desc = "Greedy Cey",
    Callback = function()
        FlyToProximity("Greedy Cey")
    end
})

NPCsTab:Button({
    Title = "Maze Merchant/Fungi",
    Desc = "Merchant",
    Callback = function()
        FlyToProximity("MazeMerchant")
    end
})

NPCsTab:Section({ Title = "Pickaxe Shops" })

local NPCsUI = { selectedPickaxe = nil, selectedOtherNPC = nil }

NPCsUI.pickaxeDropdown = NPCsTab:Dropdown({
    Title = "Select Pickaxe Shop",
    Multi = false,
    Values = Helpers.GetPickaxeList(),
    Callback = function(value)
        NPCsUI.selectedPickaxe = value
    end
})

NPCsTab:Button({
    Title = "Fly to Pickaxe Shop",
    Callback = function()
        if not NPCsUI.selectedPickaxe or NPCsUI.selectedPickaxe == "" then
            WindUI:Notify({
                Title = "NPCs",
                Content = "No pickaxe shop selected!",
                Duration = 2,
                Icon = "alert-circle",
            })
            return
        end
        FlyToProximity(NPCsUI.selectedPickaxe)
    end
})

NPCsTab:Section({ Title = "Other NPCs" })

NPCsUI.otherNPCDropdown = NPCsTab:Dropdown({
    Title = "Select NPC / Proximity",
    Multi = false,
    Values = Helpers.GetOtherNPCsList(),
    Callback = function(value)
        NPCsUI.selectedOtherNPC = value
    end
})

NPCsTab:Button({
    Title = "Fly to Selected",
    Callback = function()
        if not NPCsUI.selectedOtherNPC or NPCsUI.selectedOtherNPC == "" then
            WindUI:Notify({
                Title = "NPCs",
                Content = "No NPC selected!",
                Duration = 2,
                Icon = "alert-circle",
            })
            return
        end
        FlyToProximity(NPCsUI.selectedOtherNPC)
    end
})

NPCsTab:Button({
    Title = "Refresh Lists",
    Desc = "Update lists for current world",
    Callback = function()
        NPCsUI.pickaxeDropdown:Refresh(Helpers.GetPickaxeList())
        NPCsUI.otherNPCDropdown:Refresh(Helpers.GetOtherNPCsList())
        WindUI:Notify({
            Title = "NPCs",
            Content = "Lists refreshed!",
            Duration = 2,
            Icon = "refresh-cw",
        })
    end
})

local RacesTab = Window:Tab({
    Title = "Races",
    Icon = "dna",
})

local RaceList = {
    "Human",
    "Elf",
    "Zombie",
    "Goblin",
    "Undead",
    "Orc",
    "Dwarf",
    "Shadow",
    "Vampire",
    "Minotaur",
    "Dragonborn",
    "Golem",
    "Felynx",
    "Angel",
    "Demon",
    "Archangel"
}

local RaceChances = {
    ["Human"] = "25%",
    ["Elf"] = "14%",
    ["Zombie"] = "13.75%",
    ["Goblin"] = "10.4%",
    ["Undead"] = "9%",
    ["Orc"] = "8%",
    ["Dwarf"] = "5%",
    ["Shadow"] = "4%",
    ["Vampire"] = "4%",
    ["Minotaur"] = "1.75%",
    ["Dragonborn"] = "1.5%",
    ["Golem"] = "1.25%",
    ["Felynx"] = "1.25%",
    ["Angel"] = "0.5%",
    ["Demon"] = "0.5%",
    ["Archangel"] = "0.1%"
}

getgenv().AutoRerollRace = false
getgenv().SelectedTargetRaces = {}

local function GetCurrentRace()
    local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
    if not playerGui then return "Unknown" end
    
    local sellGui = playerGui:FindFirstChild("Sell")
    if not sellGui then return "Unknown" end
    
    local raceUI = sellGui:FindFirstChild("RaceUI")
    if not raceUI then return "Unknown" end
    
    local currentRaceLabel = raceUI:FindFirstChild("CurrentRace")
    if not currentRaceLabel then return "Unknown" end
    
    local raceText = currentRaceLabel.ContentText or currentRaceLabel.Text or ""
    if raceText == "" then return "Unknown" end
    
    return raceText
end

local function RerollRace()
    local RaceService = game:GetService("ReplicatedStorage"):FindFirstChild("Shared")
    if not RaceService then return false end
    
    local Packages = RaceService:FindFirstChild("Packages")
    if not Packages then return false end
    
    local Knit = Packages:FindFirstChild("Knit")
    if not Knit then return false end
    
    local Services = Knit:FindFirstChild("Services")
    if not Services then return false end
    
    local RaceServiceFolder = Services:FindFirstChild("RaceService")
    if not RaceServiceFolder then return false end
    
    local RF = RaceServiceFolder:FindFirstChild("RF")
    if not RF then return false end
    
    local Reroll = RF:FindFirstChild("Reroll")
    if not Reroll then return false end
    
    local success, result = pcall(function()
        return Reroll:InvokeServer()
    end)
    
    return success
end

local function IsTargetRace(raceName)
    for _, target in pairs(getgenv().SelectedTargetRaces) do
        if target == raceName then
            return true
        end
    end
    return false
end

local function StartAutoReroll(toggleElement)
    if Threads.autoReroll then return end
    
    Threads.autoReroll = task.spawn(function()
        while getgenv().AutoRerollRace do
            local currentRace = GetCurrentRace()
            
                        if IsTargetRace(currentRace) then
                WindUI:Notify({
                    Title = "Race Reroll",
                    Content = "Already have target race: " .. currentRace .. "!",
                    Duration = 3,
                    Icon = "check-circle",
                })
                getgenv().AutoRerollRace = false
                toggleElement:Set(false)
                break
            end
            
                        if #getgenv().SelectedTargetRaces == 0 then
                WindUI:Notify({
                    Title = "Race Reroll",
                    Content = "No target races selected!",
                    Duration = 2,
                    Icon = "alert-circle",
                })
                getgenv().AutoRerollRace = false
                toggleElement:Set(false)
                break
            end
            
                        RerollRace()
            task.wait(0.5)             
                        local newRace = GetCurrentRace()
            
            if IsTargetRace(newRace) then
                WindUI:Notify({
                    Title = "Race Reroll",
                    Content = "Got target race: " .. newRace .. "!",
                    Duration = 5,
                    Icon = "sparkles",
                })
                getgenv().AutoRerollRace = false
                toggleElement:Set(false)
                break
            end
            
            task.wait(0.3)         end
    end)
end

local function StopAutoReroll()
    if Threads.autoReroll then
        task.cancel(Threads.autoReroll)
        Threads.autoReroll = nil
    end
end

RacesTab:Section({ Title = "Current Race" })

local RacesUI = {}

RacesUI.currentRaceText = RacesTab:Paragraph({
    Title = "Your Race",
    Desc = GetCurrentRace()
})

RacesTab:Button({
    Title = "Refresh Current Race",
    Callback = function()
        local race = GetCurrentRace()
        RacesUI.currentRaceText:SetDesc(race)
        WindUI:Notify({
            Title = "Races",
            Content = "Current race: " .. race,
            Duration = 2,
            Icon = "dna",
        })
    end
})

RacesTab:Divider()

RacesTab:Section({ Title = "Auto Reroll" })

RacesTab:Dropdown({
    Title = "Target Races",
    Desc = "Stop rerolling when you get one of these",
    Multi = true,
    AllowNone = true,
    Flag = "TargetRaces",
    Values = RaceList,
    Value = {},
    Callback = function(values)
        getgenv().SelectedTargetRaces = values
    end
})

RacesUI.autoRerollToggle = RacesTab:Toggle({
    Title = "Auto Reroll Race",
    Desc = "Reroll until you get a target race",
    Value = false,
    Callback = function(state)
        getgenv().AutoRerollRace = state
        if state then
            StartAutoReroll(RacesUI.autoRerollToggle)
            WindUI:Notify({
                Title = "Race Reroll",
                Content = "Auto rerolling for: " .. table.concat(getgenv().SelectedTargetRaces, ", "),
                Duration = 3,
                Icon = "dna",
            })
        else
            StopAutoReroll()
            WindUI:Notify({
                Title = "Race Reroll",
                Content = "Stopped rerolling",
                Duration = 2,
                Icon = "square",
            })
        end
    end
})

RacesTab:Divider()

RacesTab:Section({ Title = "Race Chances" })

for _, race in ipairs(RaceList) do
    RacesTab:Paragraph({
        Title = race,
        Desc = RaceChances[race] or "Unknown"
    })
end

local ServerHopTab = Window:Tab({
    Title = "Server Hop",
    Icon = "globe",
})

getgenv().RequireMinPlayer = false
getgenv().PreferLowPing = false

local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")

local function GetServers(placeId)
    local servers = {}
    local url = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"
    
    local success, response = pcall(function()
        return request({
            Url = url,
            Method = "GET",
        })
    end)
    
    if success and response and response.Body then
        local data = HttpService:JSONDecode(response.Body)
        if data and data.data then
            servers = data.data
        end
    end
    
    return servers
end

local function FindBestServer(placeId)
    local servers = GetServers(placeId)
    local currentJobId = game.JobId
    
        local filteredServers = {}
    for _, server in ipairs(servers) do
        if server.id ~= currentJobId then
                        if getgenv().RequireMinPlayer then
                if server.playing >= 1 then
                    table.insert(filteredServers, server)
                end
            else
                table.insert(filteredServers, server)
            end
        end
    end
    
    if #filteredServers == 0 then
        return nil
    end
    
        table.sort(filteredServers, function(a, b)
        if a.playing == b.playing then
                        if getgenv().PreferLowPing then
                return a.ping < b.ping
            end
        end
        return a.playing < b.playing
    end)
    
        if getgenv().PreferLowPing then
        local lowestPlayerCount = filteredServers[1].playing
        local lowPlayerServers = {}
        for _, server in ipairs(filteredServers) do
            if server.playing == lowestPlayerCount then
                table.insert(lowPlayerServers, server)
            end
        end
        table.sort(lowPlayerServers, function(a, b)
            return a.ping < b.ping
        end)
        return lowPlayerServers[1]
    end
    
    return filteredServers[1]
end

local TELEPORT_BLOCKER_SCRIPT = [=[
task.spawn(function()
    repeat task.wait() until game:IsLoaded()
    local tpService = cloneref(game:GetService("TeleportService"))
    tpService:SetTeleportGui(tpService)
    task.wait(3)
    tpService:TeleportCancel()
    tpService:SetTeleportGui(nil)
end)
]=]

local function HopToServer(placeId, worldName, useBlocker)
    WindUI:Notify({
        Title = "Server Hop",
        Content = "Finding best server for " .. worldName .. "...",
        Duration = 3,
        Icon = "search",
    })
    
    local bestServer = FindBestServer(placeId)
    
    if bestServer then
        WindUI:Notify({
            Title = "Server Found!",
            Content = "Players: " .. bestServer.playing .. " | Ping: " .. math.floor(bestServer.ping) .. "ms",
            Duration = 3,
            Icon = "check-circle",
        })
        
        task.wait(1)
        
                if useBlocker and queue_on_teleport then
            queue_on_teleport(TELEPORT_BLOCKER_SCRIPT)
        end
        
        TeleportService:TeleportToPlaceInstance(placeId, bestServer.id)
    else
        WindUI:Notify({
            Title = "No Server Found",
            Content = "Could not find a suitable server. Try disabling 'Require 1+ Player'.",
            Duration = 5,
            Icon = "alert-circle",
        })
    end
end

local function HopToPlaceId(placeId, useBlocker)
    WindUI:Notify({
        Title = "Teleporting",
        Content = "Teleporting to PlaceId: " .. tostring(placeId),
        Duration = 3,
        Icon = "send",
    })
    
    task.wait(0.5)
    
        if useBlocker and queue_on_teleport then
        queue_on_teleport(TELEPORT_BLOCKER_SCRIPT)
    end
    
    TeleportService:Teleport(placeId)
end

ServerHopTab:Section({
    Title = "Server Hop Options",
    Icon = "settings",
})

ServerHopTab:Toggle({
    Title = "Require 1+ Player",
    Desc = "Only join servers with at least 1 player",
    Value = false,
    Flag = "RequireMinPlayer",
    Callback = function(state)
        getgenv().RequireMinPlayer = state
    end
})

ServerHopTab:Toggle({
    Title = "Prefer Low Ping",
    Desc = "Among lowest player servers, pick the one with lowest ping",
    Value = false,
    Flag = "PreferLowPing",
    Callback = function(state)
        getgenv().PreferLowPing = state
    end
})

ServerHopTab:Divider()

ServerHopTab:Section({
    Title = "Hop to World",
    Icon = "globe",
})

ServerHopTab:Button({
    Title = "Hop to World 1",
    Desc = "Teleport to lowest player World 1 server",
    Callback = function()
        HopToServer(WORLD_1_PLACE_ID, "World 1", false)
    end
})

ServerHopTab:Button({
    Title = "Hop to World 2",
    Desc = "Teleport to lowest player World 2 server",
    Callback = function()
        HopToServer(WORLD_2_PLACE_ID, "World 2", true)
    end
})

ServerHopTab:Divider()

ServerHopTab:Section({
    Title = "Custom Server (Job ID)",
    Icon = "hash",
})

local customJobId = ""

ServerHopTab:Input({
    Title = "Job ID",
    Desc = "Enter server Job ID to join specific server",
    Value = "",
    Placeholder = "Enter Job ID...",
    Callback = function(value)
        customJobId = value
    end
})

ServerHopTab:Button({
    Title = "Join Server",
    Desc = "Teleport to the server with entered Job ID",
    Callback = function()
        if customJobId == "" then
            WindUI:Notify({
                Title = "Invalid Job ID",
                Content = "Please enter a Job ID",
                Duration = 3,
                Icon = "alert-circle",
            })
            return
        end
        
                local placeId = game.PlaceId
        local isWorld2 = (placeId == WORLD_2_PLACE_ID)
        
        WindUI:Notify({
            Title = "Teleporting",
            Content = "Joining server: " .. string.sub(customJobId, 1, 8) .. "...",
            Duration = 3,
            Icon = "send",
        })
        
        task.wait(0.5)
        
                if queue_on_teleport then
            queue_on_teleport(TELEPORT_BLOCKER_SCRIPT)
        end
        
        TeleportService:TeleportToPlaceInstance(placeId, customJobId)
    end
})

ServerHopTab:Divider()

ServerHopTab:Section({
    Title = "Current Server Info",
    Icon = "info",
})

ServerHopTab:Button({
    Title = "Show Server Info",
    Desc = "Display current server details",
    Callback = function()
        local currentWorld = "Unknown"
        if game.PlaceId == WORLD_1_PLACE_ID then
            currentWorld = "World 1"
        elseif game.PlaceId == WORLD_2_PLACE_ID then
            currentWorld = "World 2"
        end
        
        WindUI:Notify({
            Title = "Current Server",
            Content = "World: " .. currentWorld .. "\nJob ID: " .. string.sub(game.JobId, 1, 8) .. "...",
            Duration = 5,
            Icon = "info",
        })
    end
})

local DesyncTab = Window:Tab({
    Title = "Desync",
    Icon = "zap",
})

local DesyncFFlags = {
    PhysicsSenderMaxBandwidthBps = "20000",
    S2PhysicsSenderRate = "15000",
    ServerMaxBandwith = "20",
    MaxTimestepMultiplierAcceleration = "2147483647",
    InterpolationFrameVelocityThresholdMillionth = "5",
    GameNetDontSendRedundantNumTimes = "1",
    GameNetPVHeaderConfig = "1",
    GameNetPVHeaderConfig_RiseClientNetworkPV = "1",
    GameNetPVHeaderConfig_RiseServerNetworkPV = "1",
    GameNetPVSensitivity = "1",
    GameNetPVSensitivityRise = "1",
    MaxFrameSendMultiplierAcceleration = "2147483647",
    InterpolationFrameTimeMaxAcceleration = "1",
    InterpolationFrameTimeWindow = "2147483647",
    InterpolationFrameTimeWindowMultiplier = "2147483647",
    InterpolationWindowDelayMillis = "2000",
    InterpolationWindowMinDelay = "2147483647",
    InterpolationWindowServerPosAdjPercent = "0",
    InterpolationWindowServerVelAdjPercent = "0",
    InterpolationWindowVelocityMultiplier = "0",
    NetworkMaxReceiveKBps = "0",
    NextGenReplicatorEnabledWrite4 = "true",
    MicroProfilerDWebServerIp = "255.255.255.255",
    PhysicsNetIncomingWaitForCFrameNan = "false",
    UseLargerInterpolationWindow2 = "true",
    CellDictionaryKeyString = "true",
    DisableInterpolateUnownedFloorToFloorTransitions = "true",
    InterpolationAdjustVelocityMaxSpeedSqr = "0",
    InterpolationAdjustVelocityMaxWait = "0",
    InterpolationAdjustVelocityMaxWaitMSec = "0",
    InterpolationConvergeToServerVelIfZero = "false",
    InterpolationFloorAdaptiveZero = "false",
    MaxPhysicsSpeedSq = "9999999999",
    MinorTimeCorrectionsEnabled = "false",
    PhysicsMaxTimestepRollingAverageFactor = "100000000",
    PhysicsMinTimestepRollingAverageFactor = "100000000",
    PhysicsSenderDropBatch = "false",
    PhysicsSenderSlidingWindowRatio = "99999",
    PhysicsSenderSlidingWindowTime = "99999",
    PhysicsSenderSlidingWindowTransmitBandwidthRatio = "9999",
    PhysicsSenderThrottleMaxPacketsPerStep = "9999",
    PhysicsSpeedThreshold = "9999999999999",
    PhysicsTimestepRollingAverageUnder = "true",
    ReplicatorNumBytesPerClusterFlat = "9999999999",
    ReplicatorNumClustersPerBatch = "1",
}

local DefaultFFlags = {
    PhysicsSenderMaxBandwidthBps = "15000",
    S2PhysicsSenderRate = "20000",
    ServerMaxBandwith = "102",
    MaxTimestepMultiplierAcceleration = "1000000",
    InterpolationFrameVelocityThresholdMillionth = "100",
    GameNetDontSendRedundantNumTimes = "0",
    GameNetPVHeaderConfig = "0",
    GameNetPVHeaderConfig_RiseClientNetworkPV = "0",
    GameNetPVHeaderConfig_RiseServerNetworkPV = "0",
    GameNetPVSensitivity = "0",
    GameNetPVSensitivityRise = "0",
    MaxFrameSendMultiplierAcceleration = "1000000",
    InterpolationFrameTimeMaxAcceleration = "100",
    InterpolationFrameTimeWindow = "30",
    InterpolationFrameTimeWindowMultiplier = "2",
    InterpolationWindowDelayMillis = "100",
    InterpolationWindowMinDelay = "50",
    InterpolationWindowServerPosAdjPercent = "100",
    InterpolationWindowServerVelAdjPercent = "100",
    InterpolationWindowVelocityMultiplier = "1",
    NetworkMaxReceiveKBps = "64",
    NextGenReplicatorEnabledWrite4 = "false",
    MicroProfilerDWebServerIp = "127.0.0.1",
    PhysicsNetIncomingWaitForCFrameNan = "true",
    UseLargerInterpolationWindow2 = "false",
    CellDictionaryKeyString = "false",
    DisableInterpolateUnownedFloorToFloorTransitions = "false",
    InterpolationAdjustVelocityMaxSpeedSqr = "1000",
    InterpolationAdjustVelocityMaxWait = "0.5",
    InterpolationAdjustVelocityMaxWaitMSec = "500",
    InterpolationConvergeToServerVelIfZero = "true",
    InterpolationFloorAdaptiveZero = "true",
    MaxPhysicsSpeedSq = "10000",
    MinorTimeCorrectionsEnabled = "true",
    PhysicsMaxTimestepRollingAverageFactor = "0.5",
    PhysicsMinTimestepRollingAverageFactor = "0.5",
    PhysicsSenderDropBatch = "true",
    PhysicsSenderSlidingWindowRatio = "0.5",
    PhysicsSenderSlidingWindowTime = "0.5",
    PhysicsSenderSlidingWindowTransmitBandwidthRatio = "0.5",
    PhysicsSenderThrottleMaxPacketsPerStep = "10",
    PhysicsSpeedThreshold = "100",
    PhysicsTimestepRollingAverageUnder = "false",
    ReplicatorNumBytesPerClusterFlat = "1000",
    ReplicatorNumClustersPerBatch = "10",
}

local function IsDesynced()
    if not setfflag then return false end
    local success, result = pcall(function()
        return getfflag and getfflag("PhysicsSenderMaxBandwidthBps")
    end)
    if success and result == "20000" then
        return true
    end
    return false
end

getgenv().DesyncEnabled = IsDesynced()

DesyncTab:Section({
    Title = "Desync Controls",
    Icon = "zap",
})

getgenv().DesyncStatusParagraph = DesyncTab:Paragraph({
    Title = "Desync Status",
    Desc = getgenv().DesyncEnabled and "✅ DESYNCED - You are invisible to other players" or "❌ NOT DESYNCED - Normal state",
})

DesyncTab:Button({
    Title = "Enable Desync",
    Desc = "Sets desync FFlags and rejoins the server (required for desync to work)",
    Callback = function()
        if not setfflag then
            WindUI:Notify({
                Title = "Error",
                Content = "setfflag is not available in your executor",
                Duration = 5,
                Icon = "alert-circle",
            })
            return
        end
        
        WindUI:Notify({
            Title = "Enabling Desync",
            Content = "Setting FFlags and rejoining server...",
            Duration = 3,
            Icon = "zap",
        })
        
                for flag, value in pairs(DesyncFFlags) do
            pcall(function()
                setfflag(flag, value)
            end)
        end
        
        getgenv().DesyncEnabled = true
        
                task.delay(1, function()
            local TeleportService = game:GetService("TeleportService")
            pcall(function()
                TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId)
            end)
        end)
    end
})

DesyncTab:Button({
    Title = "Disable Desync",
    Desc = "Resets FFlags to default values rejpin needed",
    Callback = function()
        if not setfflag then
            WindUI:Notify({
                Title = "Error",
                Content = "setfflag is not available in your executor",
                Duration = 5,
                Icon = "alert-circle",
            })
            return
        end
        
                for flag, value in pairs(DefaultFFlags) do
            pcall(function()
                setfflag(flag, value)
            end)
        end
        
        getgenv().DesyncEnabled = false
        
                getgenv().DesyncStatusParagraph:SetDesc("❌ NOT DESYNCED - Normal state")
        
                local networkClient = game:FindService("NetworkClient")
        if networkClient then
            local player = game:GetService("Players").LocalPlayer
            if player and player.Character then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                                        hrp.CFrame = hrp.CFrame * CFrame.new(0, 0.1, 0)
                    task.wait(0.1)
                    hrp.CFrame = hrp.CFrame * CFrame.new(0, -0.1, 0)
                end
            end
        end
        
        WindUI:Notify({
            Title = "Desync Disabled",
            Content = "FFlags reset to default. You are now visible to other players. but u need to rejoin",
            Duration = 5,
            Icon = "check",
        })
    end
})

DesyncTab:Divider()

DesyncTab:Section({
    Title = "Information",
    Icon = "info",
})

DesyncTab:Paragraph({
    Title = "What is Desync?",
    Desc = "Desync makes your character invisible to other players and server. You can move around freely but others see you at your last synced position. Useful for mining and farming.",
})

DesyncTab:Paragraph({
    Title = "How it Works",
    Desc = "Enable it then start do mining or killing mobs or whatever u wants",
})

DesyncTab:Paragraph({
    Title = "Note",
    Desc = "After enable it, the game will rejoing and you are desynced that's all you can tp or any map or farm",
})

local ConfigTab = Window:Tab({
    Title = "Configs",
    Icon = "save",
})

ConfigTab:Section({
    Title = "Configuration",
    Icon = "folder",
})

local ConfigManager = Window.ConfigManager
local ConfigState = {
    currentName = "Default",
    current = ConfigManager:CreateConfig("Default"),
    newName = "Default",
}

local function GetAllConfigs()
    local configs = ConfigManager:AllConfigs() or {}
    if #configs == 0 then
        table.insert(configs, "Default")
    end
    return configs
end

ConfigTab:Input({
    Title = "New Config Name",
    Desc = "Enter a name for your config",
    Value = "Default",
    Placeholder = "Enter config name...",
    Callback = function(input)
        ConfigState.newName = input
    end
})

ConfigTab:Divider()

local ConfigUI = {}
ConfigUI.configDropdown = ConfigTab:Dropdown({
    Title = "Select Config",
    Desc = "Choose a saved config to load or manage",
    Multi = false,
    Values = GetAllConfigs(),
    Value = "Default",
    Callback = function(value)
        ConfigState.currentName = value
    end
})

ConfigTab:Divider()

ConfigTab:Section({
    Title = "Config Actions",
    Icon = "settings",
})

ConfigTab:Button({
    Title = "Save Current Config",
    Desc = "Save settings to selected config",
    Callback = function()
        if ConfigState.currentName and ConfigState.currentName ~= "" then
            local config = ConfigManager:CreateConfig(ConfigState.currentName)
            config:Save()
            WindUI:Notify({
                Title = "Config Saved",
                Content = "Saved to: " .. ConfigState.currentName,
                Duration = 2,
                Icon = "check-circle",
            })
        end
    end
})

ConfigTab:Button({
    Title = "Save As New Config",
    Desc = "Create new config with the name above",
    Callback = function()
        local name = ConfigState.newName
        if name == "" then name = "Default" end
        
        local config = ConfigManager:CreateConfig(name)
        config:Save()
        
                ConfigUI.configDropdown:Refresh(GetAllConfigs())
        ConfigState.currentName = name
        
        WindUI:Notify({
            Title = "New Config Created",
            Content = "Created and saved: " .. name,
            Duration = 2,
            Icon = "check-circle",
        })
    end
})

ConfigTab:Button({
    Title = "Load Selected Config",
    Desc = "Load your saved settings",
    Callback = function()
        if ConfigState.currentName and ConfigState.currentName ~= "" then
            local config = ConfigManager:CreateConfig(ConfigState.currentName)
            config:Load()
            WindUI:Notify({
                Title = "Config Loaded",
                Content = "Loaded: " .. ConfigState.currentName,
                Duration = 2,
                Icon = "check-circle",
            })
        end
    end
})

ConfigTab:Button({
    Title = "Delete Selected Config",
    Desc = "Delete your saved settings",
    Callback = function()
        if ConfigState.currentName and ConfigState.currentName ~= "" then
            local config = ConfigManager:CreateConfig(ConfigState.currentName)
            config:Delete()
            
                        ConfigUI.configDropdown:Refresh(GetAllConfigs())
            
            WindUI:Notify({
                Title = "Config Deleted",
                Content = "Deleted: " .. ConfigState.currentName,
                Duration = 2,
                Icon = "trash",
            })
        end
    end
})

ConfigTab:Button({
    Title = "Refresh Config List",
    Callback = function()
        ConfigUI.configDropdown:Refresh(GetAllConfigs())
        WindUI:Notify({
            Title = "Configs Refreshed",
            Content = "Found " .. #GetAllConfigs() .. " configs",
            Duration = 2,
            Icon = "refresh-cw",
        })
    end
})

local AFKTab = Window:Tab({
    Title = "AFK",
    Icon = "moon",
})

AFKTab:Section({
    Title = "AFK Protection",
    Icon = "shield",
})

getgenv().AntiAfkEnabled = true
AFKTab:Toggle({
    Title = "Anti-AFK",
    Desc = "Prevents you from being kicked for being idle",
    Value = true,
    Callback = function(state)
        getgenv().AntiAfkEnabled = state
        if state then
            local VirtualUser = game:GetService("VirtualUser")
            local Player = game:GetService("Players").LocalPlayer
            
                        if Threads.antiAfkConnection then
                Threads.antiAfkConnection:Disconnect()
                Threads.antiAfkConnection = nil
            end
            
            Threads.antiAfkConnection = Player.Idled:Connect(function()
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end)
            
            WindUI:Notify({
                Title = "Anti-AFK Enabled",
                Content = "You won't be kicked for being idle",
                Duration = 2,
                Icon = "check-circle",
            })
        else
            if Threads.antiAfkConnection then
                Threads.antiAfkConnection:Disconnect()
                Threads.antiAfkConnection = nil
            end
            WindUI:Notify({
                Title = "Anti-AFK Disabled",
                Content = "AFK kick protection removed",
                Duration = 2,
                Icon = "x-circle",
            })
        end
    end
})

task.spawn(function()
    if getgenv().AntiAfkEnabled and not Threads.antiAfkConnection then
        local VirtualUser = game:GetService("VirtualUser")
        local Player = game:GetService("Players").LocalPlayer
        
        Threads.antiAfkConnection = Player.Idled:Connect(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end
end)

AFKTab:Divider()

AFKTab:Section({
    Title = "Performance",
    Icon = "cpu",
})

AFKTab:Toggle({
    Title = "Stop Rendering",
    Desc = "Disables 3D rendering to save resources (screen goes black but game runs)",
    Value = false,
    Callback = function(state)
        game:GetService("RunService"):Set3dRenderingEnabled(not state)
        if state then
            WindUI:Notify({
                Title = "Rendering Stopped",
                Content = "3D rendering disabled - game still running",
                Duration = 2,
                Icon = "pause-circle",
            })
        else
            WindUI:Notify({
                Title = "Rendering Resumed",
                Content = "3D rendering enabled",
                Duration = 2,
                Icon = "play-circle",
            })
        end
    end
})

local PerformanceBoosterControl = {
    IsActive = false,
    WorkspaceConnection = nil
}

local function optimizeObject(v)
    pcall(function()
        if not v or not v.Parent then return end
        
        if v:IsA("BasePart") then
            v.Material = Enum.Material.Plastic
            v.Reflectance = 0
        elseif v:IsA("Decal") then
            v.Transparency = 1
        elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
            v.Lifetime = NumberRange.new(0)
        elseif v:IsA("Explosion") then
            v.BlastPressure = 1
            v.BlastRadius = 1
        end
    end)
end

local function applyGlobalSettings()
        local terrain = workspace:FindFirstChildOfClass('Terrain')
    if terrain then
        terrain.WaterWaveSize = 0
        terrain.WaterWaveSpeed = 0
        terrain.WaterReflectance = 0
        terrain.WaterTransparency = 0
    end

        game:GetService("Lighting").GlobalShadows = false
    game:GetService("Lighting").FogEnd = 9e9

        pcall(function()
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
    end)

        for _, v in pairs(game:GetService("Lighting"):GetDescendants()) do
        if v:IsA("BlurEffect") or v:IsA("SunRaysEffect") or v:IsA("ColorCorrectionEffect") or v:IsA("BloomEffect") or v:IsA("DepthOfFieldEffect") then
            v.Enabled = false
        end
    end
end

local function activatePerformanceBooster()
    if PerformanceBoosterControl.IsActive then
        return
    end
    
    PerformanceBoosterControl.IsActive = true
    
        applyGlobalSettings()
    
        for _, v in pairs(workspace:GetDescendants()) do
        optimizeObject(v)
    end
    
        PerformanceBoosterControl.WorkspaceConnection = workspace.DescendantAdded:Connect(optimizeObject)
end

AFKTab:Button({
    Title = "Enable Performance Mode",
    Desc = "Reduces graphics for better FPS (requires rejoin to undo)",
    Callback = function()
        activatePerformanceBooster()
        WindUI:Notify({
            Title = "Performance Mode Enabled",
            Content = "Graphics reduced. Rejoin to restore.",
            Duration = 3,
            Icon = "zap",
        })
    end
})

AFKTab:Paragraph({
    Title = "Note",
    Desc = "Performance Mode disables shadows, effects, and reduces material quality. Rejoin the game to restore normal graphics.",
})

local AfktyTab = Window:Tab({
    Title = "Afkty",
    Icon = "bell",
})

getgenv().AfktyUserToken = "" getgenv().AfktyConnected = false

local AFKTY_HUB_KEY = "hub_live_a9dda553c7d801ec28390081179dc35579ddd3ac1a78e2e8"

getgenv().AfktyOnPlayerJoin = "Nothing" getgenv().AfktyOnOreFound = "Nothing" getgenv().AfktyOnLevelUp = "Nothing" 
local Afkty = loadstring(game:HttpGet("https://raw.githubusercontent.com/nouralddin-abdullah/Airlines/refs/heads/main/afkty-v3.luau"))()
local afktyLoadSuccess = Afkty ~= nil

print("[AFKTY] SDK loaded:", afktyLoadSuccess)
print("[AFKTY] Afkty object:", Afkty)

local AfktyUI = {}

local function UpdateAfktyStatus(connected, extra)
    getgenv().AfktyConnected = connected
    if connected then
        AfktyUI.statusParagraph:SetDesc("🟢 Connected" .. (extra and (" - " .. extra) or ""))
    else
        AfktyUI.statusParagraph:SetDesc("🔴 Disconnected")
    end
end

local function IsAfktyConnected()
    if not Afkty then return false end
    if getgenv().AfktyConnected then return true end
    if Afkty.IsConnected and Afkty:IsConnected() then return true end
    return false
end

AfktyTab:Section({
    Title = "Information",
    Icon = "info",
})

AfktyTab:Paragraph({
    Title = "What is Afkty?",
    Desc = "Get alerts on your phone when your Roblox script crashes or gets kicked.",
})

AfktyTab:Button({
    Title = "Discord",
    Desc = "Join Discord to get the Afkty mobile app",
    Callback = function()
        setclipboard("https://discord.gg/afkty")
        WindUI:Notify({
            Title = "Discord Link Copied!",
            Content = "Join: https://discord.gg/afkty",
            Duration = 3,
            Icon = "clipboard-check",
        })
    end
})

AfktyTab:Divider()

AfktyTab:Section({
    Title = "Connection",
    Icon = "wifi",
})

AfktyUI.statusParagraph = AfktyTab:Paragraph({
    Title = "Status",
    Desc = afktyLoadSuccess and "⚪ Not Connected" or "❌ SDK Failed to Load",
})

AfktyTab:Input({
    Title = "User Token",
    Desc = "Your 6-character key from Afkty mobile app (e.g. ABC123)",
    Value = getgenv().AfktyUserToken,
    Placeholder = "ABC123",
    Callback = function(value)
        getgenv().AfktyUserToken = value
    end
})

AfktyTab:Button({
    Title = "Connect",
    Desc = "Connect to Afkty server",
    Callback = function()
        print("[AFKTY] Connect button clicked!")
        
        if not Afkty then
            print("[AFKTY] ERROR: SDK is nil!")
            WindUI:Notify({
                Title = "Afkty Error",
                Content = "SDK failed to load",
                Duration = 5,
                Icon = "alert-circle",
            })
            return
        end
        
        print("[AFKTY] SDK exists, checking token...")
        local token = getgenv().AfktyUserToken
        print("[AFKTY] Token value:", token, "Type:", type(token))
        
        if token == nil or token == "" then
            print("[AFKTY] ERROR: Token is empty or nil!")
            WindUI:Notify({
                Title = "Afkty Error",
                Content = "Please enter your 6-character User Token",
                Duration = 5,
                Icon = "alert-circle",
            })
            return
        end
        
        print("[AFKTY] Token OK, updating status...")
        
                local statusOk, statusErr = pcall(function()
            AfktyUI.statusParagraph:SetDesc("🟡 Connecting...")
        end)
        print("[AFKTY] Status update:", statusOk, statusErr)
        
        print("[AFKTY] Setting up event handlers...")
        
                print("[AFKTY] OnConnected exists:", Afkty.OnConnected ~= nil)
        print("[AFKTY] OnError exists:", Afkty.OnError ~= nil)
        
                local evtOk, evtErr = pcall(function()
            Afkty.OnConnected:Connect(function()
                print("[AFKTY] Connected!")
                UpdateAfktyStatus(true)
                WindUI:Notify({
                    Title = "Afkty Connected",
                    Content = "Mobile notifications enabled",
                    Duration = 3,
                    Icon = "check-circle",
                })
            end)
            
            Afkty.OnDisconnected:Connect(function()
                print("[AFKTY] Disconnected!")
                UpdateAfktyStatus(false)
            end)
            
            Afkty.OnCommand:Connect(function(data)
                print("[AFKTY] Command received:", data.command)
                if data.command == "stop" then
                    WindUI:Notify({
                        Title = "Remote Command",
                        Content = "Stop command received from mobile",
                        Duration = 5,
                        Icon = "smartphone",
                    })
                    Afkty:Disconnect("Stopped by user")
                end
            end)
            
            Afkty.OnError:Connect(function(data)
                print("[AFKTY] Error:", data.code, data.message)
                local errorMsg = data.message or "Unknown error"
                
                if data.code == "INVALID_HUB_KEY" then
                    errorMsg = "Hub key is wrong"
                elseif data.code == "HUB_NOT_APPROVED" then
                    errorMsg = "Hub pending approval"
                elseif data.code == "INVALID_USER_TOKEN" then
                    errorMsg = "User key is wrong"
                end
                
                WindUI:Notify({
                    Title = "Afkty Error",
                    Content = errorMsg,
                    Duration = 5,
                    Icon = "alert-circle",
                })
                UpdateAfktyStatus(false)
            end)
        end)
        
        print("[AFKTY] Event setup:", evtOk, evtErr)
        
        if not evtOk then
            print("[AFKTY] Event setup FAILED:", evtErr)
            WindUI:Notify({
                Title = "Afkty Error",
                Content = "Event setup failed: " .. tostring(evtErr),
                Duration = 5,
                Icon = "alert-circle",
            })
            return
        end
        
                print("[AFKTY] Calling Init...")
        print("[AFKTY] Hub Key:", AFKTY_HUB_KEY)
        print("[AFKTY] User Token:", token)
        
        local initOk, initErr = pcall(function()
            Afkty:Init({
                hubKey = AFKTY_HUB_KEY,
                userToken = token,
                debug = true
            })
        end)
        
        if initOk then
            print("[AFKTY] Init called successfully!")
        else
            print("[AFKTY] Init FAILED:", initErr)
            WindUI:Notify({
                Title = "Afkty Error",
                Content = "Init failed: " .. tostring(initErr),
                Duration = 5,
                Icon = "alert-circle",
            })
            UpdateAfktyStatus(false)
            return
        end
        
                task.spawn(function()
            task.wait(3)
            if IsAfktyConnected() then
                Afkty:SetStatus("Forge Script Active")
            end
        end)
    end
})

AfktyTab:Button({
    Title = "Disconnect",
    Desc = "Disconnect from Afkty server",
    Callback = function()
        if Afkty and IsAfktyConnected() then
            Afkty:Disconnect("Manual disconnect")
            UpdateAfktyStatus(false)
            WindUI:Notify({
                Title = "Afkty",
                Content = "Disconnected from server",
                Duration = 3,
                Icon = "info",
            })
        else
            WindUI:Notify({
                Title = "Afkty",
                Content = "Not currently connected",
                Duration = 3,
                Icon = "info",
            })
        end
    end
})

AfktyTab:Divider()

AfktyTab:Section({
    Title = "Test",
    Icon = "bell",
})

AfktyTab:Button({
    Title = "Send Test Notification",
    Desc = "Afkty:Notify(title, message)",
    Callback = function()
        if IsAfktyConnected() then
            Afkty:Notify("Test Notification", "Afkty is working!")
            WindUI:Notify({
                Title = "Afkty",
                Content = "Test notification sent",
                Duration = 3,
                Icon = "check-circle",
            })
        else
            WindUI:Notify({
                Title = "Afkty Error",
                Content = "Not connected",
                Duration = 3,
                Icon = "alert-circle",
            })
        end
    end
})

AfktyTab:Button({
    Title = "Send Test Alert",
    Desc = "Afkty:Alert(reason) - Critical with alarm",
    Callback = function()
        if IsAfktyConnected() then
            Afkty:Alert("This is a test alert!")
            WindUI:Notify({
                Title = "Afkty",
                Content = "Test alert sent",
                Duration = 3,
                Icon = "check-circle",
            })
        else
            WindUI:Notify({
                Title = "Afkty Error",
                Content = "Not connected",
                Duration = 3,
                Icon = "alert-circle",
            })
        end
    end
})

AfktyTab:Button({
    Title = "Send Test Log",
    Desc = "Afkty:Log(message, level)",
    Callback = function()
        if IsAfktyConnected() then
            Afkty:Log("Test log message from Forge script")
            WindUI:Notify({
                Title = "Afkty",
                Content = "Test log sent",
                Duration = 3,
                Icon = "check-circle",
            })
        else
            WindUI:Notify({
                Title = "Afkty Error",
                Content = "Not connected",
                Duration = 3,
                Icon = "alert-circle",
            })
        end
    end
})

AfktyTab:Divider()

AfktyTab:Section({
    Title = "Auto Notifications",
    Icon = "bell-ring",
})

AfktyTab:Dropdown({
    Title = "On Player Join",
    Desc = "Notify when a new player joins the server",
    Values = { "Nothing", "Notify", "Log" },
    Value = "Nothing",
    Callback = function(option)
        getgenv().AfktyOnPlayerJoin = option
    end
})

AfktyTab:Dropdown({
    Title = "On Found Selected Ores",
    Desc = "Notify when a selected ore is collected",
    Values = { "Nothing", "Notify", "Log" },
    Value = "Nothing",
    Callback = function(option)
        getgenv().AfktyOnOreFound = option
    end
})

AfktyTab:Dropdown({
    Title = "On Level Up",
    Desc = "Notify when you level up",
    Values = { "Nothing", "Notify", "Log" },
    Value = "Nothing",
    Callback = function(option)
        getgenv().AfktyOnLevelUp = option
    end
})

Players.PlayerAdded:Connect(function(player)
    if not IsAfktyConnected() then return end
    if getgenv().AfktyOnPlayerJoin == "Nothing" then return end
    
    local message = player.Name .. " joined the server"
    if getgenv().AfktyOnPlayerJoin == "Notify" then
        Afkty:Notify("Player Joined", message)
    elseif getgenv().AfktyOnPlayerJoin == "Log" then
        Afkty:Log(message)
    end
end)

task.spawn(function()
    local success, err = pcall(function()
        local Knit = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"))
        Knit.OnStart():await()
        local PlayerController = Knit.GetController("PlayerController")
        if PlayerController and PlayerController.Replica then
                        PlayerController.Replica:OnSet({ "Level" }, function(newLevel, oldLevel)
                if not IsAfktyConnected() then return end
                if getgenv().AfktyOnLevelUp == "Nothing" then return end
                
                local message = "Level " .. (oldLevel or "?") .. " → " .. newLevel
                if getgenv().AfktyOnLevelUp == "Notify" then
                    Afkty:Notify("🎉 Level Up!", message)
                elseif getgenv().AfktyOnLevelUp == "Log" then
                    Afkty:Log("Level Up: " .. message)
                end
            end)
            
                        PlayerController.Replica:OnWrite("GiveItem", function(item, amount)
                if not IsAfktyConnected() then return end
                if getgenv().AfktyOnOreFound == "Nothing" then return end
                if typeof(item) ~= "string" then return end
                
                                local isSelected = false
                for _, selectedOre in pairs(getgenv().SelectedOres or {}) do
                    if item == selectedOre then
                        isSelected = true
                        break
                    end
                end
                
                if not isSelected then return end
                
                local message = "Collected " .. item .. (amount and amount > 1 and (" x" .. amount) or "")
                if getgenv().AfktyOnOreFound == "Notify" then
                    Afkty:Notify("⛏️ Ore Found", message)
                elseif getgenv().AfktyOnOreFound == "Log" then
                    Afkty:Log(message)
                end
            end)
        end
    end)
    if not success then
        warn("[Afkty] Failed to hook game events:", err)
    end
end)

getgenv().AfktyConnections = getgenv().AfktyConnections or {}

task.spawn(function()
    local GuiService = game:GetService("GuiService")
    local CoreGui = game:GetService("CoreGui")

    if getgenv().AfktyConnections.errorChanged then
        getgenv().AfktyConnections.errorChanged:Disconnect()
    end
    getgenv().AfktyConnections.errorChanged =
        GuiService.ErrorMessageChanged:Connect(function()
            if IsAfktyConnected() then
                local errorMsg = GuiService:GetErrorMessage()
                if errorMsg and errorMsg ~= "" then
                    Afkty:Alert(errorMsg)
                end
            end
        end)

    if getgenv().AfktyConnections.idleWarn then
        getgenv().AfktyConnections.idleWarn:Disconnect()
    end
    getgenv().AfktyConnections.idleWarn =
        LocalPlayer.Idled:Connect(function()
            if IsAfktyConnected() and not getgenv().AntiAfkEnabled then
                Afkty:Alert("Player went idle - may be kicked soon")
            end
        end)

    if getgenv().AfktyConnections.promptChild then
        getgenv().AfktyConnections.promptChild:Disconnect()
    end
    pcall(function()
        local overlay = CoreGui.RobloxPromptGui.promptOverlay
        getgenv().AfktyConnections.promptChild =
            overlay.ChildAdded:Connect(function(child)
                task.wait(0.5)
                if child.Name == "ErrorPrompt" and IsAfktyConnected() then
                    local errorText = "Kicked from game"
                    pcall(function()
                        errorText = child.MessageArea.ErrorFrame.ErrorMessage.Text
                    end)
                    Afkty:Alert(errorText)
                end
            end)
    end)
end)

local SettingsTab = Window:Tab({
    Title = "Settings",
    Icon = "settings",
})

local SCRIPT_URL = "https://raw.githubusercontent.com/nouralddin-abdullah/Airlines/refs/heads/main/Forge.lua"

getgenv().AutoExecuteOnTeleport = false

SettingsTab:Section({
    Title = "UI Settings",
    Icon = "palette",
})

SettingsTab:Dropdown({
    Title = "Theme",
    Desc = "Change the UI theme",
    Values = { "Dark", "Light", "Darker", "Aqua", "Amethyst" },
    Value = "Dark",
    Flag = "UITheme",
    Callback = function(option)
        WindUI:SetTheme(option)
    end
})

SettingsTab:Dropdown({
    Title = "Toggle Key",
    Desc = "Key to show/hide the UI",
    Values = { "RightControl", "RightShift", "LeftAlt", "F1", "F2", "F3" },
    Value = "RightControl",
    Flag = "ToggleKey",
    Callback = function(option)
        local keyMap = {
            ["RightControl"] = Enum.KeyCode.RightControl,
            ["RightShift"] = Enum.KeyCode.RightShift,
            ["LeftAlt"] = Enum.KeyCode.LeftAlt,
            ["F1"] = Enum.KeyCode.F1,
            ["F2"] = Enum.KeyCode.F2,
            ["F3"] = Enum.KeyCode.F3,
        }
        Window:SetToggleKey(keyMap[option])
    end
})

SettingsTab:Toggle({
    Title = "Auto Execute on Teleport",
    Desc = "Re-run script automatically after server hop",
    Value = false,
    Callback = function(state)
        getgenv().AutoExecuteOnTeleport = state
        if state then
                        local queueScript = [[
                local placeId = game.PlaceId
                local WORLD_1 = 76558904092080
                local WORLD_2 = 129009554587176
                if placeId == WORLD_1 or placeId == WORLD_2 then
                    loadstring(game:HttpGet("]] .. SCRIPT_URL .. [["))()
                end
            ]]
            
            if queue_on_teleport then
                queue_on_teleport(queueScript)
                WindUI:Notify({
                    Title = "Auto Execute Enabled",
                    Content = "Script will re-run after teleport",
                    Duration = 3,
                    Icon = "check-circle",
                })
            elseif syn and syn.queue_on_teleport then
                syn.queue_on_teleport(queueScript)
                WindUI:Notify({
                    Title = "Auto Execute Enabled",
                    Content = "Script will re-run after teleport",
                    Duration = 3,
                    Icon = "check-circle",
                })
            elseif fluxus and fluxus.queue_on_teleport then
                fluxus.queue_on_teleport(queueScript)
                WindUI:Notify({
                    Title = "Auto Execute Enabled",
                    Content = "Script will re-run after teleport",
                    Duration = 3,
                    Icon = "check-circle",
                })
            else
                WindUI:Notify({
                    Title = "Not Supported",
                    Content = "Your executor doesn't support queue_on_teleport",
                    Duration = 5,
                    Icon = "alert-circle",
                })
            end
        else
            WindUI:Notify({
                Title = "Auto Execute Disabled",
                Content = "Script won't re-run after teleport",
                Duration = 2,
                Icon = "x-circle",
            })
        end
    end
})

SettingsTab:Section({
    Title = "Teleport",
    Icon = "map-pin",
})

SettingsTab:Button({
    Title = "Stonewake's Cross",
    Desc = "Teleport to the first island",
    Callback = function()
        pcall(function()
            local Knit = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"))
            Knit.OnStart():await()
            local PortalService = Knit.GetService("PortalService")
            PortalService:TeleportToIsland("Stonewake's Cross"):await()
        end)
        WindUI:Notify({
            Title = "Teleporting",
            Content = "Teleporting to Stonewake's Cross...",
            Duration = 3,
            Icon = "map-pin",
        })
    end
})

SettingsTab:Button({
    Title = "Forgotten Kingdom",
    Desc = "Teleport to the second island (Requires Level 10)",
    Callback = function()
        pcall(function()
            local Knit = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"))
            Knit.OnStart():await()
            local PortalService = Knit.GetService("PortalService")
            PortalService:TeleportToIsland("Forgotten Kingdom"):await()
        end)
        WindUI:Notify({
            Title = "Teleporting",
            Content = "Teleporting to Forgotten Kingdom...",
            Duration = 3,
            Icon = "map-pin",
        })
    end
})

SettingsTab:Divider()

SettingsTab:Section({
    Title = "About",
    Icon = "info",
})

SettingsTab:Button({
    Title = "Version Info",
    Desc = "Forge Automation - ToastyHub",
    Callback = function()
        WindUI:Notify({
            Title = "Forge Auto",
            Content = "ToastyHub Forge",
            Duration = 5,
            Icon = "info",
        })
    end
})


local ForgeGui = PlayerGui:WaitForChild("Forge", 60)
if not ForgeGui then
    WindUI:Notify({
        Title = "Error",
        Content = "Forge GUI not found! Script may not work properly.",
        Duration = 5,
        Icon = "alert-circle",
    })
    return
end

local MeltMinigame = ForgeGui:WaitForChild("MeltMinigame", 10)
local PourMinigame = ForgeGui:WaitForChild("PourMinigame", 10)
local HammerMinigame = ForgeGui:WaitForChild("HammerMinigame", 10)

getgenv().SkipToHammerHooked = getgenv().SkipToHammerHooked or false
getgenv().OriginalChangeSequence = getgenv().OriginalChangeSequence or nil

task.spawn(function()
        if getgenv().SkipToHammerHooked then
        return
    end
    
    local Shared = ReplicatedStorage:WaitForChild("Shared")
    local Packages = Shared:WaitForChild("Packages")
    local Knit = require(Packages:WaitForChild("Knit"))
    local Utils = require(Shared:WaitForChild("Utils"))
    
    Knit.OnStart():await()
    
    local ForgeController = Knit.GetController("ForgeController")
    local UIController = Knit.GetController("UIController")
    local ForgeService = Knit.GetService("ForgeService")
    
    if not ForgeController then
        warn("[SkipToHammer] ForgeController not found!")
        return
    end
    
        if not getgenv().OriginalChangeSequence then
        getgenv().OriginalChangeSequence = ForgeController.ChangeSequence
    end
    local originalChangeSequence = getgenv().OriginalChangeSequence
    
        getgenv().SkipToHammerHooked = true
    
    ForgeController.ChangeSequence = function(self, sequenceName, data, ...)
                if getgenv().SkipToHammer and sequenceName == "Melt" then
            task.spawn(function()
                                local _, meltResponse = ForgeService:ChangeSequence("Melt", {
                    ["Ores"] = self.Ores,
                    ["ItemType"] = self.ItemType,
                    ["FastForge"] = true                  }):await()
                
                if not meltResponse then
                    warn("[SkipToHammer] Melt failed, falling back to normal")
                    originalChangeSequence(self, "OreSelect")
                    return
                end
                
                                pcall(function()
                    PlayerGui:WaitForChild("Forge").OreSelect.Visible = false
                end)
                
                                pcall(function()
                    if UIController.Modules.Forge.physicalOres then
                        for _, ore in pairs(UIController.Modules.Forge.physicalOres) do
                            ore:Destroy()
                        end
                    end
                end)
                
                                pcall(function()
                    self.Music = Utils:PlaySound("General", "Forge Music", false)
                    if self.Music then
                        self.Music.Parent = workspace.Debris
                        self.Music.Volume = 0
                        TweenService:Create(self.Music, TweenInfo.new(2.5, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {
                            ["Volume"] = 0.1
                        }):Play()
                    end
                end)
                
                                if meltResponse.FastForge then
                    originalChangeSequence(self, "Hammer")
                    return
                end
                
                                                                                                local meltStartTime = meltResponse.MinigameData and meltResponse.MinigameData.StartTime or workspace:GetServerTimeNow()
                local meltRequiredTime = meltResponse.MinigameData and meltResponse.MinigameData.RequiredTime or 5
                local perfectMeltClientTime = meltStartTime + meltRequiredTime
                
                                                local _, pourResponse = ForgeService:ChangeSequence("Pour", {
                    ["ClientTime"] = perfectMeltClientTime
                }):await()
                if not pourResponse then
                    local meltWait = perfectMeltClientTime - workspace:GetServerTimeNow()
                    if meltWait > 0 then
                        task.wait(meltWait)
                    end
                    _, pourResponse = ForgeService:ChangeSequence("Pour", {
                        ["ClientTime"] = perfectMeltClientTime
                    }):await()
                end
                
                if not pourResponse then
                    warn("[SkipToHammer] Pour failed!")
                    originalChangeSequence(self, "OreSelect")
                    return
                end
                
                                local pourStartTime = pourResponse.MinigameData and pourResponse.MinigameData.StartTime or workspace:GetServerTimeNow()
                local pourRequiredTime = pourResponse.MinigameData and pourResponse.MinigameData.RequiredTime or 5
                local perfectPourClientTime = pourStartTime + pourRequiredTime
                
                local _, hammerResponse = ForgeService:ChangeSequence("Hammer", {
                    ["ClientTime"] = perfectPourClientTime
                }):await()
                if not hammerResponse then
                    local pourWait = perfectPourClientTime - workspace:GetServerTimeNow()
                    if pourWait > 0 then
                        task.wait(pourWait)
                    end
                    _, hammerResponse = ForgeService:ChangeSequence("Hammer", {
                        ["ClientTime"] = perfectPourClientTime
                    }):await()
                end
                
                if not hammerResponse then
                    warn("[SkipToHammer] Hammer failed!")
                    originalChangeSequence(self, "OreSelect")
                    return
                end
                
                                pcall(function()
                    UIController.Modules.Forge:ChangeSequence("Hammer", hammerResponse)
                end)
                
                                pcall(function()
                    self:ChangeCamera("Hammer", self.Station.Cameras.HammerSequence, {
                        ["tweenInfo"] = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
                    })
                end)
                
                                task.spawn(function()
                    pcall(function()
                        TweenService:Create(PlayerGui.Forge.Vignette, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {
                            ["ImageTransparency"] = 0.5
                        }):Play()
                    end)
                    
                    local clientTime, item, originalPartData = self.Minigames.HammerMinigame:Start(hammerResponse.MinigameData)
                    self.Item = item
                    self.OriginalPartData = originalPartData
                    
                    task.wait(4)
                    originalChangeSequence(self, "Water", {
                        ["ClientTime"] = clientTime - 4
                    })
                end)
            end)
            
            return         end
        
                return originalChangeSequence(self, sequenceName, data, ...)
    end

            task.spawn(function()
        local hammerModule
        for _ = 1, 120 do
            hammerModule = ForgeController.Minigames and ForgeController.Minigames.HammerMinigame
            if hammerModule and type(hammerModule) == "table" and type(hammerModule.Start) == "function" then
                break
            end
            task.wait(0.5)
        end
        if not hammerModule or hammerModule.__HammerHookInstalled then
            return
        end
        hammerModule.__HammerHookInstalled = true

                if not getgenv().OriginalHammerStart then
            getgenv().OriginalHammerStart = hammerModule.Start
        end
        local originalStart = getgenv().OriginalHammerStart
        
        hammerModule.Start = function(self2, startData, ...)
            local results = {originalStart(self2, startData, ...)}
            return table.unpack(results)
        end
    end)
end)

getgenv().meltConnection = getgenv().meltConnection or nil
getgenv().meltActive = getgenv().meltActive or false

local function AutomateMelt()
    if getgenv().meltConnection then getgenv().meltConnection:Disconnect() end
    if getgenv().meltActive then return end
    getgenv().meltActive = true
    
    local Heater = MeltMinigame:FindFirstChild("Heater")
    if not Heater then getgenv().meltActive = false return end
    local TopButton = Heater:FindFirstChild("Top")
    if not TopButton then getgenv().meltActive = false return end
    
    local function fireMouseDown()
        pcall(function()
            for _, conn in pairs(getconnections(TopButton.MouseButton1Down)) do
                conn:Fire()
            end
        end)
    end
    
    local pumpPhase = 0
    
    getgenv().meltConnection = RunService.Heartbeat:Connect(function(dt)
        if not MeltMinigame.Visible then
            if getgenv().meltConnection then getgenv().meltConnection:Disconnect() getgenv().meltConnection = nil end
            getgenv().meltActive = false
            return
        end
        
        if not getgenv().AutoMelt then return end
        
        fireMouseDown()
        
        pumpPhase = pumpPhase + dt * 3
        local targetY = 0.05 + (math.sin(pumpPhase) + 1) / 2 * 0.7
        
        pcall(function()
            TopButton.Position = UDim2.new(TopButton.Position.X.Scale, 0, targetY, 0)
        end)
    end)
end

getgenv().pourConnection = getgenv().pourConnection or nil
getgenv().pourActive = getgenv().pourActive or false
getgenv().originalAreaSize = getgenv().originalAreaSize or nil

local function AutomatePour()
    if getgenv().pourActive then return end
    getgenv().pourActive = true
    
    local Frame = PourMinigame:FindFirstChild("Frame")
    if not Frame then getgenv().pourActive = false return end
    local Area = Frame:FindFirstChild("Area")
    
    if not Area then getgenv().pourActive = false return end
    
    getgenv().originalAreaSize = Area.Size
    Area.Size = UDim2.new(1, 0, 1.12, 0)
end

PourMinigame:GetPropertyChangedSignal("Visible"):Connect(function()
    if PourMinigame.Visible and getgenv().AutoPour then
        task.delay(0.1, AutomatePour)
    elseif not PourMinigame.Visible then
        if getgenv().originalAreaSize then
            local Frame = PourMinigame:FindFirstChild("Frame")
            if Frame then
                local Area = Frame:FindFirstChild("Area")
                if Area then
                    Area.Size = getgenv().originalAreaSize
                end
            end
            getgenv().originalAreaSize = nil
        end
        getgenv().pourActive = false
    end
end)

getgenv().hammerConnection = getgenv().hammerConnection or nil
getgenv().hammerActive = getgenv().hammerActive or false
getgenv().clickedNotes = getgenv().clickedNotes or {}

local function AutomateHammer()
        if getgenv().hammerConnection then 
        getgenv().hammerConnection:Disconnect() 
        getgenv().hammerConnection = nil 
    end
    getgenv().hammerActive = false
    getgenv().clickedNotes = {}     
    task.wait(0.1)     
    getgenv().hammerActive = true
    
    task.wait(2)
    
    local moldClicks = 0
    local moldDestroyed = false
    local lastMoldClick = 0
    
    print("[AutoHammer] Started - waiting for mold and circles")
    
    getgenv().hammerConnection = RunService.Heartbeat:Connect(function()
        if not HammerMinigame.Visible then
            if getgenv().hammerConnection then getgenv().hammerConnection:Disconnect() getgenv().hammerConnection = nil end
            getgenv().hammerActive = false
            moldDestroyed = false
            moldClicks = 0
            getgenv().clickedNotes = {}
            print("[AutoHammer] Stopped - HammerMinigame no longer visible")
            return
        end
        
        local forgeExists = false
        pcall(function()
            if workspace:FindFirstChild("Debris") and (#workspace.Debris:GetChildren() > 0 or moldDestroyed) then
                forgeExists = true
            end
        end)
        
        if not forgeExists and moldDestroyed then
            if getgenv().hammerConnection then getgenv().hammerConnection:Disconnect() getgenv().hammerConnection = nil end
            getgenv().hammerActive = false
            getgenv().clickedNotes = {}
            print("[AutoHammer] Stopped - forge no longer exists")
            return
        end
        
        if not getgenv().AutoHammer then return end
        
        local now = tick()
        
                if not moldDestroyed and now - lastMoldClick > 0.2 then
            pcall(function()
                local debris = workspace:FindFirstChild("Debris")
                if debris then
                    for _, model in pairs(debris:GetChildren()) do
                        if model:IsA("Model") and model.Name == "Mold" and not model:GetAttribute("IsDestroyed") then
                            local clickDetector = model:FindFirstChildOfClass("ClickDetector", true)
                            if clickDetector then
                                if fireclickdetector then
                                    fireclickdetector(clickDetector)
                                    moldClicks = moldClicks + 1
                                    lastMoldClick = now
                                    print("[AutoHammer] Clicked mold:", moldClicks, "/3")
                                    
                                    if moldClicks >= 3 then
                                        moldDestroyed = true
                                        print("[AutoHammer] Mold destroyed, now detecting circles")
                                    end
                                end
                            end
                        end
                    end
                end
            end)
        end
        
                for _, child in pairs(HammerMinigame:GetChildren()) do
            if child:IsA("TextButton") and child.Name == "Frame" and child.Visible and not getgenv().clickedNotes[child] then
                getgenv().clickedNotes[child] = true
                local frame = child:FindFirstChild("Frame")
                if frame and frame:IsA("ImageLabel") then
                    local circle = frame:FindFirstChild("Circle")
                    if circle and circle:IsA("ImageLabel") then
                        print("[AutoHammer] Found new circle, tracking...")
                        task.spawn(function()
                            local noteStartTime = tick()
                            local clicked = false
                            
                            while tick() - noteStartTime < 3 and not clicked and child.Parent do
                                pcall(function()
                                    local circleSize = circle.Size.Y.Scale
                                    local frameSize = frame.Size.Y.Scale
                                    local sizeDifference = math.abs(circleSize - frameSize)
                                    
                                                                        if sizeDifference < 0.05 and not clicked then
                                        clicked = true
                                        print("[AutoHammer] Clicking circle! sizeDiff:", sizeDifference)
                                        pcall(function()
                                            for _, conn in pairs(getconnections(child.MouseButton1Down)) do
                                                conn:Fire()
                                            end
                                            for _, conn in pairs(getconnections(child.MouseButton1Up)) do
                                                conn:Fire()
                                            end
                                            for _, conn in pairs(getconnections(child.MouseButton1Click)) do
                                                conn:Fire()
                                            end
                                        end)
                                    end
                                end)
                                
                                task.wait(0.03)
                            end
                            
                            if not clicked then
                                print("[AutoHammer] Circle timed out without click")
                            end
                        end)
                    end
                end
            end
        end
    end)
end

MeltMinigame:GetPropertyChangedSignal("Visible"):Connect(function()
    if MeltMinigame.Visible and getgenv().AutoMelt then
        task.delay(0.3, AutomateMelt)
    elseif not MeltMinigame.Visible then
        if getgenv().meltConnection then getgenv().meltConnection:Disconnect() getgenv().meltConnection = nil end
        getgenv().meltActive = false
    end
end)

HammerMinigame:GetPropertyChangedSignal("Visible"):Connect(function()
    if HammerMinigame.Visible and getgenv().AutoHammer then
        print("[AutoHammer] HammerMinigame visible, starting automation")
        task.delay(0.3, AutomateHammer)
    elseif not HammerMinigame.Visible then
        print("[AutoHammer] HammerMinigame hidden, cleaning up")
        if getgenv().hammerConnection then getgenv().hammerConnection:Disconnect() getgenv().hammerConnection = nil end
        getgenv().hammerActive = false
        getgenv().clickedNotes = {}     end
end)

WindUI:Notify({
    Title = "Forge Auto Loaded",
    Content = "Press RightControl to toggle UI\nAll automations are enabled!",
    Duration = 5,
    Icon = "check-circle",
})

ForgeTab:Select()

local mobConnection = nil
local noClipConnection = nil
local currentTarget = nil
local attackRemote = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated")

local function SetNoClip(enabled)
    local character = LocalPlayer.Character
    if not character then return end
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = not enabled
        end
    end
end

noClipConnection = RunService.Stepped:Connect(function()
    if getgenv().NoClipEnabled then
        SetNoClip(true)
    end
end)

Helpers.IsInWorld2 = function()
    local proximity = workspace:FindFirstChild("Proximity")
    return proximity and proximity:FindFirstChild("Captain Rowan") ~= nil
end

Helpers.GetMobBaseName = function(fullName) return fullName:gsub("%d+$", "") end

Helpers.IsMobSelected = function(mobName)
    local baseName = Helpers.GetMobBaseName(mobName)
    for _, selectedMob in pairs(getgenv().SelectedMobs) do
        local selectedName = type(selectedMob) == "table" and selectedMob.Title or selectedMob
        if baseName == selectedName then return true end
    end
    return false
end

local function IsMobInSelectedArea(mob)
    if not getgenv().FilterMobByArea then return true end
    if #getgenv().SelectedMobAreas == 0 then return true end
    
    local MobSpawns = workspace:FindFirstChild("Debris") and workspace.Debris:FindFirstChild("MobSpawns")
    if not MobSpawns then return true end
    
    for _, areaName in pairs(getgenv().SelectedMobAreas) do
        local areaFolder = MobSpawns:FindFirstChild(areaName)
        if areaFolder then
            for _, spawnLocation in pairs(areaFolder:GetChildren()) do
                local spawnedObject = spawnLocation:FindFirstChild("SpawnedObject")
                if spawnedObject and spawnedObject.Value == mob then
                    return true
                end
            end
        end
    end
    return false
end

local function GetClosestSelectedMob()
    local Living = workspace:FindFirstChild("Living")
    if not Living then return nil end
    
    local character = LocalPlayer.Character
    if not character then return nil end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local bestMob = nil
    local bestValue = nil     local priority = getgenv().MobPriority or "Nearest"
    
    for _, mob in pairs(Living:GetChildren()) do
        if mob:IsA("Model") and Helpers.IsMobSelected(mob.Name) and IsMobInSelectedArea(mob) then
            local mobHRP = mob:FindFirstChild("HumanoidRootPart") or mob:FindFirstChild("Torso") or mob.PrimaryPart
            local humanoid = mob:FindFirstChildOfClass("Humanoid")
            
            if mobHRP and humanoid and humanoid.Health > 0 then
                local distance = (hrp.Position - mobHRP.Position).Magnitude
                local health = humanoid.Health
                local isBetter = false
                
                if priority == "Nearest" then
                    if bestValue == nil or distance < bestValue then
                        bestValue = distance
                        isBetter = true
                    end
                elseif priority == "Weakest" then
                    if bestValue == nil or health < bestValue then
                        bestValue = health
                        isBetter = true
                    end
                elseif priority == "Strongest" then
                    if bestValue == nil or health > bestValue then
                        bestValue = health
                        isBetter = true
                    end
                end
                
                if isBetter then
                    bestMob = mob
                end
            end
        end
    end
    
    return bestMob
end

local function IsMobAlive(mob)
    if not mob or not mob.Parent then return false end
    local humanoid = mob:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.Health > 0
end

local lastAttackTime = 0
local bodyVelocity = nil
local bodyGyro = nil

local mobFlightPhase = "idle" local mobFlightStartY = 0
local mobLastTargetId = nil

local function SetupFly(hrp)
        if bodyVelocity then bodyVelocity:Destroy() end
    if bodyGyro then bodyGyro:Destroy() end
    
        bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = hrp
    
        bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    bodyGyro.P = 10000
    bodyGyro.D = 100
    bodyGyro.Parent = hrp
    
    return bodyVelocity, bodyGyro
end

local function CleanupFly()
        pcall(function()
        if bodyVelocity and bodyVelocity.Parent then bodyVelocity:Destroy() end
    end)
    pcall(function()
        if bodyGyro and bodyGyro.Parent then bodyGyro:Destroy() end
    end)
    bodyVelocity = nil
    bodyGyro = nil
    
        pcall(function()
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.PlatformStand = false
            end
        end
    end)
end

local function StartMobAttack()
    if mobConnection then mobConnection:Disconnect() end
    
    mobConnection = RunService.Heartbeat:Connect(function()
        if not getgenv().AutoMob then
            currentTarget = nil
            CleanupFly()
            return
        end
        
        local character = LocalPlayer.Character
        if not character then return end
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        
                if not IsMobAlive(currentTarget) then
            currentTarget = GetClosestSelectedMob()
                        mobFlightPhase = "idle"
            mobLastTargetId = nil
            if not currentTarget then 
                if bodyVelocity then
                    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                end
                return 
            end
        end
        
                local mobHRP = currentTarget:FindFirstChild("HumanoidRootPart") or currentTarget:FindFirstChild("Torso") or currentTarget.PrimaryPart
        if not mobHRP then
            currentTarget = nil
            mobFlightPhase = "idle"
            return
        end
        
                local currentTargetId = tostring(currentTarget)
        if mobLastTargetId ~= currentTargetId then
            mobLastTargetId = currentTargetId
            mobFlightPhase = "idle"
            mobFlightStartY = hrp.Position.Y
        end
        
                local mobCFrame = mobHRP.CFrame
        local depthOffset = getgenv().MobDepthOffset or 0
        local targetPosition = (mobCFrame * CFrame.new(0, -depthOffset, getgenv().AttackDistance)).Position
        
                if not bodyVelocity or not bodyVelocity.Parent then
            SetupFly(hrp)
            if humanoid then
                humanoid.PlatformStand = true
            end
        end
        
                local flySpeed = getgenv().FlySpeed
        local antiGoblin = getgenv().AntiGoblinVillage
        local goblinHeight = getgenv().AntiGoblinHeight or 50
        
        if antiGoblin and mobFlightPhase == "idle" then
                        mobFlightPhase = "ascending"
            mobFlightStartY = hrp.Position.Y
        end
        
        if antiGoblin then
            local currentY = hrp.Position.Y
            local targetY = targetPosition.Y
            local safeY = math.max(mobFlightStartY, targetY) + goblinHeight
            
            if mobFlightPhase == "ascending" then
                                if currentY < safeY - 5 then
                    bodyVelocity.Velocity = Vector3.new(0, flySpeed, 0)
                    bodyGyro.CFrame = CFrame.new(hrp.Position, hrp.Position + Vector3.new(0, 1, 0))
                else
                    mobFlightPhase = "horizontal"
                end
            elseif mobFlightPhase == "horizontal" then
                                local horizontalTarget = Vector3.new(targetPosition.X, currentY, targetPosition.Z)
                local horizontalDir = (horizontalTarget - hrp.Position)
                local horizontalDist = horizontalDir.Magnitude
                
                if horizontalDist > 5 then
                    bodyVelocity.Velocity = horizontalDir.Unit * flySpeed
                    bodyGyro.CFrame = CFrame.new(hrp.Position, horizontalTarget)
                else
                    mobFlightPhase = "descending"
                end
            elseif mobFlightPhase == "descending" then
                                local direction = (targetPosition - hrp.Position)
                local distance = direction.Magnitude
                
                if distance > 1 then
                    bodyVelocity.Velocity = direction.Unit * flySpeed
                else
                    mobFlightPhase = "attacking"
                    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                end
                bodyGyro.CFrame = CFrame.new(hrp.Position, mobHRP.Position)
            else                                 local direction = (targetPosition - hrp.Position)
                local distance = direction.Magnitude
                
                if distance > 1 then
                    bodyVelocity.Velocity = direction.Unit * flySpeed
                else
                    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                end
                bodyGyro.CFrame = CFrame.new(hrp.Position, mobHRP.Position)
            end
        else
                        local direction = (targetPosition - hrp.Position)
            local distance = direction.Magnitude
            
            if distance > 1 then
                                bodyVelocity.Velocity = Helpers.GetSafeFlyVelocity(hrp.Position, targetPosition, flySpeed)
            else
                                bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
            
                        bodyGyro.CFrame = CFrame.new(hrp.Position, mobHRP.Position)
        end
        
                local now = tick()
        if now - lastAttackTime >= 0.3 then
            lastAttackTime = now
            pcall(function()
                attackRemote:InvokeServer("Weapon")
            end)
        end
    end)
end

LocalPlayer.CharacterAdded:Connect(function(character)
        local wasMobEnabled = getgenv().AutoMob
    local wasMineEnabled = getgenv().AutoMine
    
        getgenv().AutoMob = false
    getgenv().AutoMine = false
    getgenv().NoClipEnabled = false
    
        isDefending = false
    markedThreat = nil
    
        
        character:WaitForChild("HumanoidRootPart", 5)
    character:WaitForChild("Humanoid", 5)
    task.wait(1)
    
        if wasMobEnabled then
        getgenv().AutoMob = true
        getgenv().NoClipEnabled = true
    end
    
    if wasMineEnabled then
        getgenv().AutoMine = true
        getgenv().NoClipEnabled = true
    end
end)

StartMobAttack()

local mineConnection = nil
local currentRockTarget = nil
local mineBodyVelocity = nil
local mineBodyGyro = nil
local lastMineTime = 0
local skippedRocks = {} local occupiedRocks = {} local lastSkipNotifyTime = 0 local ROCK_OCCUPY_TIMEOUT = 10 local OCCUPIED_ROCK_BLACKLIST_TIME = 15 
local mineFlightPhase = "idle" local mineFlightStartY = 0
local mineLastTargetId = nil

local function SetupMiningNotificationHook()
    local success, result = pcall(function()
        local Knit = require(ReplicatedStorage.Shared.Packages.Knit)
        local NotifService = Knit.GetService("NotificationService")
        
        if NotifService and NotifService.Notify then
            NotifService.Notify:Connect(function(data)
                if type(data) == "table" and data.Text then
                    local text = string.lower(data.Text)
                                        if string.find(text, "already mining") or string.find(text, "someone else") then
                                                if currentRockTarget then
                            local lastHitPlayer = currentRockTarget:GetAttribute("LastHitPlayer")
                            
                                                        if lastHitPlayer and lastHitPlayer ~= LocalPlayer.Name then
                                                                occupiedRocks[currentRockTarget] = tick()
                                currentRockTarget = nil                             end
                                                    end
                    end
                end
            end)
            return true
        end
        return false
    end)
end

task.spawn(function()
    task.wait(2)     SetupMiningNotificationHook()
end)

local function IsRockBeingMined(rock)
    if not rock then return false end
    
    local lastHitPlayer = rock:GetAttribute("LastHitPlayer")
    local lastHitTime = rock:GetAttribute("LastHitTime")
    
        if not lastHitPlayer or not lastHitTime then
        return false
    end
    
        if lastHitPlayer == LocalPlayer.Name then
        return false
    end
    
        local currentTime = workspace:GetServerTimeNow()     local timeSinceHit = currentTime - lastHitTime
    
    if timeSinceHit <= ROCK_OCCUPY_TIMEOUT then
        return true     end
    
    return false end

local function IsRockBlacklisted(rock)
    if not rock then return false end
    
    local blacklistTime = occupiedRocks[rock]
    if not blacklistTime then return false end
    
        if tick() - blacklistTime > OCCUPIED_ROCK_BLACKLIST_TIME then
        occupiedRocks[rock] = nil
        return false
    end
    
    return true
end

local function CleanupOccupiedRocks()
    local now = tick()
    for rock, time in pairs(occupiedRocks) do
        if now - time > OCCUPIED_ROCK_BLACKLIST_TIME then
            occupiedRocks[rock] = nil
        end
    end
end

local isDefending = false
local lastDefendCheck = 0
local DEFEND_CHECK_INTERVAL = 0.5 local markedThreat = nil 
local function GetAttackingMobNearPosition(position, range)
    local Living = workspace:FindFirstChild("Living")
    if not Living then return nil end
    
    for _, mob in pairs(Living:GetChildren()) do
        if mob:IsA("Model") then
                        local isPlayer = false
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character == mob then
                    isPlayer = true
                    break
                end
            end
            if isPlayer then
                continue
            end
            
            local mobHRP = mob:FindFirstChild("HumanoidRootPart") or mob:FindFirstChild("Torso") or mob.PrimaryPart
            local mobHumanoid = mob:FindFirstChildOfClass("Humanoid")
            local status = mob:FindFirstChild("Status")
            
            if mobHRP and mobHumanoid and mobHumanoid.Health > 0 then
                local distance = (mobHRP.Position - position).Magnitude
                
                                if distance <= range and status and status:FindFirstChild("Attacking") then
                    return mob
                end
            end
        end
    end
    
    return nil
end

local function IsMarkedThreatValid()
    if not markedThreat then return false end
    if not markedThreat.Parent then return false end     
    local mobHumanoid = markedThreat:FindFirstChildOfClass("Humanoid")
    if not mobHumanoid or mobHumanoid.Health <= 0 then return false end     
    return true
end

local function ClearMarkedThreat()
    markedThreat = nil
end

local function KillThreat(threatMob)
    if not threatMob then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    
        local defendVelocity = Instance.new("BodyVelocity")
    defendVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    defendVelocity.Velocity = Vector3.new(0, 0, 0)
    defendVelocity.Parent = hrp
    
    local defendGyro = Instance.new("BodyGyro")
    defendGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    defendGyro.P = 10000
    defendGyro.D = 100
    defendGyro.Parent = hrp
    
    if humanoid then
        humanoid.PlatformStand = true
    end
    
    local startTime = tick()
    local maxKillTime = 30     local lastAttack = 0
    local mobDead = false
    
        local DEFEND_FLY_SPEED = 50
    local DEFEND_ATTACK_DISTANCE = 2
    local DEFEND_DEPTH = 0
    
        local defendConnection
    defendConnection = RunService.Heartbeat:Connect(function()
                if not character or not character.Parent then
            mobDead = true
            return
        end
        
                hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then 
            mobDead = true
            return
        end
        
                if not threatMob or not threatMob.Parent then
            mobDead = true
            return
        end
        
        local mobHumanoid = threatMob:FindFirstChildOfClass("Humanoid")
        if not mobHumanoid or mobHumanoid.Health <= 0 then
            mobDead = true
            return
        end
        
                if tick() - startTime > maxKillTime then
            mobDead = true
            return
        end
        
                local myHumanoid = character:FindFirstChildOfClass("Humanoid")
        if not myHumanoid or myHumanoid.Health <= 0 then
            mobDead = true
            return
        end
        
        local mobHRP = threatMob:FindFirstChild("HumanoidRootPart") or threatMob:FindFirstChild("Torso") or threatMob.PrimaryPart
        if not mobHRP then 
            mobDead = true
            return
        end
        
                local targetPosition = (mobHRP.CFrame * CFrame.new(0, -DEFEND_DEPTH, DEFEND_ATTACK_DISTANCE)).Position
        
        local direction = (targetPosition - hrp.Position)
        local distance = direction.Magnitude
        
        if distance > 1 then
            defendVelocity.Velocity = direction.Unit * DEFEND_FLY_SPEED
        else
            defendVelocity.Velocity = Vector3.new(0, 0, 0)
        end
        
                defendGyro.CFrame = CFrame.new(hrp.Position, mobHRP.Position)
        
                local now = tick()
        if now - lastAttack >= 0.3 then
            lastAttack = now
            pcall(function()
                attackRemote:InvokeServer("Weapon")
            end)
        end
    end)
    
        while not mobDead do
        task.wait(0.1)
    end
    
        if defendConnection then
        defendConnection:Disconnect()
    end
    
        pcall(function() if defendVelocity then defendVelocity:Destroy() end end)
    pcall(function() if defendGyro then defendGyro:Destroy() end end)
    
        ClearMarkedThreat()
    
        pcall(function()
        if character and character.Parent then
            local hum = character:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.PlatformStand = false
            end
        end
    end)
    
        task.wait(0.2)
end

local function ShouldDefend(rockPosition)
    if not getgenv().DefendWhileMining then return false, nil end
    
    local character = LocalPlayer.Character
    if not character then return false, nil end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false, nil end
    
        if IsMarkedThreatValid() then
                return true, markedThreat
    end
    
        local range = getgenv().DefendRange or 20
    local threat = GetAttackingMobNearPosition(rockPosition, range)
    
    if threat then
                markedThreat = threat
        return true, threat
    end
    
    return false, nil
end

Helpers.IsRockSelected = function(rockName)
    return Helpers.IsSelected(rockName, getgenv().SelectedRocks)
end

Helpers.IsPlayerNearRock = function(rockPart, avoidDistance)
    avoidDistance = tonumber(avoidDistance) or 10
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local playerHrp = player.Character:FindFirstChild("HumanoidRootPart")
            if playerHrp and (playerHrp.Position - rockPart.Position).Magnitude <= avoidDistance then
                return true
            end
        end
    end
    return false
end

local function RockHasDesiredOre(rock)
    if not rock or not rock.Parent then return nil end
    
    local oreChildren = {}
    for _, child in pairs(rock:GetChildren()) do
        local oreAttr = child:GetAttribute("Ore")
        if oreAttr and type(oreAttr) == "string" then
            table.insert(oreChildren, oreAttr)
        end
    end
    
        if #oreChildren == 0 then
        return nil
    end
    
        for _, revealedOre in ipairs(oreChildren) do
        for _, selectedOre in pairs(getgenv().SelectedOres) do
            if revealedOre == selectedOre then
                return true             end
        end
    end
    
        return false
end

local function GetClosestSelectedRock()
    local Rocks = workspace:FindFirstChild("Rocks")
    if not Rocks then return nil end
    
    local character = LocalPlayer.Character
    if not character then return nil end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local bestRock = nil
    local bestValue = nil     local bestPriority = math.huge     local priority = getgenv().MinePriority or "Nearest"
    local useSpecificPriority = getgenv().SpecificPriority and priority == "Nearest"
    
        local now = tick()
    for rock, skipTime in pairs(skippedRocks) do
        if now - skipTime > 65 then
            skippedRocks[rock] = nil
        end
    end
    
        local function IsRockSkipped(rock)
        if not getgenv().OreSkipperEnabled then return false end
        if not skippedRocks[rock] then return false end
                return true
    end
    
        local function IsAreaSelected(areaName)
        if not getgenv().FilterMineByArea then return true end
        if #getgenv().SelectedMineAreas == 0 then return true end
        for _, selected in pairs(getgenv().SelectedMineAreas) do
            if selected == areaName then return true end
        end
        return false
    end
    
        local function GetItemPriority(itemName)
        local priorityOrder = getgenv().PriorityOrder or {}
        return priorityOrder[itemName] or 9999
    end
    
        local validRocks = {}
    
        for _, areaFolder in pairs(Rocks:GetChildren()) do
        if areaFolder:IsA("Folder") then
                        if not IsAreaSelected(areaFolder.Name) then continue end
            
                        for _, spawnLocation in pairs(areaFolder:GetChildren()) do
                                for _, rock in pairs(spawnLocation:GetChildren()) do
                                        local shouldMine = false
                    local mineMode = getgenv().MineMode or "Rocks"
                    
                    if mineMode == "Rocks" then
                        shouldMine = Helpers.IsRockSelected(rock.Name)
                    elseif mineMode == "Ores" then
                        shouldMine = Helpers.RockDropsSelectedOre(rock.Name)
                    end
                    
                    if shouldMine then
                                                if IsRockSkipped(rock) then
                            continue
                        end
                        
                                                if getgenv().AvoidPlayersWhileMining then
                                                        if IsRockBlacklisted(rock) then
                                continue
                            end
                            
                                                        if IsRockBeingMined(rock) then
                                continue
                            end
                        end
                        
                        local health = rock:GetAttribute("Health")
                        health = tonumber(health)
                        if health == nil or health > 0 then
                            local rockPart = nil
                            if rock:IsA("Model") then
                                                                rockPart = rock.PrimaryPart or rock:FindFirstChild("Hitbox") or rock:FindFirstChildOfClass("BasePart")
                            else
                                rockPart = rock
                            end
                            if rockPart and rockPart:IsA("BasePart") then
                                                                if getgenv().AvoidPlayersWhileMining then
                                    if Helpers.IsPlayerNearRock(rockPart, getgenv().PlayerAvoidDistance) then
                                        continue                                     end
                                end
                                
                                local distance = (hrp.Position - rockPart.Position).Magnitude
                                local rockHealth = health or 9999                                 local isBetter = false
                                
                                if useSpecificPriority then
                                                                        local mineMode = getgenv().MineMode or "Rocks"
                                    local itemName = rock.Name
                                    local itemPriority = GetItemPriority(itemName)
                                    
                                                                        if itemPriority < bestPriority then
                                        bestPriority = itemPriority
                                        bestValue = distance
                                        isBetter = true
                                    elseif itemPriority == bestPriority and (bestValue == nil or distance < bestValue) then
                                        bestValue = distance
                                        isBetter = true
                                    end
                                elseif priority == "Nearest" then
                                    if bestValue == nil or distance < bestValue then
                                        bestValue = distance
                                        isBetter = true
                                    end
                                elseif priority == "Weakest" then
                                    if bestValue == nil or rockHealth < bestValue then
                                        bestValue = rockHealth
                                        isBetter = true
                                    end
                                elseif priority == "Strongest" then
                                    if bestValue == nil or rockHealth > bestValue then
                                        bestValue = rockHealth
                                        isBetter = true
                                    end
                                end
                                
                                if isBetter then
                                    bestRock = rock
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    return bestRock
end

local function GetAnyRockInSelectedAreas()
    local Rocks = workspace:FindFirstChild("Rocks")
    if not Rocks then return nil end
    
    local character = LocalPlayer.Character
    if not character then return nil end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local bestRock = nil
    local bestDistance = math.huge
    
        local function IsAreaSelected(areaName)
        if not getgenv().FilterMineByArea then return true end
        if #getgenv().SelectedMineAreas == 0 then return true end
        for _, selected in pairs(getgenv().SelectedMineAreas) do
            if selected == areaName then return true end
        end
        return false
    end
    
        for _, areaFolder in pairs(Rocks:GetChildren()) do
        if areaFolder:IsA("Folder") then
            if not IsAreaSelected(areaFolder.Name) then continue end
            
            for _, spawnLocation in pairs(areaFolder:GetChildren()) do
                for _, rock in pairs(spawnLocation:GetChildren()) do
                    local health = rock:GetAttribute("Health")
                    health = tonumber(health)
                    if health == nil or health > 0 then
                        local rockPart = nil
                        if rock:IsA("Model") then
                            rockPart = rock.PrimaryPart or rock:FindFirstChild("Hitbox") or rock:FindFirstChildOfClass("BasePart")
                        else
                            rockPart = rock
                        end
                        if rockPart and rockPart:IsA("BasePart") then
                                                        if getgenv().AvoidPlayersWhileMining then
                                if IsRockBlacklisted(rock) or IsRockBeingMined(rock) then
                                    continue
                                end
                                if Helpers.IsPlayerNearRock(rockPart, getgenv().PlayerAvoidDistance) then
                                    continue
                                end
                            end
                            
                            local distance = (hrp.Position - rockPart.Position).Magnitude
                            if distance < bestDistance then
                                bestDistance = distance
                                bestRock = rock
                            end
                        end
                    end
                end
            end
        end
    end
    
    return bestRock
end

local function IsRockValid(rock)
    if not rock or not rock.Parent then return false end
        local health = rock:GetAttribute("Health")
    health = tonumber(health)
    if health ~= nil and health <= 0 then return false end
    return true
end

local function SetupMineFly(hrp)
        if mineBodyVelocity then mineBodyVelocity:Destroy() end
    if mineBodyGyro then mineBodyGyro:Destroy() end
    
        mineBodyVelocity = Instance.new("BodyVelocity")
    mineBodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    mineBodyVelocity.Velocity = Vector3.new(0, 0, 0)
    mineBodyVelocity.Parent = hrp
    
        mineBodyGyro = Instance.new("BodyGyro")
    mineBodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    mineBodyGyro.P = 10000
    mineBodyGyro.D = 100
    mineBodyGyro.Parent = hrp
    
    return mineBodyVelocity, mineBodyGyro
end

local function CleanupMineFly()
        pcall(function()
        if mineBodyVelocity and mineBodyVelocity.Parent then mineBodyVelocity:Destroy() end
    end)
    pcall(function()
        if mineBodyGyro and mineBodyGyro.Parent then mineBodyGyro:Destroy() end
    end)
    mineBodyVelocity = nil
    mineBodyGyro = nil
    
        pcall(function()
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.PlatformStand = false
            end
        end
    end)
end

local function StartAutoMine()
    if mineConnection then mineConnection:Disconnect() end
    
        local lastCleanupTime = 0
    
    mineConnection = RunService.Heartbeat:Connect(function()
        if not getgenv().AutoMine then
            currentRockTarget = nil
            CleanupMineFly()
            return
        end
        
                if isDefending then
            return
        end
        
                local now = tick()
        if now - lastCleanupTime > 5 then
            lastCleanupTime = now
            CleanupOccupiedRocks()
        end
        
        local character = LocalPlayer.Character
        if not character then return end
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        
                if currentRockTarget and getgenv().AvoidPlayersWhileMining then
            if IsRockBlacklisted(currentRockTarget) or IsRockBeingMined(currentRockTarget) then
                currentRockTarget = nil             end
        end
        
                if not IsRockValid(currentRockTarget) then
            currentRockTarget = GetClosestSelectedRock()
                        mineFlightPhase = "idle"
            mineLastTargetId = nil
            
                        if not currentRockTarget and getgenv().MineMode == "Ores" then
                local fallback = getgenv().NoRocksFallback or "Wait (No Potions)"
                
                if fallback == "Wait (No Potions)" then
                                        getgenv().NoDesiredRocksAvailable = true
                    if mineBodyVelocity then
                        mineBodyVelocity.Velocity = Vector3.new(0, 0, 0)
                    end
                    return
                elseif fallback == "Mine Any (No Potions)" or fallback == "Mine Any (With Potions)" then
                                        currentRockTarget = GetAnyRockInSelectedAreas()
                    if fallback == "Mine Any (No Potions)" then
                        getgenv().NoDesiredRocksAvailable = true                     else
                        getgenv().NoDesiredRocksAvailable = false                     end
                    
                    if not currentRockTarget then
                                                if mineBodyVelocity then
                            mineBodyVelocity.Velocity = Vector3.new(0, 0, 0)
                        end
                        return
                    end
                end
            elseif not currentRockTarget then
                                if mineBodyVelocity then
                    mineBodyVelocity.Velocity = Vector3.new(0, 0, 0)
                end
                                pcall(function()
                    attackRemote:InvokeServer("Pickaxe")
                end)
                return 
            else
                                getgenv().NoDesiredRocksAvailable = false
            end
        end
        
                local rockPart = nil
        if currentRockTarget:IsA("Model") then
            rockPart = currentRockTarget.PrimaryPart or currentRockTarget:FindFirstChild("Hitbox") or currentRockTarget:FindFirstChildOfClass("BasePart")
        else
            rockPart = currentRockTarget
        end
        if not rockPart or not rockPart:IsA("BasePart") then
            currentRockTarget = nil
            mineFlightPhase = "idle"
            return
        end
        
                local currentTargetId = tostring(currentRockTarget)
        if mineLastTargetId ~= currentTargetId then
            mineLastTargetId = currentTargetId
            mineFlightPhase = "idle"
            mineFlightStartY = hrp.Position.Y
        end
        
                local depthOffset = getgenv().MineDepthOffset or 0
        local targetPosition = rockPart.Position + Vector3.new(0, -depthOffset, mineDistance)
        
                if not mineBodyVelocity or not mineBodyVelocity.Parent then
            SetupMineFly(hrp)
            if humanoid then
                humanoid.PlatformStand = true
            end
        end
        
                        local flySpeed = getgenv().MineFlySpeed or 50
        local mineDistance = getgenv().MineDistance or 2
        local antiGoblin = getgenv().AntiGoblinVillage
        local goblinHeight = getgenv().AntiGoblinHeight or 50
        local now = tick()
        local isCloseEnough = false
        
        if antiGoblin and mineFlightPhase == "idle" then
                        mineFlightPhase = "ascending"
            mineFlightStartY = hrp.Position.Y
        end
        
        if antiGoblin then
            local currentY = hrp.Position.Y
            local targetY = targetPosition.Y
            local safeY = math.max(mineFlightStartY, targetY) + goblinHeight
            
            if mineFlightPhase == "ascending" then
                                if currentY < safeY - 5 then
                    mineBodyVelocity.Velocity = Vector3.new(0, flySpeed, 0)
                    mineBodyGyro.CFrame = CFrame.new(hrp.Position, hrp.Position + Vector3.new(0, 1, 0))
                else
                    mineFlightPhase = "horizontal"
                end
            elseif mineFlightPhase == "horizontal" then
                                local horizontalTarget = Vector3.new(targetPosition.X, currentY, targetPosition.Z)
                local horizontalDir = (horizontalTarget - hrp.Position)
                local horizontalDist = horizontalDir.Magnitude
                
                if horizontalDist > 5 then
                    mineBodyVelocity.Velocity = horizontalDir.Unit * flySpeed
                    mineBodyGyro.CFrame = CFrame.new(hrp.Position, horizontalTarget)
                else
                    mineFlightPhase = "descending"
                end
            elseif mineFlightPhase == "descending" then
                                local direction = (targetPosition - hrp.Position)
                local distance = direction.Magnitude
                
                if distance > 1 then
                    mineBodyVelocity.Velocity = direction.Unit * flySpeed
                else
                    mineFlightPhase = "mining"
                    mineBodyVelocity.Velocity = Vector3.new(0, 0, 0)
                    isCloseEnough = true
                end
                mineBodyGyro.CFrame = CFrame.new(hrp.Position, rockPart.Position)
            else                                 local direction = (targetPosition - hrp.Position)
                local distance = direction.Magnitude
                
                if distance > 1 then
                    mineBodyVelocity.Velocity = direction.Unit * flySpeed
                else
                    mineBodyVelocity.Velocity = Vector3.new(0, 0, 0)
                    isCloseEnough = true
                end
                mineBodyGyro.CFrame = CFrame.new(hrp.Position, rockPart.Position)
            end
        else
                        local direction = (targetPosition - hrp.Position)
            local distance = direction.Magnitude
            
            if distance > 1 then
                                mineBodyVelocity.Velocity = Helpers.GetSafeFlyVelocity(hrp.Position, targetPosition, flySpeed)
            else
                                mineBodyVelocity.Velocity = Vector3.new(0, 0, 0)
                isCloseEnough = true
            end
            
                        mineBodyGyro.CFrame = CFrame.new(hrp.Position, rockPart.Position)
        end
        
                if isCloseEnough then
                        if getgenv().DefendWhileMining and now - lastDefendCheck >= DEFEND_CHECK_INTERVAL then
                lastDefendCheck = now
                
                local shouldDefend, threat = ShouldDefend(hrp.Position)
                if shouldDefend and threat then
                    isDefending = true
                    
                                        local rockToResume = currentRockTarget
                    
                                        CleanupMineFly()
                    
                    WindUI:Notify({
                        Title = "Defending",
                        Content = "Killing " .. threat.Name,
                        Duration = 2,
                        Icon = "sword",
                    })
                    
                                        KillThreat(threat)
                    
                                        currentRockTarget = rockToResume
                    isDefending = false
                    
                                        if hrp then
                        SetupMineFly(hrp)
                        if humanoid then
                            humanoid.PlatformStand = true
                        end
                    end
                    
                    return                 end
            end
        end
        
                if now - lastMineTime >= 0.3 then
            lastMineTime = now
            pcall(function()
                attackRemote:InvokeServer("Pickaxe")
            end)
            
                        if getgenv().MineMode == "Ores" and getgenv().OreSkipperEnabled and currentRockTarget then
                local hasDesiredOre = RockHasDesiredOre(currentRockTarget)
                if hasDesiredOre == false then
                                                            skippedRocks[currentRockTarget] = tick()
                    currentRockTarget = nil
                    
                                        if now - lastSkipNotifyTime >= 1 then
                        lastSkipNotifyTime = now
                        WindUI:Notify({
                            Title = "Ore Skipper",
                            Content = "Skipped rock - no desired ores found",
                            Duration = 1,
                            Icon = "fast-forward",
                        })
                    end
                    return                 end
                            end
        end
    end)
end

StartAutoMine()


-- Optimized transparent assets (overrides previous implementation)
function setMiscTransparent(enabled)
    local state = getgenv().MiscState
    state.transparent = enabled

    if state.conns.transparent then
        state.conns.transparent:Disconnect()
        state.conns.transparent = nil
    end

    if not enabled then
        for part in pairs(state.isChanged) do
            if part and part.Parent and state.originalTransparency[part] ~= nil then
                pcall(function()
                    part.Transparency = state.originalTransparency[part]
                end)
            end
        end
        state.originalTransparency = {}
        state.isChanged = {}
        return
    end

    local Assets = workspace:FindFirstChild("Assets")
    local Rocks = workspace:FindFirstChild("Rocks")
    if not Assets and not Rocks then
        WindUI:Notify({
            Title = "Error",
            Content = "Assets/Rocks folders not found",
            Duration = 3,
            Icon = "alert-circle"
        })
        return
    end

    local Camera = workspace.CurrentCamera
    local previousBlockers = {}

    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    rayParams.IgnoreWater = true

    local lastUpdate = 0
    state.conns.transparent = RunService.RenderStepped:Connect(function(dt)
        lastUpdate += dt
        if lastUpdate < 0.1 then
            return
        end
        lastUpdate = 0

        local char = LocalPlayer.Character
        if not char then
            return
        end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then
            return
        end

        local tval = state.transparentValue
        local origTrans = state.originalTransparency
        local isChanged = state.isChanged

        local camPos = Camera.CFrame.Position
        local camCF = Camera.CFrame
        local targetPos = hrp.Position
        local toTarget = targetPos - camPos
        local distance = toTarget.Magnitude
        if distance < 1 then
            return
        end

        local maxCheckDistance = math.min(distance, state.transparentRadius or distance)

        local currentBlockers = {}

        local rayTargets = {}
        table.insert(rayTargets, targetPos)
        table.insert(rayTargets, targetPos + Vector3.new(0, 2, 0))
        table.insert(rayTargets, targetPos - Vector3.new(0, 2, 0))

        local spread = math.min(distance * 0.4, 15)
        local right = camCF.RightVector
        local up = camCF.UpVector

        table.insert(rayTargets, targetPos + right * spread)
        table.insert(rayTargets, targetPos - right * spread)
        table.insert(rayTargets, targetPos + up * spread)
        table.insert(rayTargets, targetPos - up * spread)

        local midPoint = camPos:Lerp(targetPos, 0.5)
        table.insert(rayTargets, midPoint)

        local baseExclude = { char }

        local function castLine(origin, target)
            local dir = target - origin
            local dist = dir.Magnitude
            if dist < 1 then
                return
            end

            dist = math.min(dist, maxCheckDistance)
            dir = dir.Unit * dist

            local exclude = { unpack(baseExclude) }
            local maxHits = 3

            while maxHits > 0 do
                rayParams.FilterDescendantsInstances = exclude
                local result = workspace:Raycast(origin, dir, rayParams)
                if not result or not result.Instance then
                    break
                end

                local part = result.Instance
                table.insert(exclude, part)

                if not part:IsA("BasePart") then
                    maxHits -= 1
                    continue
                end

                local inAssets = Assets and part:IsDescendantOf(Assets)
                local inRocks = Rocks and part:IsDescendantOf(Rocks)

                if inRocks then
                    local partName = part.Name:lower()
                    if partName == "hitbox" or partName == "ore" then
                        maxHits -= 1
                        continue
                    end
                end

                if inAssets or inRocks then
                    currentBlockers[part] = true
                    if not isChanged[part] then
                        origTrans[part] = part.Transparency
                        part.Transparency = tval
                        isChanged[part] = true
                    end
                end

                maxHits -= 1
            end
        end

        for _, target in ipairs(rayTargets) do
            castLine(camPos, target)
        end

        for part in pairs(previousBlockers) do
            if not currentBlockers[part] and isChanged[part] then
                if part and part.Parent then
                    part.Transparency = origTrans[part] or 0
                    isChanged[part] = nil
                end
            end
        end

        previousBlockers = currentBlockers
    end)
end
